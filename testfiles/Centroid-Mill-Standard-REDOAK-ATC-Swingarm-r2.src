; File:           Centroid-Mill-Standard-REDOAK-ATC-Swingarm-r2.src
; Programmer:     Mario Lopes
; Date:           June 26, 2018
; Purpose:        Swingarm ATC PLC Program for REDOAK
; Requires:       CNC12 v4.09 r13+
;
; Mods: 26 FEB 2019 MML Red button on wireless MPG acts like Cycle Cancel
;       16 OCT 2018 MML	Updated USB MPG feedrate logic

; Custom Macros:
;	M13 is used to cycle the swingarm
;	M14 is used to move the pot down
;	M15 is used to move the pot up
;	M18 is used to initialize the tool changer
;	M19 is used to orient the spindle
;	M20 is used to turn off the orient request
;	M21 is used to turn the chip pump on
;	M22 is used to turn the chip pump off
;	M31 is used to turn the chip auger forward
;	M32 is used to turn the chip auger reverse
;	M33 is used to turn the chip auger off

; SV_MACHINE_PARAMETER_218 = 0 = Wired MPG, > 0 = Wireless MPG 
; SV_MACHINE_PARAMETER_219 = 0 = No VCP, 1 = Start VCP on boot
; SV_MACHINE_PARAMETER_348 = 15 (MPG encoder)

; The REDOAK board includes connections for several types of auxiliary I/O.
; 4 digital "high speed" inputs (INP769-772) typically used for probe/TT1
; related functions, 3 auxiliary digital inputs (INP784-786), 11 Digital inputs
; used for MPG increment and axis selection and 2 auxiliary digital outputs
; (Out770-771).

; Inputs: The REDOAK provides 16 inputs which are available for general
; purpose use.  Inputs 1-16 can be configured for 5, 12 or 24VDC operation
; in either a sourcing or sinking configuration.

; Outputs: The REDOAK has 9 relay contact closure outputs.  Outputs 1-7
; are SPST type relays while outputs 8 & 9 are SPDT type relays.
; Outputs 15 and 16 are for internal PLC hardware use only, being used to 
; set the mode of operation for the spindle analog output.

; Analog input: The 12 bit analog input on the REDOAK is mapped to
; inputs 17-32.

; Analog output: The 16 bit analog output on the REDOAK is mapped to
; outputs 17-32.
;
;=============================================================================
;                   CONSTANT DEFINITIONS
;=============================================================================
PLC_EXECUTOR_FLT_MSG   				 IS 257;(1+256*1)
AXIS1_INFLT            				 IS 1282;(2+256*5) Fiber to MPU11 from axis drive has a problem
AXIS2_INFLT            				 IS 1538;(2+256*6)
AXIS3_INFLT            				 IS 1794;(2+256*7)
AXIS4_INFLT            				 IS 2050;(2+256*8)
AXIS5_INFLT            				 IS 2306;(2+256*9)
AXIS6_INFLT            				 IS 2562;(2+256*10)
AXIS7_INFLT            				 IS 2818;(2+256*11)
AXIS8_INFLT            				 IS 3074;(2+256*12)

AXIS1_OUTFLT           				 IS 3330;(2+256*13) Fiber to axis drive from MPU11 has a problem
AXIS2_OUTFLT           				 IS 3586;(2+256*14)
AXIS3_OUTFLT           				 IS 3842;(2+256*15)
AXIS4_OUTFLT           				 IS 4098;(2+256*16)
AXIS5_OUTFLT           				 IS 4354;(2+256*17)
AXIS6_OUTFLT           				 IS 4610;(2+256*18)
AXIS7_OUTFLT           				 IS 4866;(2+256*19)
AXIS8_OUTFLT           				 IS 5122;(2+256*20)

AXIS_FLT_CLR           				 IS 5378;(2+256*21)

PLC_INFLT              				 IS 5634;(2+256*22)
PLC_OUTFLT             				 IS 5890;(2+256*23)
PLC_FLT_CLR            				 IS 6146;(2+256*24)

AXIS1_DRIVE_FAULT      				 IS 6401;(1+256*25)
AXIS2_DRIVE_FAULT      				 IS 6657;(1+256*26)
AXIS3_DRIVE_FAULT      				 IS 6913;(1+256*27)
AXIS4_DRIVE_FAULT      				 IS 7169;(1+256*28)
AXIS5_DRIVE_FAULT      				 IS 7425;(1+256*29)

SPINDLE_FAULT          				 IS 7681;(1+256*30)
SPINDLE_CHILLER_FAULT  				 IS 7937;(1+256*31)

JOGBOARD_INFLT                       IS 8193;(1+256*32)
JOGBOARD_OUTFLT                      IS 8449;(1+256*33)

PROBE_FAULT_MSG        				 IS 8705;(1+256*34)

KB_JOG_MSG             				 IS 8962;(2+256*35)

LUBE_FAULT_MSG         				 IS 9217;(1+256*36)
LUBE_WARNING_MSG       				 IS LUBE_FAULT_MSG+1
PROBE_JOG_FAULT_MSG    				 IS 9473;(1+256*37)

MIN_SPEED_MSG          				 IS 9730;(2+256*38)
SOFTWARE_EXIT_MSG      				 IS 9985;(1+256*39)

RESET_CLEARED                        IS 10242;(2+256*40)                              
RESET_DETECTED                       IS 10497;(1+256*41)

AUTO_COOL_MSG                        IS 10753;(1+256*42)
MAN_COOL_MSG                         IS 11010;(2+256*43)

AUTO_SPINDLE_PROMPT                  IS 11522;(2+256*45)
AUTO_COOLANT_PROMPT                  IS 11778;(2+256*46)

MSG_CLEARED_MSG        				 IS 25345;(1+256*99)

;// ATC FAULT Message Definitions:

ATC_NR_ARM_HOME                      IS 25857;(1+256*101)
ATC_NR_ARM_AT_CLAMP                  IS 26113;(1+256*102)
ATC_NR_ARM_AT_STOP                   IS 26369;(1+256*103)
ATC_NR_TOOL_UNCLMP                   IS 26625;(1+256*104)
ATC_NR_TOOL_CLMP                     IS 26881;(1+256*105)
ATC_NR_POT_DOWN                      IS 27137;(1+256*106)
ATC_NR_POT_UP                        IS 27393;(1+256*107)
ATC_NR_TOOL_COUNTER                  IS 27649;(1+256*108)
ATC_BIN_OUT_OF_RANGE                 IS 27905;(1+256*109)
ATC_NR_MZ_ACK                        IS 28161;(1+256*110)
ATC_TIMEOUT_MOVE_Z_STAGE             IS 28417;(1+256*111)
ATC_TIMEOUT_ORIENT_STAGE             IS 28673;(1+256*112)
ATC_TIMEOUT_POT_DOWN_STAGE           IS 28929;(1+256*113)
ATC_ORIENT_LOST_POT_DOWN_STAGE       IS 29185;(1+256*114)
ATC_CLAMP_WO_STOP_AHTC_STAGE         IS 29441;(1+256*115)
ATC_TIMEOUT_ARM_TO_CLAMP             IS 29697;(1+256*116)
ATC_TIMEOUT_WAIT_STOP_AHTC_STAGE     IS 29953;(1+256*117)
ATC_HOME_CLAMP_WO_STOP_AHTC_STAGE    IS 30209;(1+256*118)
ATC_TIMEOUT_UNCLAMP_STAGE            IS 30465;(1+256*119)
ATC_TIMEOUT_ARM_D180UP_STAGE         IS 30721;(1+256*120)
ATC_TIMEOUT_ARM_D1UWS_STAGE          IS 30977;(1+256*121)
ATC_HOME_CLAMP_WO_STOP               IS 31233;(1+256*122)
ATC_TIMEOUT_CLAMP_STAGE              IS 31489;(1+256*123)
ATC_TIMEOUT_ARM_CTH                  IS 31745;(1+256*124)
ATC_WO_STOP_ACTH_HOME_STAGE          IS 32001;(1+256*125)
ATC_TIMEOUT_ARM_HTCWS_STAGE          IS 32257;(1+256*126)
ATC_WO_STOP_ARM_HOME_CLAMP           IS 32513;(1+256*127)
ATC_TIMEOUT_POT_UP_STAGE             IS 32769;(1+256*128)
ATC_TIMEOUT_END_STAGE                IS 33025;(1+256*129)
ATC_CLAMP_FAULT_ARM_D180UP_STAGE     IS 33537;(1+256*131)
ATC_CLAMP_FAULT_ARM_D1UWS_STAGE      IS 33793;(1+256*132)
ATC_TOOL_COUNTER_NOISE               IS 34049;(1+256*133)
ATC_TIMEOUT_TOOL_COUNTER             IS 34305;(1+256*134)
ATC_POT_FAULT_ROTATE_STAGE           IS 34561;(1+256*135)
ATC_TOOL_COUNTER_NOISE_COUNT_STAGE   IS 34817;(1+256*136)
ATC_TIMEOUT_TOOL_COUNTER_COUNT_STAGE IS 35073;(1+256*137)
ATC_POT_FAULT_COUNT_STAGE            IS 35329;(1+256*138)
ATC_INITIALIZED                      IS 35586;(2+256*139)
ATC_TOOL_COUNTER_FAULT_CLEARED       IS 35842;(2+256*140)
LOW_AIR_FAULT                        IS 36353;(1+256*142)
M19_FAULT_TOOL_CLAMPED               IS 36609;(1+256*143)
M19_STOPPED_M19_STAGE                IS 36865;(1+256*144)
M19_ORIENT_LOST_M19_MON_STAGE        IS 37121;(1+256*145)

MINI_PLC_1_FLT_MSG                   IS 39169;(1+256*153)
MINI_PLC_2_FLT_MSG                   IS 39425;(1+256*154)
MINI_PLC_3_FLT_MSG                   IS 39681;(1+256*155)
MINI_PLC_4_FLT_MSG                   IS 39937;(1+256*156)
MINI_PLC_5_FLT_MSG                   IS 40193;(1+256*157)
MINI_PLC_6_FLT_MSG                   IS 40449;(1+256*158)
MINI_PLC_7_FLT_MSG                   IS 40705;(1+256*159)
MINI_PLC_8_FLT_MSG                   IS 40961;(1+256*160)
MINI_PLC_1_WARNING                   IS 41218;(2+256*161)
MINI_PLC_2_WARNING                   IS 41474;(2+256*162)
MINI_PLC_3_WARNING                   IS 41730;(2+256*163)
MINI_PLC_4_WARNING                   IS 41986;(2+256*164)
MINI_PLC_5_WARNING                   IS 42242;(2+256*165)
MINI_PLC_6_WARNING                   IS 42498;(2+256*166)
MINI_PLC_7_WARNING                   IS 42754;(2+256*167)
MINI_PLC_8_WARNING                   IS 43010;(2+256*168)

DOOR_NOT_CLOSED                      IS 49922;(2+256*195)
WAITING_FOR_DOOR_LOCKED              IS 50178;(2+256*196)
DOOR_NOT_LOCKED                      IS 50433;(1+256*197)
DOOR_OPEN_MESSAGE                    IS 50689;(1+256*198)

;-------------------------------------------------------------------------------
;        PLC Input Definitions
;-------------------------------------------------------------------------------
; Logic 1 = CLOSED SWITCH, 0 = OPEN SWITCH

;// INP1 - INP768 Physical PLC inputs
Ax1_MinusLimitOk        	  IS INP1
Ax1_PlusLimitOk         	  IS INP2
Ax2_MinusLimitOk        	  IS INP3
Ax2_PlusLimitOk         	  IS INP4
Ax3_MinusLimitOk        	  IS INP5
Ax3_PlusLimitOk         	  IS INP6
RotaryHome		        	  IS INP7
DoorClosed		        	  IS INP8
LubeOk                  	  IS INP9
SpindleInverterOk       	  IS INP10
EStopOk                 	  IS INP11   ; 1 = OK
ZeroSpeed               	  IS INP12
SpinLowRange            	  IS INP13   
;spare		              	  IS INP14
;spare 	                	  IS INP15
;spare		            	  IS INP16
	                          
AnalogInput					  IS INP17   ;12 bit - Read on INP17-32

;-------------------------------------------------------------------------------
; This section is on 1st PLCEXP1616 board
;-------------------------------------------------------------------------------

OrientComplete          	  IS INP33   ;IN1
AirPressureOk           	  IS INP34   ;IN2
ChillerOk               	  IS INP35   ;IN3
DoorLocked	            	  IS INP36   ;IN4
ToolClamped             	  IS INP37   ;IN5
ToolUnclamped           	  IS INP38   ;IN6
ToolRelease             	  IS INP39   ;IN7
ToolCounter             	  IS INP40   ;IN8
ArmAtStopInput          	  IS INP41   ;IN9
ArmAtHomeInput          	  IS INP42   ;IN10
ArmAtClampInput         	  IS INP43   ;IN11
CarouselAtHome          	  IS INP44   ;IN12
PotUp		            	  IS INP45   ;IN13
PotDown		            	  IS INP46   ;IN14
;spare		            	  IS INP47   ;IN15
;spare		            	  IS INP48   ;IN16

;-------------------------------------------------------------------------------
; M-Function bits are no longer mapped as PLC inputs 33-48.  M-Function bits are 
; now mapped as system variables.  See system variables section.
;-------------------------------------------------------------------------------
;                       INP49-58, INP63 ->....
; INP 59-62 moved to 34-37
;-------------------------------------------------------------------------------
; INP769 - INP784 Reserved for DPx/TTx/MPG connections.
;-------------------------------------------------------------------------------

MechanicalProbe       		  IS INP769
DSPProbe              		  IS INP770
ProbeDetect           		  IS INP771
ProbeAux              		  IS INP772
MPG_Inc_X_1           		  IS INP773
MPG_Inc_X_10          		  IS INP774
MPG_Inc_X_100         		  IS INP775
MPG_AXIS_1            		  IS INP776
MPG_AXIS_2            		  IS INP777
MPG_AXIS_3            		  IS INP778
MPG_AXIS_4            		  IS INP779
MPG_AXIS_5            		  IS INP780
MPG_AXIS_6            		  IS INP781
MPG_AXIS_7            		  IS INP782
MPG_AXIS_8            		  IS INP783

;-------------------------------------------------------------------------------
; Jog panel inputs are mapped to INP1057-INP1312. Alternatively, jog panel 
; inputs can also be referenced as JPI1 through JPI256.
;-------------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey               IS INP1057  ; Row  1 Column 1
SpinAutoManKey                IS INP1058  ; Row  1 Column 2
Aux1Key                       IS INP1059  ; Row  1 Column 3
Aux2Key                       IS INP1060  ; Row  1 Column 4
Aux3Key                       IS INP1061  ; Row  1 Column 5
                              
SpinOver100Key                IS INP1062  ; Row  2 Column 1
SpinCWKey                     IS INP1063  ; Row  2 Column 2
Aux4Key                       IS INP1064  ; Row  2 Column 3
Aux5Key                       IS INP1065  ; Row  2 Column 4
Aux6Key                       IS INP1066  ; Row  2 Column 5
                              
SpinOverMinusKey              IS INP1067  ; Row  3 Column 1
SpinCCWKey                    IS INP1068  ; Row  3 Column 2
Aux7Key		                  IS INP1069  ; Row  3 Column 3
Aux8Key 		              IS INP1070  ; Row  3 Column 4
Aux9Key          	  	      IS INP1071  ; Row  3 Column 5
                                          ;
SpinStopKey                   IS INP1072  ; Row  4 Column 1
SpinStartKey                  IS INP1073  ; Row  4 Column 2
Aux10Key                      IS INP1074  ; Row  4 Column 3
Aux11Key                      IS INP1075  ; Row  4 Column 4
Aux12Key                      IS INP1076  ; Row  4 Column 5
                              
CoolAutoManKey                IS INP1077  ; Row  5 Column 1
CoolFloodKey                  IS INP1078  ; Row  5 Column 2
CoolMistKey                   IS INP1079  ; Row  5 Column 3
Aux13Key                      IS INP1080  ; Row  5 Column 4
ATCOverrideKey                IS INP1081  ; Row  5 Column 5
                              
IncrContKey                   IS INP1082  ; Row  6 Column 1
x1JogKey                      IS INP1083  ; Row  6 Column 2
x10JogKey                     IS INP1084  ; Row  6 Column 3
x100JogKey                    IS INP1085  ; Row  6 Column 4
MPGKey                        IS INP1086  ; Row  6 Column 5
                              
Ax4PlusJogKey                 IS INP1087  ; Row  7 Column 1
UnusedR7C2Key                 IS INP1088  ; Row  7 Column 2
Ax2PlusJogKey                 IS INP1089  ; Row  7 Column 3
UnusedR7C4Key                 IS INP1090  ; Row  7 Column 4
Ax3PlusJogKey                 IS INP1091  ; Row  7 Column 5
                              
UnusedR8C1Key                 IS INP1092  ; Row  8 Column 1
Ax1MinusJogKey                IS INP1093  ; Row  8 Column 2
FastSlowKey                   IS INP1094  ; Row  8 Column 3
Ax1PlusJogKey                 IS INP1095  ; Row  8 Column 4
UnusedR8C5Key                 IS INP1096  ; Row  8 Column 5
                              
Ax4MinusJogKey                IS INP1097  ; Row  9 Column 1
UnusedR9C2Key                 IS INP1098  ; Row  9 Column 2
Ax2MinusJogKey                IS INP1099  ; Row  9 Column 3
UnusedR9C4Key                 IS INP1100  ; Row  9 Column 4
Ax3MinusJogKey                IS INP1101  ; Row  9 Column 5
                              
CycleCancelKey                IS INP1102  ; Row 10 Column 1
SingleBlockKey                IS INP1103  ; Row 10 Column 2
ToolCheckKey                  IS INP1104  ; Row 10 Column 3
FeedHoldKey                   IS INP1105  ; Row 10 Column 4
CycleStartKey                 IS INP1106  ; Row 10 Column 5

;-------------------------------------------------------------------------------
;                    Feedrate Override Knob
;-------------------------------------------------------------------------------

JpFeedOrKnobBit0              IS INP1249
JpFeedOrKnobBit1              IS INP1250
JpFeedOrKnobBit2              IS INP1251
JpFeedOrKnobBit3              IS INP1252
JpFeedOrKnobBit4              IS INP1253
JpFeedOrKnobBit5              IS INP1254
JpFeedOrKnobBit6              IS INP1255
JpFeedOrKnobBit7              IS INP1256
JpFeedOrKnobBit8              IS INP1257 ; Current jog panels send first 8 bits
JpFeedOrKnobBit9              IS INP1258 ; unused
JpFeedOrKnobBit10             IS INP1259 ; unused
JpFeedOrKnobBit11             IS INP1260 ; unused
JpFeedOrKnobBit12             IS INP1261 ; unused
JpFeedOrKnobBit13             IS INP1262 ; unused
JpFeedOrKnobBit14             IS INP1263 ; unused
JpFeedOrKnobBit15             IS INP1264 ; unused

;-------------------------------------------------------------------------------
;       PLC Output Definitions
;-------------------------------------------------------------------------------

;// OUT1 - OUT768 Physical PLC outputs
NoFaultOut              	  IS OUT1    
LubeOut                 	  IS OUT2    
FloodOut                	  IS OUT3    
MistOut                 	  IS OUT4    
InverterResetOut        	  IS OUT5  
WorkLightOut            	  IS OUT6
SpindleEnableOut        	  IS OUT7  
SpindleDirectionOut     	  IS OUT8   ; SPDT - 1 = CCW
ZBrakeRelease           	  IS OUT9   ; SPDT

ResetSet					  IS OUT10  ; Logic use only

SpindleDACModeBit1      	  IS OUT15  ; Used to set voltage range and polarity, see table below
SpindleDACModeBit2      	  IS OUT16  ; Used to set voltage range and polarity, see table below

; The following bits control the actual analog hardware output on the REDOAK.
; Output = 16bit (0-65536) Default 0-10VDC.
; Different analog ranges are available by setting outputs 15 and 16:
; ----------------------------------------
; | Output 15 | Output 16 | Range         |
; |     0     |     0     | 0 to +10VDC   |
; |     0     |     1     | 0 to +5VDC    |
; |     1     |     0     | -5 to +5VDC   |
; |     1     |     1     | -10 to +10VDC | 
; -----------------------------------------

; These bits control the actual analog hardware output on the REDOAK.
; Output = 16bit (0-32768) 0-10VDC.									   
SpinAnalogOutBit0             IS OUT17
SpinAnalogOutBit1             IS OUT18
SpinAnalogOutBit2             IS OUT19
SpinAnalogOutBit3             IS OUT20
SpinAnalogOutBit4             IS OUT21
SpinAnalogOutBit5             IS OUT22
SpinAnalogOutBit6             IS OUT23
SpinAnalogOutBit7             IS OUT24
SpinAnalogOutBit8             IS OUT25
SpinAnalogOutBit9             IS OUT26
SpinAnalogOutBit10            IS OUT27
SpinAnalogOutBit11            IS OUT28
SpinAnalogOutBit12            IS OUT29
SpinAnalogOutBit13            IS OUT30
SpinAnalogOutBit14            IS OUT31
SpinAnalogOutBit15            IS OUT32

;-------------------------------------------------------------------------------
; This section is on 1st PLCEXP1616 board
;-------------------------------------------------------------------------------

OrientRequestOut        	  IS OUT33  ; OUT1
SpindleChillerOut       	  IS OUT34  ; OUT2
CoolingFanOut           	  IS OUT35  ; OUT3
DoorLockOut             	  IS OUT36  ; OUT4
;spare	                	  IS OUT37  ; OUT5
ToolUnclampOut          	  IS OUT38  ; OUT6
MagMotorEnableOut       	  IS OUT39  ; OUT7
MagMotorMinusOut        	  IS OUT40  ; OUT8 SPDT - 1 = Tool Magazine Minus Dir
RedLightOut             	  IS OUT41  ; OUT9 SPDT
AirBlowOut              	  IS OUT42  ; OUT10
ChipPumpOut               	  IS OUT43  ; OUT11
ArmMotorOut             	  IS OUT44  ; OUT12
PotUpOut	            	  IS OUT45  ; OUT13
PotDownOut	            	  IS OUT46  ; OUT14
GreenLightOut           	  IS OUT47  ; OUT15
AmberLightOut           	  IS OUT48  ; OUT16

;-------------------------------------------------------------------------------
; This section is on 2nd PLCEXP1616 board
;-------------------------------------------------------------------------------

;spare		            	  IS OUT49  ; OUT1
;spare  	            	  IS OUT50  ; OUT2
;spare			        	  IS OUT51  ; OUT3
;spare			        	  IS OUT52  ; OUT4
;spare			        	  IS OUT53  ; OUT5
;spare	                	  IS OUT54  ; OUT6
Auger1Enable	         	  IS OUT55  ; OUT7
Auger1DirOut            	  IS OUT56  ; OUT8 SPDT
Auger2DirOut                  IS OUT57  ; OUT9 SPDT
Auger2Enable                  IS OUT58  ; OUT10
;spare                  	  IS OUT59  ; OUT11
;spare                  	  IS OUT60  ; OUT12
;spare                  	  IS OUT61  ; OUT13
;spare                  	  IS OUT62  ; OUT14
;spare                  	  IS OUT63  ; OUT15
DriveResetOut              	  IS OUT64  ; OUT16

MPG_LED_OUT             	  IS OUT769

;-------------------------------------------------------------------------------
;              Jog Panel Output (LED) Definitions
;       Jog Panel LEDs can be addressed as OUT1057 - OUT1312
;                              OR
;                         JPO1 - JPO256
;-------------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusLED               IS OUT1057; Row  1 Column 1
SpinAutoModeLED               IS OUT1058; Row  1 Column 2
Aux1LED                       IS OUT1059; Row  1 Column 3
Aux2LED                       IS OUT1060; Row  1 Column 4
Aux3LED                       IS OUT1061; Row  1 Column 5
                              
SpinOver100LED                IS OUT1062; Row  2 Column 1
SpindleCWLED                  IS OUT1063; Row  2 Column 2
Aux4LED                       IS OUT1064; Row  2 Column 3
Aux5LED                       IS OUT1065; Row  2 Column 4
Aux6LED                       IS OUT1066; Row  2 Column 5
                              
SpinOverMinusLED              IS OUT1067; Row  3 Column 1
SpindleCCWLED                 IS OUT1068; Row  3 Column 2
Aux7LED  	                  IS OUT1069; Row  3 Column 3
Aux8LED                       IS OUT1070; Row  3 Column 4
Aux9LED                       IS OUT1071; Row  3 Column 5
                              
SpinStopLED                   IS OUT1072; Row  4 Column 1
SpinStartLED                  IS OUT1073; Row  4 Column 2
Aux10LED                      IS OUT1074; Row  4 Column 3
Aux11LED                      IS OUT1075; Row  4 Column 4
Aux12LED                      IS OUT1076; Row  4 Column 5
                              
CoolAutoModeLED               IS OUT1077; Row  5 Column 1
CoolFloodLED                  IS OUT1078; Row  5 Column 2
CoolMistLED                   IS OUT1079; Row  5 Column 3
Aux13LED                      IS OUT1080; Row  5 Column 4
Aux14LED                      IS OUT1081; Row  5 Column 5
                              
IncrContLED                   IS OUT1082 ; Row  6 Column 1
x1JogLED                      IS OUT1083 ; Row  6 Column 2
x10JogLED                     IS OUT1084 ; Row  6 Column 3
x100JogLED                    IS OUT1085 ; Row  6 Column 4
MPGLED                        IS OUT1086 ; Row  6 Column 5
                              
Ax4PlusJogLED                 IS OUT1087 ; Row  7 Column 1
UnusedR7C2LED                 IS OUT1088 ; Row  7 Column 2
Ax2PlusJogLED                 IS OUT1089 ; Row  7 Column 3
UnusedR7C4LED                 IS OUT1090 ; Row  7 Column 4
Ax3PlusJogLED                 IS OUT1091 ; Row  7 Column 5
                              
UnusedR8C1LED                 IS OUT1092 ; Row  8 Column 1
Ax1MinusJogLED                IS OUT1093 ; Row  8 Column 2
FastSlowLED                   IS OUT1094 ; Row  8 Column 3
Ax1PlusJogLED                 IS OUT1095 ; Row  8 Column 4
UnusedR8C5LED                 IS OUT1096 ; Row  8 Column 5
                              
Ax4MinusJogLED                IS OUT1097 ; Row  9 Column 1
UnusedR9C2LED                 IS OUT1098 ; Row  9 Column 2
Ax2MinusJogLED                IS OUT1099 ; Row  9 Column 3
UnusedR9C4LED                 IS OUT1100 ; Row  9 Column 4
Ax3MinusJogLED                IS OUT1101 ; Row  9 Column 5
                              
CycleCancelLED                IS OUT1102 ; Row 10 Column 1
SingleBlockLED                IS OUT1103 ; Row 10 Column 2
ToolCheckLED                  IS OUT1105 ; Row 10 Column 3
FeedHoldLED                   IS OUT1104 ; Row 10 Column 4

;-------------------------------------------------------------------------------															 
;                        Memory Bit Definitions
;-------------------------------------------------------------------------------

PLCExecutorFault_M            IS MEM1
SoftwareNotReady_M            IS MEM2   ; 0 = okay, 1 = CNC11 not running/ready
MPGManOffFlag_M               IS MEM3
BelowMinSpeed_M               IS MEM4
SoftwareReady_M				  IS MEM5

LightBlinkOff_M				  IS MEM6

DoingM6_M					  IS MEM7
DoingRotate_M				  IS MEM8
DoingIndex_M				  IS MEM9
ATCCount_M					  IS MEM10
PreToolChangeOrientMem		  IS MEM11
tempbit						  IS MEM12
ATCRotate_M					  IS MEM13
ArmHasMoved_M				  IS MEM14
ArmHasStopped_M				  IS MEM15
END_REQ_M					  IS MEM16
MZ_REQ_M					  IS MEM17
HU_REQ_M                	  IS MEM18  
HD_REQ_M                	  IS MEM19  
Calc_B1_M               	  IS MEM20
Calc_B2_M               	  IS MEM21
Tool_Noise_Fault_M      	  IS MEM22

Echo_Stall_M            	  IS MEM24
Echo_Stop_M             	  IS MEM25
                              
Ax1PlusJogDisabled_M          IS MEM30
Ax1MinusJogDisabled_M         IS MEM31
Ax2PlusJogDisabled_M          IS MEM32
Ax2MinusJogDisabled_M         IS MEM33
Ax3MinusJogDisabled_M         IS MEM34
                              
Axis1DriveOk                  IS MEM35
Axis2DriveOk                  IS MEM36
Axis3DriveOk                  IS MEM37
Axis4DriveOk                  IS MEM38
Axis5DriveOk                  IS MEM39
                              
MasterEnable_M                IS MEM40  ; 1 = enabled (echo of SV_MASTER_ENABLE)
PLCBus_Oe_M                   IS MEM41  ; 1 = okay, 0 = incoming PLC fiber problem
PLCBusExtDevEn_M              IS MEM42  ; 1 = okay, 0 = PLC reports bad output fiber
JogLinkOk_M                   IS MEM43  ; 1 = okay, 0 = incoming jog panel data problem
JogPanelOnline_M              IS MEM44  ; 1 = okay, 0 = JogBoard reports bad connection
ActivateFeedHold_M            IS MEM45  ; 0 = idle, 1 = trigger feed hold on
ErrorFlag_M                   IS MEM46  ; 0 = okay, 1 = error (but not a fault)
Stop_M                        IS MEM47  ; 0 = okay, 1 = fault (echo of SV_STOP)
Stall_M                       IS MEM48  ; 0 = okay, 1 = stall (echo of SV_STALL_ERROR)
LubeFault_M                   IS MEM49  ; 0 = okay, 1 = lube fault
PLCFault_M                    IS MEM50  ; 0 = okay, 1 = PLC fault
AxisFault_M                   IS MEM51  ; 0 = okay, 1 = drive or drive fiber problem
DriveComFltIn_M               IS MEM52  ; 0 = okay, 1 = incoming drive fiber problem
DriveComFltOut_M              IS MEM53  ; 0 = okay, 1 = outgoing drive fiber problem
ProbeFault_M                  IS MEM54  ; 0 = okay, 1 = tried to start spindle w/probe
JogProbeFault_M               IS MEM55  ; 0 = okay, 1 = tripped probe while jogging
SpindleFault_M                IS MEM56  ; 0 = okay, 1 = spindle drive fault
OtherFault_M                  IS MEM57
                              
KbJpActive_M                  IS MEM60 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
Axis1Fault_M                  IS MEM61
Axis2Fault_M                  IS MEM62
Axis3Fault_M                  IS MEM63
Axis4Fault_M                  IS MEM64
Axis5Fault_M                  IS MEM65
                              
Axis1FiberOk_M                IS MEM70
Axis2FiberOk_M                IS MEM71
Axis3FiberOk_M                IS MEM72
Axis4FiberOk_M                IS MEM73
Axis5FiberOk_M                IS MEM74
Axis6FiberOk_M                IS MEM75
Axis7FiberOk_M                IS MEM76
Axis8FiberOk_M                IS MEM77
                              
ProbeMsgSent_M                IS MEM78
True                          IS MEM79
SpinLowRange_M                IS MEM80
SpinHighRange_M               IS MEM81
SpindleDirection_M            IS MEM82
SpindlePause_M                IS MEM83
LimitTripped_M                IS MEM84
SpinStart_M                   IS MEM85
SpinStop_M                    IS MEM86
SpindleOutRequest_M			  IS MEM87

BadCfg_M                      IS MEM88
UpdatingConfig_M              IS MEM89 
ConfigFaultTrigger_M          IS MEM90
ClampEnabled_M                IS MEM91
                              
DisableKbInput_M              IS MEM101 ;If 1, disable kb jogging
AllowKbInput_M                IS MEM102 ;If 1, allow kb jogging
JogOverOnly_M                 IS MEM103
KbOverOnly_M                  IS MEM104
UsingFeedrateKnob_M           IS MEM105
WaitingForSleepTimer_M        IS MEM106
JogPanelRequired_M            IS MEM107
UsingVirtualOverride_M        IS MEM108										
                              
X1_M                          IS MEM111
X10_M                         IS MEM112
X100_M                        IS MEM113
                              
MiniPLCOk1_M                  IS MEM121
MiniPLCOk2_M                  IS MEM122
MiniPLCOk3_M                  IS MEM123
MiniPLCOk4_M                  IS MEM124
MiniPLCOk5_M                  IS MEM125
MiniPLCOk6_M                  IS MEM126
MiniPLCOk7_M                  IS MEM127
MiniPLCOk8_M                  IS MEM128

AugerKeyStart_M         	  IS MEM130
M31                     	  IS MEM131
M32                     	  IS MEM132
M33                     	  IS MEM133
DoorInterlockMode_M     	  IS MEM134 ; If 1, set slow jog if door open
DoorOpenSlowJog_M       	  IS MEM135 ; If DoorInterlockMode_M and door open then this is set
DoorInterlock_Override_M 	  IS MEM136 ; Allows user to override the door interlock system, for probing with door open for instance
DoorLockDelay_M          	  IS MEM137
                              
MiniPLCExpected1_M            IS MEM137
MiniPLCExpected2_M            IS MEM138
MiniPLCExpected3_M            IS MEM139
MiniPLCExpected4_M            IS MEM140
MiniPLCExpected5_M            IS MEM141
MiniPLCExpected6_M            IS MEM142
MiniPLCExpected7_M            IS MEM143
MiniPLCExpected8_M            IS MEM144
                              
OnAtPowerUp_M                 IS MEM200
EstopCycled_M                 IS MEM201
ResetArmed_M                  IS MEM202									   
LastProbeMode_M               IS MEM210
JogModeSaved_M                IS MEM211
UsbMpgPresent                 IS MEM221										
;MPG bits 32 bits reserved 32 bits open for further use start at  
MpgResetKey_M   	    	  IS MEM230
MpgFeedHold_M				  IS MEM231
MpgCycleStart_M               IS MEM232
UsbMpgJogPlus_M			      IS MEM233
UsbMpgJogMinus_M			  IS MEM234
UsbMpgSpinAutoMan_M    		  IS MEM235
UsbMpgSpinOnOff_M 			  IS MEM236
MpgMacro1_M					  IS MEM237
MpgMacro2_M                   IS MEM238
MpgMacro3_M                   IS MEM239
MpgMacro4_M                   IS MEM240
MpgToolCheck_M                IS MEM241
MpgSetAxisZero_M		      IS MEM242  
UsbMpgOn                      IS MEM243
 
UsbMpgAxis1Active_M           IS MEM245 
UsbMpgAxis2Active_M           IS MEM246 
UsbMpgAxis3Active_M           IS MEM247 
UsbMpgAxis4Active_M           IS MEM248 
InvertXJogKeys_M              IS MEM249
SwapAxes_M                    IS MEM250

;Glue Logic   254+
UsbMpgSpinOnOffPressed_M      IS MEM254
UsbMpgSpinOn_M			      IS MEM255 
UsbMpgSpinOff_M			      IS MEM256 
UsbMpgSpinOnState_M			  IS MEM257 
UsbMpgAxis1Selected_M		  IS MEM258
UsbMpgAxis2Selected_M		  IS MEM259
UsbMpgAxis3Selected_M		  IS MEM260
UsbMpgAxis4Selected_M		  IS MEM261
UsbMpgSpinWheelSelect_M		  IS MEM262
UsbMpgSpinWheelSet_M		  IS MEM263
UsbMpgFeedWheelSelect_M       IS MEM264
UsbMpgFeedWheelSet_M          IS MEM265
UsbMpgAxis1JogPlus_M		  IS MEM266
UsbMpgAxis1JogMinus_M		  IS MEM267
UsbMpgAxis2JogPlus_M		  IS MEM268
UsbMpgAxis2JogMinus_M		  IS MEM269
UsbMpgAxis3JogPlus_M		  IS MEM270
UsbMpgAxis3JogMinus_M		  IS MEM271
UsbMpgAxis4JogPlus_M   		  IS MEM272
UsbMpgAxis4JogMinus_M		  IS MEM273									   
KbCycleStart_M                IS MEM400 ; "alt" + "s"
KbCycleCancel_M               IS MEM401 ; escape
KbToolCheck_M                 IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M            IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M            IS MEM404 ; "Insert"
KbDecreaseJogInc_M            IS MEM405 ; "Delete"
KbIncFeedOver_M               IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M               IS MEM407 ; "ctrl" + "keyboard "-"
KbFeedOver100_M               IS MEM408 ; "ctrl" + "\"
KbTogIncContJog_M             IS MEM409 ; "ctrl" + "i"
KbTogFastSlowJog_M            IS MEM410 ; "ctrl" + "f"
KbJogAx1Plus_M                IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M               IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M                IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M               IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M                IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M               IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M                IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M               IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M                   IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M                   IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M                   IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M                   IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M                   IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M                   IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M                   IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M                   IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M                   IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M                  IS MEM428 ; "ctrl" + "F10"
KbAux11Key_M                  IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M                  IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M              IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M            IS MEM432 ; "ctrl" + "a"
KbSpinCW_M                    IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M                   IS MEM434 ; "ctrl" + "w"
KbSpinStart_M                 IS MEM435 ; "ctrl" + "s"
KbSpinStop_M                  IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M                IS MEM437 ; "ctrl" + "n"
KbMistOnOff_M                 IS MEM438 ; "ctrl" + "k"
KbTogCoolAutoMan_M            IS MEM439 ; "ctrl" + "m"
KbFeedHold_M                  IS MEM440 ; space bar
KbIncSpinOver_M               IS MEM441 ; "ctrl" + ">" (.)
KbDecSpinOver_M               IS MEM442 ; "ctrl" + "<" (,)
KbSpinOver100_M               IS MEM443 ; "ctrl" + "?" (/)
                              
Axis1StatusBit0               IS MEM500
Axis1StatusBit1               IS MEM501
Axis1StatusBit2               IS MEM502
Axis1StatusBit3               IS MEM503
Axis1StatusTP                 IS MEM504
Axis1StatusALM3               IS MEM505
Axis1StatusALM2               IS MEM506
Axis1StatusALM1               IS MEM507
Axis1StatusTGON               IS MEM508
Axis1StatusBRAKE              IS MEM509
Axis1StatusSRDY               IS MEM510
Axis1StatusQUADERR            IS MEM511
Axis1StatusDIR                IS MEM512
Axis1StatusZ                  IS MEM513
Axis1StatusDIFF_ERR           IS MEM514
Axis1DriveALM                 IS MEM515
                              
Axis2StatusBit0               IS MEM516
Axis2StatusBit1               IS MEM517
Axis2StatusBit2               IS MEM518
Axis2StatusBit3               IS MEM519
Axis2StatusTP                 IS MEM520
Axis2StatusALM3               IS MEM521
Axis2StatusALM2               IS MEM522
Axis2StatusALM1               IS MEM523
Axis2StatusTGON               IS MEM524
Axis2StatusBRAKE              IS MEM525
Axis2StatusSRDY               IS MEM526
Axis2StatusQUADERR            IS MEM527
Axis2StatusDIR                IS MEM528
Axis2StatusZ                  IS MEM529
Axis2StatusDIFF_ERR           IS MEM530
Axis2DriveALM                 IS MEM531
                              
Axis3StatusBit0               IS MEM532
Axis3StatusBit1               IS MEM533
Axis3StatusBit2               IS MEM534
Axis3StatusBit3               IS MEM535
Axis3StatusTP                 IS MEM536
Axis3StatusALM3               IS MEM537
Axis3StatusALM2               IS MEM538
Axis3StatusALM1               IS MEM539
Axis3StatusTGON               IS MEM540
Axis3StatusBRAKE              IS MEM541
Axis3StatusSRDY               IS MEM542
Axis3StatusQUADERR            IS MEM543
Axis3StatusDIR                IS MEM544
Axis3StatusZ                  IS MEM545
Axis3StatusDIFF_ERR           IS MEM546
Axis3DriveALM                 IS MEM547
                              
Axis4StatusBit0               IS MEM548
Axis4StatusBit1               IS MEM549
Axis4StatusBit2               IS MEM550
Axis4StatusBit3               IS MEM551
Axis4StatusTP                 IS MEM552
Axis4StatusALM3               IS MEM553
Axis4StatusALM2               IS MEM554
Axis4StatusALM1               IS MEM555
Axis4StatusTGON               IS MEM556
Axis4StatusBRAKE              IS MEM557
Axis4StatusSRDY               IS MEM558
Axis4StatusQUADERR            IS MEM559
Axis4StatusDIR                IS MEM560
Axis4StatusZ                  IS MEM561
Axis4StatusDIFF_ERR           IS MEM562
Axis4DriveALM                 IS MEM563
                              
Axis5StatusBit0               IS MEM564
Axis5StatusBit1               IS MEM565
Axis5StatusBit2               IS MEM566
Axis5StatusBit3               IS MEM567
Axis5StatusTP                 IS MEM568
Axis5StatusALM3               IS MEM569
Axis5StatusALM2               IS MEM570
Axis5StatusALM1               IS MEM571
Axis5StatusTGON               IS MEM572
Axis5StatusBRAKE              IS MEM573
Axis5StatusSRDY               IS MEM574
Axis5StatusQUADERR            IS MEM575
Axis5StatusDIR                IS MEM576
Axis5StatusZ                  IS MEM577
Axis5StatusDIFF_ERR           IS MEM578
Axis5DriveALM                 IS MEM579

;-------------------------------------------------------------------------------
;                     ---------SYSTEM VARIABLES--------
;
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;-------------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional responsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibility of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel key press to a specific function.  Pressing a jog key or AUX key
; won't DO anything unless the PLC assigns an action to the key press.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                                 ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape key press event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the key press is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "set" KbCycleCancel_M any time the escape key is pressed.
;    if Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancel key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_1 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_1 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Key press: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times------------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 32-17 (Selection 0)
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                    Debounce Time Selection #1
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                      Debounce Time Selection #3
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the characteristics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 & INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is set as follows:

; Five new operators have been introduced to simplify bit operations:
; BITSET, BITRST, BITTST, LShift & Rshift.  Below we will use BITSET to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; BITSET and BITRST can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use BITSET and
; BITRST to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; Inputs_9_12_W IS W1
; use BITSET or BITRST
; if 1 == 1 THEN BITSET Inputs_9_12_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; if 1 == 1 THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp1 = bits 31-24        Inp2 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp3 = bits 15-8       Inp4 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Invert(bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, set the both invert AND force bits
;   for the input.
;-------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/set in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.

;-------------------------------------------------------------------------------
;            *** Direct Accessed System Variables
; The following System Variables are directly accessed in this PLC program.
; They are listed here to enable you to easily search and find them
;-------------------------------------------------------------------------------

; SV_STOP_REASON             - ThIS IS used to get any stop reasons from CNC11/MPU11
; SV_TOOL_NUMBER             - Requested Tool Number during Tool Change, M107 sets thIS
; SV_ATC_CAROUSEL_POSITION   - Start-up carousel bin position, sent on CNC software start-up
; SV_ATC_TOOL_IN_SPINDLE     - Tool in spindle during machine start-up
; SV_PLC_CAROUSEL_POSITION   - Reported carousel bin number, reported by the PLC program

;-------------------------------------------------------------------------------
;  System variables:  Keyboard jogging functions
;-------------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard key press has occurred.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Key presses are sent down as individual keys.  It is the responsibility of
; the PLC programmer to insure that a key press is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a key press form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......
;-------------------------------------------------------------------------------

Kb_a                          IS SV_PC_KEYBOARD_KEY_60
Kb_b                          IS SV_PC_KEYBOARD_KEY_79
Kb_c                          IS SV_PC_KEYBOARD_KEY_77
Kb_d                          IS SV_PC_KEYBOARD_KEY_62
Kb_e                          IS SV_PC_KEYBOARD_KEY_41
Kb_f                          IS SV_PC_KEYBOARD_KEY_63
Kb_g                          IS SV_PC_KEYBOARD_KEY_64
Kb_h                          IS SV_PC_KEYBOARD_KEY_65
Kb_i                          IS SV_PC_KEYBOARD_KEY_46
Kb_j                          IS SV_PC_KEYBOARD_KEY_66
Kb_k                          IS SV_PC_KEYBOARD_KEY_67
Kb_l                          IS SV_PC_KEYBOARD_KEY_68
Kb_m                          IS SV_PC_KEYBOARD_KEY_81
Kb_n                          IS SV_PC_KEYBOARD_KEY_80
Kb_o                          IS SV_PC_KEYBOARD_KEY_47
Kb_p                          IS SV_PC_KEYBOARD_KEY_48
Kb_q                          IS SV_PC_KEYBOARD_KEY_39
Kb_r                          IS SV_PC_KEYBOARD_KEY_42
Kb_s                          IS SV_PC_KEYBOARD_KEY_61
Kb_t                          IS SV_PC_KEYBOARD_KEY_43
Kb_u                          IS SV_PC_KEYBOARD_KEY_45
Kb_v                          IS SV_PC_KEYBOARD_KEY_78
Kb_w                          IS SV_PC_KEYBOARD_KEY_40
Kb_x                          IS SV_PC_KEYBOARD_KEY_76
Kb_y                          IS SV_PC_KEYBOARD_KEY_44
Kb_z                          IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar                   IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift                    IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift                    IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt                      IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt                      IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl                     IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl                     IS SV_PC_KEYBOARD_KEY_99
Kb_Ins                        IS SV_PC_KEYBOARD_KEY_31
Kb_Home                       IS SV_PC_KEYBOARD_KEY_32
Kb_End                        IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown                     IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp                       IS SV_PC_KEYBOARD_KEY_33
Kb_Del                        IS SV_PC_KEYBOARD_KEY_52
Kb_Back                       IS SV_PC_KEYBOARD_KEY_30
Kb_Tab                        IS SV_PC_KEYBOARD_KEY_38
Kb_Up                         IS SV_PC_KEYBOARD_KEY_87
Kb_Down                       IS SV_PC_KEYBOARD_KEY_101
Kb_Left                       IS SV_PC_KEYBOARD_KEY_100
Kb_Right                      IS SV_PC_KEYBOARD_KEY_102
Kb_Escape                     IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1                         IS SV_PC_KEYBOARD_KEY_2
Kb_F2                         IS SV_PC_KEYBOARD_KEY_3
Kb_F3                         IS SV_PC_KEYBOARD_KEY_4
Kb_F4                         IS SV_PC_KEYBOARD_KEY_5
Kb_F5                         IS SV_PC_KEYBOARD_KEY_6
Kb_F6                         IS SV_PC_KEYBOARD_KEY_7
Kb_F7                         IS SV_PC_KEYBOARD_KEY_8
Kb_F8                         IS SV_PC_KEYBOARD_KEY_9
Kb_F9                         IS SV_PC_KEYBOARD_KEY_10
Kb_F10                        IS SV_PC_KEYBOARD_KEY_11
Kb_F11                        IS SV_PC_KEYBOARD_KEY_12
Kb_F12                        IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn                   IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck                   IS SV_PC_KEYBOARD_KEY_15
Kb_Break                      IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock                   IS SV_PC_KEYBOARD_KEY_34
Kb_1                          IS SV_PC_KEYBOARD_KEY_18
Kb_2                          IS SV_PC_KEYBOARD_KEY_19
Kb_3                          IS SV_PC_KEYBOARD_KEY_20
Kb_4                          IS SV_PC_KEYBOARD_KEY_21
Kb_5                          IS SV_PC_KEYBOARD_KEY_22
Kb_6                          IS SV_PC_KEYBOARD_KEY_23
Kb_7                          IS SV_PC_KEYBOARD_KEY_24
Kb_8                          IS SV_PC_KEYBOARD_KEY_25
Kb_9                          IS SV_PC_KEYBOARD_KEY_26
Kb_0                          IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div                 IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt                 IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub                 IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0                   IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1                   IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2                   IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3                   IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4                   IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5                   IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6                   IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7                   IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8                   IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9                   IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt              IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus                IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter                  IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket               IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket               IS SV_PC_KEYBOARD_KEY_50
Kb_Hyphen                     IS SV_PC_KEYBOARD_KEY_28
Kb_Equals                     IS SV_PC_KEYBOARD_KEY_29
Kb_Comma                      IS SV_PC_KEYBOARD_KEY_82
Kb_Period                     IS SV_PC_KEYBOARD_KEY_83
Kb_Slash                      IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash                  IS SV_PC_KEYBOARD_KEY_86

;-------------------------------------------------------------
;      System Variable Definions - Jog panel functions
;-------------------------------------------------------------
;Invalid              IS SV_PLC_FUNCTION_0
DoCycleCancel         IS SV_PLC_FUNCTION_1
DoCycleStart          IS SV_PLC_FUNCTION_2
DoToolCheck           IS SV_PLC_FUNCTION_3
SelectSingleBlock     IS SV_PLC_FUNCTION_4
SelectX1JogInc        IS SV_PLC_FUNCTION_5
SelectX10JogInc       IS SV_PLC_FUNCTION_6
SelectX100JogInc      IS SV_PLC_FUNCTION_7
SelectUserJogInc      IS SV_PLC_FUNCTION_8
SelectIncContJog      IS SV_PLC_FUNCTION_9
SelectFastSlowJog     IS SV_PLC_FUNCTION_10
SelectMpgMode         IS SV_PLC_FUNCTION_11
DoAx1PlusJog          IS SV_PLC_FUNCTION_12
DoAx1MinusJog         IS SV_PLC_FUNCTION_13
DoAx2PlusJog          IS SV_PLC_FUNCTION_14
DoAx2MinusJog         IS SV_PLC_FUNCTION_15
DoAx3PlusJog          IS SV_PLC_FUNCTION_16
DoAx3MinusJog         IS SV_PLC_FUNCTION_17
DoAx4PlusJog          IS SV_PLC_FUNCTION_18
DoAx4MinusJog         IS SV_PLC_FUNCTION_19
DoAx5PlusJog          IS SV_PLC_FUNCTION_20
DoAx5MinusJog         IS SV_PLC_FUNCTION_21
DoAx6PlusJog          IS SV_PLC_FUNCTION_22
DoAx6MinusJog         IS SV_PLC_FUNCTION_23
DoAux1Key             IS SV_PLC_FUNCTION_24
DoAux2Key             IS SV_PLC_FUNCTION_25
DoAux3Key             IS SV_PLC_FUNCTION_26
DoAux4Key             IS SV_PLC_FUNCTION_27
DoAux5Key             IS SV_PLC_FUNCTION_28
DoAux6Key             IS SV_PLC_FUNCTION_29
DoAux7Key             IS SV_PLC_FUNCTION_30
DoAux8Key             IS SV_PLC_FUNCTION_31
DoAux9Key             IS SV_PLC_FUNCTION_32
DoAux10Key            IS SV_PLC_FUNCTION_33
SelectRapidOverride   IS SV_PLC_FUNCTION_34
SelectManAutoSpindle  IS SV_PLC_FUNCTION_35
DoSpindleStart        IS SV_PLC_FUNCTION_37
DoSpindleStop         IS SV_PLC_FUNCTION_38
DoAux11Key            IS SV_PLC_FUNCTION_39
DoAux12Key            IS SV_PLC_FUNCTION_40
;SelectCoolantMan     IS SV_PLC_FUNCTION_41 ;deprecated
;SelectCoolantAuto    IS SV_PLC_FUNCTION_42 ;deprecated
SelectCoolantFlood    IS SV_PLC_FUNCTION_43
SelectCoolantMist     IS SV_PLC_FUNCTION_44
DoFeedHold            IS SV_PLC_FUNCTION_45
SelectSpindleCCW      IS SV_PLC_FUNCTION_98
SelectSpindleCW       IS SV_PLC_FUNCTION_99
SelectCoolAutoMan     is SV_PLC_FUNCTION_104
DoIncreaseSpindleOr   IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOr   IS SV_PLC_FUNCTION_107
SelectSpinOr100       IS SV_PLC_FUNCTION_108

;------------------------------------------------------------------------------
;                System Variable Definitions -misc
;------------------------------------------------------------------------------

SpindlePos            IS SV_MPU11_ABS_POS_4
MDIMode               IS SV_MDI_MODE
Stop                  IS SV_STOP

;------------------------------------------------------------------------------
;                       System Variable Skin Events
;------------------------------------------------------------------------------

SkinSpinOverPlus_M            IS SV_SKIN_EVENT_1  ; Row  1 Column 1
SkinSpinAutoMan_M             IS SV_SKIN_EVENT_2  ; Row  1 Column 2
SkinAux1_M                    IS SV_SKIN_EVENT_3  ; Row  1 Column 3
SkinAux2_M                    IS SV_SKIN_EVENT_4  ; Row  1 Column 4
SkinAux3_M                    IS SV_SKIN_EVENT_5  ; Row  1 Column 5
SkinSpin100_M                 IS SV_SKIN_EVENT_6  ; Row  2 Column 1
SkinSpinCW_M                  IS SV_SKIN_EVENT_7  ; Row  2 Column 2
SkinAux4_M                    IS SV_SKIN_EVENT_8  ; Row  2 Column 3
SkinAux5_M                    IS SV_SKIN_EVENT_9  ; Row  2 Column 4
SkinAux6_M                    IS SV_SKIN_EVENT_10 ; Row  2 Column 5
SkinSpinOverMinus_M           IS SV_SKIN_EVENT_11 ; Row  3 Column 1
SkinSpinCCW_M                 IS SV_SKIN_EVENT_12 ; Row  3 Column 2
SkinAux7_M                    IS SV_SKIN_EVENT_13 ; Row  3 Column 3
SkinAux8_M                    IS SV_SKIN_EVENT_14 ; Row  3 Column 4
SkinAux9_M                    IS SV_SKIN_EVENT_15 ; Row  3 Column 5
SkinSpinStop_M                IS SV_SKIN_EVENT_16 ; Row  4 Column 1
SkinSpinStart_M               IS SV_SKIN_EVENT_17 ; Row  4 Column 2
SkinAux10_M                   IS SV_SKIN_EVENT_18 ; Row  4 Column 3
SkinAux11_M                   IS SV_SKIN_EVENT_19 ; Row  4 Column 4
SkinAux12_M                   IS SV_SKIN_EVENT_20 ; Row  4 Column 5
SkinCoolAutoMan_M             IS SV_SKIN_EVENT_21 ; Row  5 Column 1
SkinCoolFlood_M               IS SV_SKIN_EVENT_22 ; Row  5 Column 2
SkinCoolMist_M                IS SV_SKIN_EVENT_23 ; Row  5 Column 3
SkinAux13_M                   IS SV_SKIN_EVENT_24 ; Row  5 Column 4
SkinAux14_M                   IS SV_SKIN_EVENT_25 ; Row  5 Column 5
SkinIncCont_M                 IS SV_SKIN_EVENT_26 ; Row  6 Column 1
SkinX1_M                      IS SV_SKIN_EVENT_27 ; Row  6 Column 2
SkinX10_M                     IS SV_SKIN_EVENT_28 ; Row  6 Column 3
SkinX100_M                    IS SV_SKIN_EVENT_29 ; Row  6 Column 4
SkinMPG_M                     IS SV_SKIN_EVENT_30 ; Row  6 Column 5
SkinJogAx4Plus_M              IS SV_SKIN_EVENT_31 ; Row  7 Column 1
SkinR7C2_M                    IS SV_SKIN_EVENT_32 ; Row  7 Column 2
SkinJogAx2Plus_M              IS SV_SKIN_EVENT_33 ; Row  7 Column 3
SkinR7C4_M                    IS SV_SKIN_EVENT_34 ; Row  7 Column 4
SkinJogAx3Plus_M              IS SV_SKIN_EVENT_35 ; Row  7 Column 5
SkinR8C1_M                    IS SV_SKIN_EVENT_36 ; Row  8 Column 1
SkinJogAx1Minus_M             IS SV_SKIN_EVENT_37 ; Row  8 Column 2
SkinFastSlowJog_M             IS SV_SKIN_EVENT_38 ; Row  8 Column 3
SkinJogAx1Plus_M              IS SV_SKIN_EVENT_39 ; Row  8 Column 4
SkinR8C5_M                    IS SV_SKIN_EVENT_40 ; Row  8 Column 5
SkinJogAx4Minus_M             IS SV_SKIN_EVENT_41 ; Row  9 Column 1
SkinR9C2_M                    IS SV_SKIN_EVENT_42 ; Row  9 Column 2
SkinJogAx2Minus_M             IS SV_SKIN_EVENT_43 ; Row  9 Column 3
SkinR9C4_M                    IS SV_SKIN_EVENT_44 ; Row  9 Column 4
SkinJogAx3Minus_M             IS SV_SKIN_EVENT_45 ; Row  9 Column 5
SkinCycleCancel_M             IS SV_SKIN_EVENT_46 ; Row 10 Column 1
SkinSingleBlock_M             IS SV_SKIN_EVENT_47 ; Row 10 Column 2
SkinToolCheck_M               IS SV_SKIN_EVENT_48 ; Row 10 Column 3
SkinFeedHold_M                IS SV_SKIN_EVENT_49 ; Row 10 Column 4
SkinCycleStart_M              IS SV_SKIN_EVENT_50 ; Row 10 Column 5
SkinResetOk_M                 IS SV_SKIN_EVENT_51
SkinFeedOverMinus_M           IS SV_SKIN_EVENT_52
SkinFeedOver100               IS SV_SKIN_EVENT_53
SkinFeedOverPlus_M            IS SV_SKIN_EVENT_54
SkinResetSet_M                IS SV_SKIN_EVENT_55 ;echo reset/set status to vcp/skin
SkinResetKey_M                IS SV_SKIN_EVENT_56
;                             IS SV_SKIN_EVENT_57
;                             IS SV_SKIN_EVENT_58
;                             IS SV_SKIN_EVENT_59
;                             IS SV_SKIN_EVENT_60
;                             IS SV_SKIN_EVENT_61
;                             IS SV_SKIN_EVENT_62
;                             IS SV_SKIN_EVENT_63
;                             IS SV_SKIN_EVENT_64
;                             IS SV_SKIN_EVENT_65
;                             IS SV_SKIN_EVENT_66
;                             IS SV_SKIN_EVENT_67
EStopPressed_M                IS SV_SKIN_EVENT_68
UsingKbOverride_M             IS SV_SKIN_EVENT_69
;                             IS SV_SKIN_EVENT_70
;                             IS SV_SKIN_EVENT_71
;                             IS SV_SKIN_EVENT_72
;                             IS SV_SKIN_EVENT_73
;                             IS SV_SKIN_EVENT_74
;                             IS SV_SKIN_EVENT_75
;                             IS SV_SKIN_EVENT_76
;                             IS SV_SKIN_EVENT_77
;                             IS SV_SKIN_EVENT_78
;                             IS SV_SKIN_EVENT_79
;                             IS SV_SKIN_EVENT_80
;                             IS SV_SKIN_EVENT_81
;                             IS SV_SKIN_EVENT_82
;                             IS SV_SKIN_EVENT_83
;                             IS SV_SKIN_EVENT_84
;                             IS SV_SKIN_EVENT_85
;                             IS SV_SKIN_EVENT_86
;                             IS SV_SKIN_EVENT_87
;                             IS SV_SKIN_EVENT_88
;                             IS SV_SKIN_EVENT_89
;                             IS SV_SKIN_EVENT_90
;                             IS SV_SKIN_EVENT_91
;                             IS SV_SKIN_EVENT_92
;                             IS SV_SKIN_EVENT_93
;                             IS SV_SKIN_EVENT_94
;                             IS SV_SKIN_EVENT_95
;                             IS SV_SKIN_EVENT_96
;                             IS SV_SKIN_EVENT_97
;                             IS SV_SKIN_EVENT_98
;                             IS SV_SKIN_EVENT_99
;                             IS SV_SKIN_EVENT_100
;                             IS SV_SKIN_EVENT_101
;                             IS SV_SKIN_EVENT_102
;                             IS SV_SKIN_EVENT_103
;                             IS SV_SKIN_EVENT_104
;                             IS SV_SKIN_EVENT_105
;                             IS SV_SKIN_EVENT_106
;                             IS SV_SKIN_EVENT_107
;                             IS SV_SKIN_EVENT_108
;                             IS SV_SKIN_EVENT_109
;                             IS SV_SKIN_EVENT_110
;                             IS SV_SKIN_EVENT_111
;                             IS SV_SKIN_EVENT_112
;                             IS SV_SKIN_EVENT_113
;                             IS SV_SKIN_EVENT_114
;                             IS SV_SKIN_EVENT_115
;                             IS SV_SKIN_EVENT_116
;                             IS SV_SKIN_EVENT_117
;                             IS SV_SKIN_EVENT_118
;                             IS SV_SKIN_EVENT_119
;                             IS SV_SKIN_EVENT_120
;                             IS SV_SKIN_EVENT_121
;                             IS SV_SKIN_EVENT_122
;                             IS SV_SKIN_EVENT_123
;                             IS SV_SKIN_EVENT_124
;                             IS SV_SKIN_EVENT_125
;                             IS SV_SKIN_EVENT_126
;                             IS SV_SKIN_EVENT_127
;                             IS SV_SKIN_EVENT_128

;   Read Only SV_USB_MPG_ENCODER_WHEEL      

SetAxis1Part0                 IS SV_PLC_SET_AXIS_1_PART_ZERO
SetAxis2Part0                 IS SV_PLC_SET_AXIS_2_PART_ZERO
SetAxis3Part0                 IS SV_PLC_SET_AXIS_3_PART_ZERO
SetAxis4Part0                 IS SV_PLC_SET_AXIS_4_PART_ZERO
SetAxis5Part0                 IS SV_PLC_SET_AXIS_5_PART_ZERO
SetAxis6Part0                 IS SV_PLC_SET_AXIS_6_PART_ZERO
SetAxis7Part0                 IS SV_PLC_SET_AXIS_7_PART_ZERO
SetAxis8Part0                 IS SV_PLC_SET_AXIS_8_PART_ZERO

;By setting SV_SYS_MACRO to a value of something other than zero, the PLC is 
;requesting CNC12 to run the corresponding macro in the c:\cncm\system directory
;Setting SV_SYS_MACRO = 1, run c:\cncm\system\macro1.mac. Cnc12 will not run the
;same macro twice in a row unless SV_SYS_MACRO has been set to 0 between requests.
;IF "Something" THEN SV_SYS_MACRO = 1					

;-------------------------------------------------------------------------------
;                System Variable Definitions - M functions
;-------------------------------------------------------------------------------

M3                  		  IS SV_M94_M95_1 ;(Spindle CW)
M4                  		  IS SV_M94_M95_2 ;(Spindle CCW)
M8                  		  IS SV_M94_M95_3 ;(Flood On)
M10                 		  IS SV_M94_M95_4 ;(Rotary Clamp)
M7                  		  IS SV_M94_M95_5 ;(Mist)
M6                  		  IS SV_M94_M95_6 ;(Tool Change)
		                      
MZ_ACK              		  IS SV_M94_M95_8 ;(Move Z Ack)
		                      
Pre_M6              		  IS SV_M94_M95_12;(Pre M6)
M13                 		  IS SV_M94_M95_13;(ArmCycle)
M14                 		  IS SV_M94_M95_14;(Pot Down)
M15                 		  IS SV_M94_M95_15;(Pot Up)
		                      
M18                 		  IS SV_M94_M95_18;(Set ATC Home)
M19                 		  IS SV_M94_M95_19;(Spindle Orient)
		                      
M21                 		  IS SV_M94_M95_21 ;(Chip Pump)
		                      
M80                 		  IS SV_M94_M95_80 ;(Thru Tool Coolant)
		                      
;-------------------------------------------------------------------------------
;           Word Definitions (int32)
;-------------------------------------------------------------------------------

LubeAccumTime_W               IS W1
KbOverride_W                  IS W2
FeedrateKnob_W                IS W3
FinalFeedOverride_W           IS W4
Last_FeedrateKnob_W           IS W5
CycloneStatus_W               IS W6
SixteenBitSpeed_W             IS W7

Bin_Position_W          	  IS W10     
Wanted_Bin_W            	  IS W11
Max_Bins_W              	  IS W12     
Distance_W              	  IS W13    
MotorDir_W					  IS W14  ; 1 = CW, -1 = CCW
OldM107Binr_W           	  IS W15      
NewM107Bin_W            	  IS W16

P6Value_W               	  IS W17
P85Value_W             		  IS W18
Inputs_9_12_W          		  IS W19
P146Value_W                   IS W20
P148Value_W            		  IS W21
P166Value_W            		  IS W22
P170Value_W            		  IS W23
P171Value_W            		  IS W24
P172Value_W            		  IS W25
P173Value_W            		  IS W26
P174Value_W            		  IS W27
P175Value_W            		  IS W28
P176Value_W            		  IS W29
P177Value_W            		  IS W30
P179Value_W            		  IS W31

UsbAxisMonitor_W        	  IS W34
UsbScaleMonitor_W			  IS W35
UsbJog_W                      IS W36
JogKeyCfg_W                   IS W37
UsbButtonMonitor			  IS W38
UsbWheelCurrent				  IS W39
UsbWheelLast				  IS W40
UsbWheelDelta				  IS W41
UsbMpgActiveAxes_W            IS W42
DefaultJogging_W              IS W43 

P900Value_W                   IS W44
MiniPLCStatus_W               IS W45
StallReason_W                 IS W46
StallAxis_W                   IS W47
ErrorCode_W                   IS W48

InfoMsg_W                     IS W50
PLC_Fault_W                   IS W51
PLCFaultAddr_W                IS W52
AsyncMsg_W                    IS W53
                                 
SpindleMeterADC_W             IS W60
Lube_W                        IS W61
LubeM_W                       IS W62
LubeS_W                       IS W63
SpindleRange_W                IS W64  ; 1 = low ... 4 = high
PrevFeedOverride_W            IS W65
InputsConfig_W                IS W67

Sv_Control_1_Shadow           IS W71
Sv_Control_2_Shadow           IS W72
Sv_Control_3_Shadow           IS W73
Sv_Control_4_Shadow           IS W74
Sv_Control_5_Shadow           IS W75

;-------------------------------------------------------------------------------
;           Word Definitions cont. (int64)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
;           Word Definitions cont. (f32)
;-------------------------------------------------------------------------------

SpinRangeAdjust_FW    		  IS FW1
RPMPerBit_FW           		  IS FW2
CfgMinSpeed_FW         		  IS FW3
CfgMaxSpeed_FW         		  IS FW4
SixteenBitSpeed_FW            IS FW5
SpinSpeedCommand_FW           IS FW6

;-------------------------------------------------------------------------------
;            One Shot Definitions
;-------------------------------------------------------------------------------

IncrContPD             		  IS PD1
SlowFastPD             		  IS PD2
MpgPD                  		  IS PD3
SingleBlockPD          		  IS PD4
FeedHoldPD             		  IS PD5
SpinAutoManPD          		  IS PD6
SpindlePlusPD          		  IS PD7
SpinOverMinusPD        		  IS PD8
SpinOver100PD          		  IS PD9


SpinCWPD               		  IS PD12
SpinCCWPD              		  IS PD13
F9PD                   		  IS PD14
x1JogPD                		  IS PD15
x10JogPD               		  IS PD16
x100JogPD              		  IS PD17
Aux10_PD           			  IS PD18
RapidOverPD            		  IS PD19
ProbePD                		  IS PD20
CoolantAutoManualPD    		  IS PD21
CoolantFloodPD         		  IS PD22
CoolantMistPD           	  IS PD23
ToolCheckPD             	  IS PD24
JogProbeFaultPD         	  IS PD25
RigidTapPD              	  IS PD26
WorklightPD             	  IS PD27
SaveJogModePD           	  IS PD28
MpgOffsetPD             	  IS PD29
PCSpindleStartStopPD    	  IS PD30
PCSpindleManualPD       	  IS PD31
PCSpindleCWPD           	  IS PD32
PCSpindleCCWPD          	  IS PD33
StopRunning_PD          	  IS PD35
SoftwareReadyPD         	  IS PD36
SetResetPD              	  IS PD37
ResetClearedPD          	  IS PD38
LowLubePD               	  IS PD39
	                          
M19_1Shot               	  IS PD41     
M18_1Shot               	  IS PD42
M13_1Shot               	  IS PD43
StopReason_1Shot        	  IS PD44
M21PD                   	  IS PD45
M22PD                   	  IS PD46
	                          
CAFWD_PD                	  IS PD47     
CAREV_PD                	  IS PD48
CA1_PD                  	  IS PD49
CA2_PD                  	  IS PD50
CA3_PD                  	  IS PD51
CAFWD_OFF_PD	        	  IS PD52
CAFWD_ON_PD	           		  IS PD53
CAREV_OFF_PD	       		  IS PD54
CAREV_ON_PD	           		  IS PD55
AugerSelectPD          		  IS PD56
		                      
ClearOffsetPD          		  IS PD57 
Aux1PD                 		  IS PD58
Aux2PD                 		  IS PD59
Aux3PD                 		  IS PD60
Aux4PD                 		  IS PD61
Aux5PD                 		  IS PD62
Aux6PD                 		  IS PD63
Aux7PD                 		  IS PD64
Aux8PD                 		  IS PD65
Aux9PD                 		  IS PD66
Aux10PD                		  IS PD67
Aux11PD                		  IS PD68
Aux12PD                		  IS PD69
Aux13PD                		  IS PD70
Aux14PD                		  IS PD71
MinSpeedPD             		  IS PD72
SkinFeedOverMinusPD    		  IS PD73
SkinFeedOverPlusPD     		  IS PD74
							 																		 
MpgMacro1PD            		  IS PD75
MpgMacro2PD            		  IS PD76
MpgMacro3PD            		  IS PD77
MpgMacro4PD            		  IS PD78

AutoSpindlePD				  IS PD79
AutoCoolantPD				  IS PD80
;-------------------------------------------------------------------------------
;             Timer Definitions
;-------------------------------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T              	  IS T1
SleepTimer              	  IS T2
CycloneStatusTimer      	  IS T3
InitializeTimer         	  IS T4
LubeM_T                 	  IS T5
LubeS_T                 	  IS T6
	                          
ATC_OrientLost_T        	  IS T7
StopReason_T            	  IS T8
P176_T                  	  IS T9
Car_Enable_T            	  IS T10
ATC_Orient_T1           	  IS T11
ATC_Unclamp_T1          	  IS T12
ATC_Rotate_T1           	  IS T13
ATC_Rotate_T2           	  IS T14
ATC_Count_T1            	  IS T15
ATC_Count_T2            	  IS T16
ATC_Clamp_T1            	  IS T17
ATC_PotDown_T1          	  IS T18
ATC_End_T1              	  IS T19
ATC_MoveZAxis_T1        	  IS T20
ATC_ARM_HTC_T1          	  IS T21
ATC_AHTCWS_T1           	  IS T22
ATC_PotUp_T1            	  IS T23
ATC_ARM_D180U_T1        	  IS T24
ATC_AD1UWS_T1           	  IS T25
ATC_ARM_CTH_T1          	  IS T26
ATC_ACTHWS_T1           	  IS T27

ChillerOff_T            	  IS T28
Tool_Thru_Coolant_T     	  IS T29
AirTimer_T              	  IS T30
SpindleChillerFault_T   	  IS T31
LightBlinkOn_T          	  IS T32
LightBlinkOff_T         	  IS T33
DoorLockDelay_T         	  IS T34
SkinFeedOverTimer             IS T35
OverrideMsgTimer              IS T36
MessageTimer                  IS T37
MpgResetTimer                 IS T38
SpindleFault_T           	  IS T39
TriggerPause_T				  IS T40

;-------------------------------------------------------------------------------
;             Stage Definitions
;-------------------------------------------------------------------------------

WatchDogStage              	  IS STG1
InitialStage               	  IS STG2
LoadCNCParametersStage   	  IS STG3
LubeMonitorStage           	  IS STG4
AxesEnableStage            	  IS STG5
JogPanelStage              	  IS STG6
MainStage                  	  IS STG7
MiniPLCErrorStage        	  IS STG8
MPGStage                  	  IS STG9
CheckCycloneStatusStage    	  IS STG10
	                          
KeyboardEventsStage        	  IS STG11
LubeUsePumpTimers          	  IS STG12
LubeUsePLCTimers           	  IS STG13
SetErrorStage              	  IS STG14
BadErrorStage              	  IS STG15
WirelessMpgStage			  IS STG16
ZeroTo5Or10Stage              IS STG17
Minus5Or10ToPlus5Or10Stage    IS STG18

ATCMainStage               	  IS STG19	                          
ATC_InitialStage           	  IS STG20
ATC_CheckStageRotateStage  	  IS STG21
ATC_ReadyStage             	  IS STG22
ATC_MoveZAxisStage         	  IS STG23
ATC_OrientStage            	  IS STG24
ATC_PotDownStage           	  IS STG25
ATC_ArmAtHomeToClampStage  	  IS STG26
ATC_AHTCWaitStopStage      	  IS STG27
ATC_UnclampStage           	  IS STG28
ATC_ArmDown180UpStage      	  IS STG29
ATC_AD1UWaitStopStage      	  IS STG30
ATC_ClampStage             	  IS STG31
ATC_ArmAtClampToHomeStage  	  IS STG32
ATC_ACTHWaitStopStage      	  IS STG33
ATC_PotUpStage             	  IS STG34
ATC_EndStage               	  IS STG35
ATC_AcceptStage            	  IS STG36
ATC_CheckStage             	  IS STG37	                          
ATC_DoM19Stage             	  IS STG38
ATC_MonitorM19Stage        	  IS STG39	                          
ATC_DoToolIndexUpStage     	  IS STG40
ATC_DoToolIndexDnStage     	  IS STG41
ATC_RotateStage            	  IS STG42
ATC_CountStage             	  IS STG43
ATC_DoneRotateStage        	  IS STG44
ATC_SetDirectionStage      	  IS STG45
ATC_M13ArmRotateStage      	  IS STG46
M13_ArmWaitStopStage       	  IS STG47
	                          
AugerOffStage              	  IS STG48
AugerFwdStage              	  IS STG49
AugerRevStage              	  IS STG50
AugerSelectStage              IS STG51
DoorInterlockStage            IS STG5

;*****************************************************************************
;                  PLC Program Start - Definitions done, start program loop
;*****************************************************************************

;-------------------------------------------------------------------------------
                          WatchDogStage
;-------------------------------------------------------------------------------

; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
IF SV_PLC_FAULT_STATUS != 0 THEN PLC_Fault_W = SV_PLC_FAULT_STATUS,
								 PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
								 ErrorCode_W = PLC_EXECUTOR_FLT_MSG, 
								 MSG ErrorCode_W,
								 SET PLCExecutorFault_M, 
								 RST SetErrorStage, 
								 SET SV_STOP

; Handle software exit.
IF !SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN
  SET SoftwareReady_M,
  SET SV_STOP,
  ErrorCode_W = SOFTWARE_EXIT_MSG

IF SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN (SoftwareReadyPD)
IF SoftwareReadyPD && !SoftwareReady_M || !TRUE THEN SET InitialStage

IF SoftwareReadyPD && SoftwareReady_M THEN RST SoftwareReady_M

;-------------------------------------------------------------------------------
            InitialStage
;-------------------------------------------------------------------------------

IF 1==1 THEN SET TRUE,
			 SET OnAtPowerUp_M,
			 SET AxesEnableStage,
			 SET JogPanelStage,
			 SET MainStage,
			 SET LoadCNCParametersStage,
			 SET MPGStage,
			 SET PLCBus_Oe_M,
			 RST DriveComFltIn_M,
             RST DriveComFltOut_M,
			 RST PLCFault_M,
			 CycloneStatusTimer = 300,
			 ErrorCode_W = MSG_CLEARED_MSG,
			 RST BadErrorStage,
			 SET SetErrorStage,
			 RST ATC_RotateStage,
			 SET AugerOffStage,
			 SET AugerSelectStage,
			 SET DoorInterlockMode_M,
			 Bin_Position_W = SV_ATC_CAROUSEL_POSITION,
			 Wanted_Bin_W = Bin_Position_W,
			 OldM107Binr_W = Bin_Position_W,
			 NewM107Bin_W = Bin_Position_W,
			 InitializeTimer = 1000, 
			 SET InitializeTimer,
			 Tool_Thru_Coolant_T = 5000,	; Timer for PLC to check Tool_thru_coolant pressure
			 AirTimer_T = 500,    			; Time that low air input must be on to cause fault
			 ATC_OrientLost_T = 1000,    	; Time that orient complete must be lost before fault
			 StopReason_T = 50,    			; misc timer used to load stop reason form CPU
			 Car_Enable_T = 100,    		; Time to keep carousel motor off before rotating
			 ATC_Orient_T1 = 60000,  		; Max time to orient spindle
			 ATC_Unclamp_T1 = 6000,   		; Max time to unclamp tool
			 ATC_Rotate_T1 = 2000,   		; Max time to see first tool counter input change
			 ATC_Rotate_T2 = 50,     		; Min time to see first tool counter input change
			 ATC_Count_T1 = 2000,   		; Max time to see second tool counter input change
			 ATC_Count_T2 = 50,     		; Min time to see second tool counter input change
			 ATC_Clamp_T1 = 5000,   		; Max time to clamp tool
			 ATC_PotDown_T1 = 5000,   		; Max time to extend tool pot
			 ATC_End_T1 = 5000,   			; Max time to finISh handshaking with M6 macro
			 ATC_MoveZAxis_T1 = 10000,  	; Max time to move Z axis to tool change height
			 ATC_ARM_HTC_T1 = 2000,   		; Max time to move arm from home to clamp (for ArmAtStopInput to go off)
			 ATC_AHTCWS_T1 = 2000,   		; Max time to move arm from home to clamp (for ArmAtStopInput and ArmAtClampInput to be on)
			 ATC_PotUp_T1 = 5000,   		; Max time to retract tool pot
			 ATC_ARM_D180U_T1 = 2000,   	; Max time to move arm down, rotate 180, up (for ArmAtStopInput to go off)
			 ATC_AD1UWS_T1 = 2000,   		; Max time to move arm down, rotate 180, up (for ArmAtStopInput and ArmAtClampI to be on)
			 ATC_ARM_CTH_T1 = 2000,   		; Max time to move arm from clamp to home (for ArmAtStopInput to go off)
			 ATC_ACTHWS_T1 = 2000,   		; Max time to move arm from clamp to home (for ArmAtStopInput and ArmAtHomeInput to be on)
			 P176_T = 200,    				; Unclamp / AirBlow Timer
			 ChillerOff_T = 10,    			; Spindle Chiller Off time delay, default 0 
			 SpindleChillerFault_T = 10000, ; Spindle Chiller Fault Timer
			 LightBlinkOn_T = 20000,  		; Light Blink On Time
			 LightBlinkOff_T = 500,  		; Light Blink Off Time
			 DoorLockDelay_T = 1000, 		; Door lock delay 
			 SpindleFault_T = 2000,         ; Delay after release of E-stop before sending spindle fault message
			 SET LightBlinkOn_T
;;;;
;;;;  START BENCHMARK TESTING TIMES
;;;;
; For production code comment out
; all lines between START and END
;   ATC_Orient_T1      = 6000,
;   ATC_Unclamp_T1     = 2000,
;   ATC_Rotate_T1      = 1000,
;   ATC_Rotate_T2      = 35,
;   ATC_Count_T1       = 1000,
;   ATC_Count_T2       = 35,
;   ATC_Clamp_T1       = 2000,
;   ATC_PotDown_T1    = 2000,
;   ATC_End_T1         = 2000,
;   ATC_MoveZAxis_T1 = 3000,
;   ATC_ARM_HTC_T1     = 2000,
;   ATC_AHTCWS_T1      = 2000,
;   ATC_PotUp_T1      = 2000,
;   ATC_ARM_D180U_T1   = 2000,
;   ATC_AD1UWS_T1      = 2000,
;   ATC_ARM_CTH_T1     = 2000,
;   ATC_ACTHWS_T1      = 2000,
;;;;
;;;;  END BENCHMARK TESTING TIMES
;;;;
IF 1==1 THEN MSG ErrorCode_W
IF 1==1 THEN RST InitialStage

IF 1==1 THEN P6Value_W = SV_MACHINE_PARAMETER_6
IF (P6Value_W == 1) THEN SET ATCMainStage, SET ATC_InitialStage
IF (P6Value_W == 0) THEN RST ATCMainStage, RST ATC_InitialStage

;-------------------------------------------------------------------------------
                      LoadCNCParametersStage
;-------------------------------------------------------------------------------
; There are two methods of control for the lube pump and they are set by CNC12
; machine parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled solely by PLC).
;
; Load lube pump times from P179 and convert to milliseconds
IF TRUE THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000

; Set the appropriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimers, RST LubeUsePLCTimers
IF LubeS_W != 0 THEN SET LubeUsePLCTimers, RST LubeUsePumpTimers

IF TRUE THEN P85Value_W = SV_MACHINE_PARAMETER_85,   ; Door Interlock - If non zero then obey Door Closed Input
			 P146Value_W = SV_MACHINE_PARAMETER_146, ; Feed hold threshold
			 P148Value_W = SV_MACHINE_PARAMETER_148, ; Misc Jogging Options
			 P166Value_W = SV_MACHINE_PARAMETER_166, ; Fifth Axis
             P170Value_W = SV_MACHINE_PARAMETER_170, ; Enable Keyboard Jogging
			 P171Value_W = SV_MACHINE_PARAMETER_171, ; Auger Mode - 0 means Both Augers, 1 means selectable Augers
			 P172Value_W = SV_MACHINE_PARAMETER_172, ; M31/M32/M33 current mode Parameter (Used by M Functions)
			 P173Value_W = SV_MACHINE_PARAMETER_173, ; 
			 P174Value_W = SV_MACHINE_PARAMETER_174, ; 
			 P175Value_W = SV_MACHINE_PARAMETER_175, ; Chiller Off Delay Time
			 P176Value_W = SV_MACHINE_PARAMETER_176, ; 
			 P177Value_W = SV_MACHINE_PARAMETER_177, ; 
			 Max_Bins_W  = SV_MACHINE_PARAMETER_161  ; Max tool numbers

; The following section allows cnc11 to invert or override inputs and outputs
IF TRUE THEN (SV_ENABLE_IO_OVERRIDE),
             SV_INVERT_INP1_16_BITS      = SV_MACHINE_PARAMETER_911,
             SV_INVERT_INP17_32_BITS     = SV_MACHINE_PARAMETER_912,
             SV_INVERT_INP33_48_BITS     = SV_MACHINE_PARAMETER_913,
             SV_INVERT_INP49_64_BITS     = SV_MACHINE_PARAMETER_914,
			 SV_INVERT_INP65_80_BITS     = SV_MACHINE_PARAMETER_915,
             SV_FORCE_INP1_16_BITS       = SV_MACHINE_PARAMETER_916,
             SV_FORCE_INP17_32_BITS      = SV_MACHINE_PARAMETER_917,
             SV_FORCE_INP33_48_BITS      = SV_MACHINE_PARAMETER_918,
             SV_FORCE_INP49_64_BITS      = SV_MACHINE_PARAMETER_919,
			 SV_FORCE_INP65_80_BITS      = SV_MACHINE_PARAMETER_920,
             SV_FORCE_ON_OUT1_16_BITS    = SV_MACHINE_PARAMETER_921,
             SV_FORCE_ON_OUT17_32_BITS   = SV_MACHINE_PARAMETER_922,
             SV_FORCE_ON_OUT33_48_BITS   = SV_MACHINE_PARAMETER_923,
             SV_FORCE_ON_OUT49_64_BITS   = SV_MACHINE_PARAMETER_924,
			 SV_FORCE_ON_OUT65_80_BITS   = SV_MACHINE_PARAMETER_925,
             SV_FORCE_OFF_OUT1_16_BITS   = SV_MACHINE_PARAMETER_926,
             SV_FORCE_OFF_OUT17_32_BITS  = SV_MACHINE_PARAMETER_927,
             SV_FORCE_OFF_OUT33_48_BITS  = SV_MACHINE_PARAMETER_928,
             SV_FORCE_OFF_OUT49_64_BITS  = SV_MACHINE_PARAMETER_929,
			 SV_FORCE_OFF_OUT65_80_BITS  = SV_MACHINE_PARAMETER_930,
			 SV_FORCE_ON_MEM1_16_BITS    = SV_MACHINE_PARAMETER_931,
             SV_FORCE_ON_MEM17_32_BITS   = SV_MACHINE_PARAMETER_932,
             SV_FORCE_ON_MEM33_48_BITS   = SV_MACHINE_PARAMETER_933,
             SV_FORCE_ON_MEM49_64_BITS   = SV_MACHINE_PARAMETER_934,
             SV_FORCE_ON_MEM65_80_BITS   = SV_MACHINE_PARAMETER_935,
             SV_FORCE_OFF_MEM1_16_BITS   = SV_MACHINE_PARAMETER_936,
             SV_FORCE_OFF_MEM17_32_BITS  = SV_MACHINE_PARAMETER_937,
             SV_FORCE_OFF_MEM33_48_BITS  = SV_MACHINE_PARAMETER_938,
             SV_FORCE_OFF_MEM49_64_BITS  = SV_MACHINE_PARAMETER_939,
             SV_FORCE_OFF_MEM65_80_BITS  = SV_MACHINE_PARAMETER_940	
			 
IF TRUE THEN BITTST P148Value_W 1 DisableKbInput_M
IF TRUE && !DisableKbInput_M THEN BITTST P170Value_W 0 AllowKbInput_M
IF TRUE THEN BITTST P170Value_W 1 JogOverOnly_M
IF TRUE THEN BITTST P170Value_W 2 KbOverOnly_M
IF JogOverOnly_M && KbOverOnly_M THEN RST KbOverOnly_M

; Load Auger Settings
IF TRUE THEN BITTST P172Value_W 1 M31
IF TRUE THEN BITTST P172Value_W 2 M32
IF TRUE THEN BITTST P172Value_W 3 M33

; Load Spindle Chiller Off Timer
IF TRUE THEN ChillerOff_T = (P175Value_W * 60000)

; Check Door Interlock Settings
IF (P85Value_W != 0) THEN SET DoorInterlockMode_M, 
						  SET DoorInterlockStage
IF (P85Value_W == 0) THEN RST DoorInterlockMode_M, 
						  RST DoorInterlockStage, 
						  RST DoorOpenSlowJog_M,
						  RST DoorLockOut

; Set (or reset) the jog panel flag 
IF SV_JOG_PANEL_REQUIRED THEN (JogPanelRequired_M)
						  
; Wireless MPG
IF SV_MACHINE_PARAMETER_218 == 0 THEN SET MPGStage, RST WirelessMpgStage	
IF SV_MACHINE_PARAMETER_218 > 0 THEN RST MPGStage, SET WirelessMpgStage	
	
;-------------------------------------------------------------------------------
                        LubeUsePumpTimers
;-------------------------------------------------------------------------------

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be set such that MMM is a
; value that is greater than the cycle time set on the internal timers and
; SS should be set to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is set to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually set with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time set by the interval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems according to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) THEN SET LubeOut, RST LubeM_T
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN LubeM_T = LubeM_W, SET LubeM_T
IF LubeM_T || !EStopOk THEN RST LubeOut

;-------------------------------------------------------------------------------
                        LubeUsePLCTimers
;-------------------------------------------------------------------------------
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be set so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To set the lube pump power to come on for 5 seconds
;    every 10 minutes, set P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To set the lube pump power to come on for 30 seconds
;    every 2 hours, set P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;

IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) THEN LubeM_T = LubeM_W, SET LubeM_T
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN (StopRunning_PD)
IF StopRunning_PD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T, RST LubeM_T
IF LubeM_T || (LubeAccumTime_W + LubeM_T > LubeM_W) THEN
  SET LubeOut, LubeS_T = LubeS_W, SET LubeS_T, RST LubeM_T, LubeAccumTime_W = 0
IF LubeS_T || !EStopOk THEN RST LubeOut, RST LubeS_T

;-------------------------------------------------------------------------------
                        KeyboardEventsStage
;-------------------------------------------------------------------------------
; This stage handles functions that are required for menu navigation
; by CNC12, require multiple key presses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must set parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC11 to aid in menu
; navigation.  NOTE: For backward compatibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked------------------------
; The cycle cancel has been moved to the main stage.
; It is commented out below but remains for reference

;Cycle Cancel
;IF Kb_Escape THEN (KbCycleCancel_M)

;Rapid override: Ctrl-r
IF Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M-------------------
;KbCycle Start: alt-s
IF  Kb_s && (Kb_R_Alt || Kb_L_Alt) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
IF Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbFeedHold_M: spacebar
IF Kb_spacebar && AllowKbInput_M THEN (KbFeedHold_M)

;KbTogSingleBlock_M: ctrl-b
IF Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
IF Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
IF Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCW_M, RST KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
IF Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCCW_M, RST KbSpinCW_M

;KbSpinStart_M:  ctrl-s
IF Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
IF Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
IF Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
IF Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
IF Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
IF Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
IF Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
IF Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbMistOnOff_M)

;KbTogIncContJog_M: "ctrl" +  "i"
IF Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
IF Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogFastSlowJog_M)

;KbAux1Key_M: "ctrl" + "F1"
IF Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
IF Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
IF Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
IF Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
IF Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
IF Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
IF Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
IF Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
IF Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
IF Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux11Key_M: "ctrl" + "F11"
IF Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux11Key_M)

;KbAux12Key_M: "ctrl" + "F12"
IF Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
IF Kb_Equals && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
IF Kb_Hyphen && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
IF Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbFeedOver100_M)

;--------Interlocked with AllowKbInput_M && KbJpActive_M-----------

;KbIncreaseJogInc_M: "insert"
IF Kb_Ins && AllowKbInput_M && KbJpActive_M THEN (KbIncreaseJogInc_M)
IF KbIncreaseJogInc_M && x1JogLED && !X1_M && !X10_M && !X100_M THEN SET X10_M
IF KbIncreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M THEN SET X100_M

;KbDecreaseJogInc_M: "delete"
IF Kb_Del && AllowKbInput_M && KbJpActive_M THEN (KbDecreaseJogInc_M)
IF KbDecreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M THEN SET X1_M
IF KbDecreaseJogInc_M && x100JogLED && !X1_M && !X10_M && !X100_M THEN SET X10_M

;KbJogAx1Plus_M: Right arrow
IF Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Right arrow
IF Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
IF Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
IF Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
IF Kb_PgUp && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
IF Kb_PgDown && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
IF Kb_Home && AllowKbInput_M && KbJpActive_M THEN (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
IF Kb_End && AllowKbInput_M && KbJpActive_M THEN (KbJogAx4Minus_M)

IF TRUE THEN RST KeyboardEventsStage

;-------------------------------------------------------------------------------
                           MPGStage
;-------------------------------------------------------------------------------
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED & on the MPG

IF MPGKey THEN (MpgPD)
IF MpgPD && MPGLED THEN SET MPGManOffFlag_M
IF !SV_MPG_1_ENABLED || (MpgPD && !MPGLED) THEN RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) || (SV_MPG_1_ENABLED && !MPGManOffFlag_M) &&
  !SV_PROGRAM_RUNNING THEN SET MPG_LED_OUT, SET MPGLED

IF (!SV_MPG_1_ENABLED || (MpgPD && MPGLED)) || SV_PROGRAM_RUNNING 
	THEN RST MPG_LED_OUT, RST MPGLED

;x1, x10, x100 functions
;--------------------------X1-----------------------------------
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp_M || X1_M || (MPG_Inc_X_1 && MPGLED)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--------------------------X10----------------------------------
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || X10_M || (MPG_Inc_X_10 && MPGLED) THEN RST x1JogLED, 
													  SET x10JogLED, 
													  RST x100JogLED

;--------------------------X100---------------------------------
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || X100_M || (MPG_Inc_X_100 && MPGLED) THEN RST x1JogLED, 
														 RST x10JogLED, 
														 SET x100JogLED

IF !KbIncreaseJogInc_M && !KbDecreaseJogInc_M THEN RST X1_M, 
												   RST X10_M,
												   RST X100_M

;                          MPG 1 Enable
IF MPG_AXIS_1 || MPG_AXIS_2 || MPG_AXIS_3 || MPG_AXIS_4 ||
  MPG_AXIS_5 || MPG_AXIS_6 || MPG_AXIS_7 || MPG_AXIS_8
  THEN (SV_MPG_1_ENABLED)

;                     Select axis to move
IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
IF MPG_AXIS_2 THEN SV_MPG_1_AXIS_SELECT = 2
IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4
IF MPG_AXIS_5 THEN SV_MPG_1_AXIS_SELECT = 5

;                   Select MPG 1 Multiplier
IF (MPG_Inc_X_100) THEN SV_MPG_1_MULTIPLIER = 100
IF (MPG_Inc_X_10) THEN  SV_MPG_1_MULTIPLIER = 10
IF (MPG_Inc_X_1) THEN   SV_MPG_1_MULTIPLIER = 1

;            Disable "Windup" mode IF x100 selected
IF (!MPG_Inc_X_100) THEN (SV_MPG_1_WINDUP_MODE)

;-------------------------------------------------------------------------------
                           WirelessMpgStage
;-------------------------------------------------------------------------------
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED & on the MPG

IF TRUE THEN UsbMpgActiveAxes_W = SV_MACHINE_PARAMETER_218
IF TRUE THEN BITTST UsbMpgActiveAxes_W 0 UsbMpgAxis1Active_M,
             BITTST UsbMpgActiveAxes_W 1 UsbMpgAxis2Active_M, 
			 BITTST UsbMpgActiveAxes_W 2 UsbMpgAxis3Active_M,
			 BITTST UsbMpgActiveAxes_W 3 UsbMpgAxis4Active_M

IF OnAtPowerUp_M THEN RST MPGLED
IF TRUE THEN UsbAxisMonitor_W = SV_USB_MPG_AXIS_SELECT

; Use echoed word value for USB mpg axis select so it can be explicitly set to 0 for invalid axes. 
IF ((UsbAxisMonitor_W == 1) && !UsbMpgAxis1Active_M) ||
   ((UsbAxisMonitor_W == 2) && !UsbMpgAxis2Active_M) ||
   ((UsbAxisMonitor_W == 3) && !UsbMpgAxis3Active_M) ||
   ((UsbAxisMonitor_W == 4) && !UsbMpgAxis4Active_M)
   THEN SV_MPG_1_AXIS_SELECT = 0, UsbAxisMonitor_W = 0  

IF UsbAxisMonitor_W > 0 THEN SET UsbMpgPresent
IF UsbMpgPresent && ((UsbAxisMonitor_W > 0) && UsbScaleMonitor_W <= 100) THEN (UsbMpgOn) 
IF true THEN UsbScaleMonitor_W = SV_USB_MPG_SCALE_SELECT 

IF MPGKey THEN (MpgPD)
IF MpgPD && MPGLED THEN SET MPGManOffFlag_M
IF !SV_MPG_1_ENABLED || (MpgPD && !MPGLED) THEN RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) || (SV_MPG_1_ENABLED && !MPGManOffFlag_M) || 
(UsbMpgPresent && (UsbAxisMonitor_W > 0))
  THEN SET MPG_LED_OUT, SET MPGLED

IF (!SV_MPG_1_ENABLED || (MpgPD && MPGLED)) || (UsbMpgPresent && (UsbAxisMonitor_W == 0))
  THEN RST MPG_LED_OUT, RST MPGLED

;x1, x10, x100 functions
;--X1
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp_M || (MPG_Inc_X_1 && MPGLED) ||
  (UsbMpgPresent && (UsbScaleMonitor_W == 1) && UsbMpgOn)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--X10
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || (MPG_Inc_X_10 && MPGLED)  || 
  (UsbMpgPresent && (UsbScaleMonitor_W == 10) && UsbMpgOn)
  THEN RST x1JogLED, SET x10JogLED, RST x100JogLED

;--X100
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || (MPG_Inc_X_100 && MPGLED)  || 
  (UsbMpgPresent && (UsbScaleMonitor_W == 100) && UsbMpgOn)
  THEN RST x1JogLED, RST x10JogLED, SET x100JogLED

;--MPG 1 Enable
IF MPG_AXIS_1 || MPG_AXIS_2 || MPG_AXIS_3 || MPG_AXIS_4 || 
  MPG_AXIS_5 || MPG_AXIS_6 || MPG_AXIS_7 || MPG_AXIS_8 || 
  ((SV_USB_MPG_AXIS_SELECT > 0) && (SV_USB_MPG_SCALE_SELECT <= 100)) 
  THEN (SV_MPG_1_ENABLED)

; Use echoed word value for USB mpg axis select so it can be explicitly set to 0 for invalid axes. 
IF (SV_USB_MPG_SCALE_SELECT > 100) || 
  ((UsbAxisMonitor_W == 1) && !UsbMpgAxis1Active_M) ||
  ((UsbAxisMonitor_W == 2) && !UsbMpgAxis2Active_M) ||
  ((UsbAxisMonitor_W == 3) && !UsbMpgAxis3Active_M) ||
  ((UsbAxisMonitor_W == 4) && !UsbMpgAxis4Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 0, UsbAxisMonitor_W = 0  
  
;                     Select axis to move
;IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
;IF MPG_AXIS_2 || MEM71 THEN SV_MPG_1_AXIS_SELECT = 2
;IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
;IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4
;IF MPG_AXIS_5 THEN SV_MPG_1_AXIS_SELECT = 5
IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 1) && UsbMpgAxis1Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 1

IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 2) && UsbMpgAxis2Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 2

IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 3) && UsbMpgAxis3Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 3  
  
IF (SV_USB_MPG_SCALE_SELECT <= 100) && ((UsbAxisMonitor_W == 4) && UsbMpgAxis4Active_M)
  THEN SV_MPG_1_AXIS_SELECT = 4  
  
IF UsbAxisMonitor_W == 0 THEN SV_MPG_1_AXIS_SELECT = 0   

;                   Select MPG 1 Multiplier
;IF (MPG_Inc_X_100) THEN SV_MPG_1_MULTIPLIER = 100
;IF (MPG_Inc_X_10) THEN  SV_MPG_1_MULTIPLIER = 10
;IF (MPG_Inc_X_1) THEN   SV_MPG_1_MULTIPLIER = 1
IF (SV_USB_MPG_SCALE_SELECT <= 100) THEN SV_MPG_1_MULTIPLIER = SV_USB_MPG_SCALE_SELECT
IF (SV_USB_MPG_SCALE_SELECT > 100)  THEN SV_MPG_1_MULTIPLIER = 1
													  
;            Disable "Windup" mode IF anything above x1 selected
IF (SV_MPG_1_MULTIPLIER < 10) THEN (SV_MPG_1_WINDUP_MODE)

;			Set Data to be seen by set axis Macro 0
IF (SV_USB_MPG_AXIS_SELECT == 0) 
	THEN RST UsbMpgAxis1Selected_M, RST UsbMpgAxis2Selected_M, RST UsbMpgAxis3Selected_M, RST UsbMpgAxis4Selected_M
	
IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgAxis1Active_M) 
	THEN SET UsbMpgAxis1Selected_M, RST UsbMpgAxis2Selected_M, RST UsbMpgAxis3Selected_M, RST UsbMpgAxis4Selected_M
	
IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgAxis2Active_M) 
	THEN RST UsbMpgAxis1Selected_M, SET UsbMpgAxis2Selected_M, RST UsbMpgAxis3Selected_M, RST UsbMpgAxis4Selected_M
	
IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgAxis3Active_M) 
	THEN RST UsbMpgAxis1Selected_M, RST UsbMpgAxis2Selected_M, SET UsbMpgAxis3Selected_M, RST UsbMpgAxis4Selected_M
	
IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgAxis4Active_M) 
	THEN RST UsbMpgAxis1Selected_M, RST UsbMpgAxis2Selected_M, RST UsbMpgAxis3Selected_M, SET UsbMpgAxis4Selected_M
	
;-------------------------------------------------------------------------------
                           JogPanelStage
;-------------------------------------------------------------------------------
;         Select Incremental or Continuous Jog Mode

IF IncrContKey || KbTogIncContJog_M || SkinIncCont_M THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp_M THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;              Select Fast or Slow Jog Mode

IF FastSlowKey || KbTogFastSlowJog_M || SkinFastSlowJog_M THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || OnAtPowerUp_M || DoorOpenSlowJog_M THEN SET FastSlowLED
IF (SlowFastPD && FastSlowLED) || OnAtPowerUp_M THEN RST FastSlowLED

;-------------------------------------------------------------------------------
;       Single Block Mode
;-------------------------------------------------------------------------------

IF SingleBlockKey || KbTogSingleBlock_M || SkinSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING THEN SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;-------------------------------------------------------------------------------
;           Toolcheck
;-------------------------------------------------------------------------------

IF (ToolCheckKey || KbToolCheck_M || SkinToolCheck_M) && EstopOk THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;-------------------------------------------------------------------------------
;          Feed Hold Mode
;-------------------------------------------------------------------------------

IF (FeedHoldKey || KbFeedHold_M || MpgFeedHold_M || SkinFeedHold_M) THEN (FeedHoldPD)

IF FeedHoldPD || ActivateFeedHold_M ||
   (FinalFeedOverride_W < P146Value_W && !OnAtPowerUp_M)
  THEN SET FeedHoldLED

  IF !SV_PROGRAM_RUNNING || DoCycleStart || DoCycleCancel || DoToolCheck || 
   (FinalFeedOverride_W >= P146Value_W && PrevFeedOverride_W < P146Value_W)
  THEN RST FeedHoldLED

;-------------------------------------------------------------------------------
;   Feedrate Override Section
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Feedrate override works as follows:

IF OnAtPowerUp_M THEN KbOverride_W = 100, FinalFeedOverride_W = 100

;-------------------------------------------------------------------------------

IF TRUE THEN SkinFeedOverTimer = 200
IF SkinFeedOverMinus_M THEN (SkinFeedOverMinusPD), SET SkinFeedOverTimer
IF SkinFeedOverPlus_M THEN (SkinFeedOverPlusPD), SET SkinFeedOverTimer
IF SkinFeedOver100 THEN RST UsingFeedrateKnob_M, KbOverride_W = 100, SET SkinFeedOverTimer

IF !SkinFeedOverPlus_M && !SkinFeedOverMinus_M THEN RST SkinFeedOverTimer 
															 
IF !WaitingForSleepTimer_M && ((KbIncFeedOver_M || SkinFeedOverPlusPD) || (SkinFeedOverTimer && SkinFeedOverPlus_M))  
	THEN KbOverride_W = KbOverride_W + 1,
		 RST UsingFeedrateKnob_M,
		 SET WaitingForSleepTimer_M,
		 SleepTimer = 30, 
		 SET SleepTimer

IF !WaitingForSleepTimer_M && ((KbDecFeedOver_M || SkinFeedOverMinusPD) || (SkinFeedOverTimer && SkinFeedOverMinus_M))
  THEN KbOverride_W = KbOverride_W - 1, 
	   RST UsingFeedrateKnob_M,
       SET WaitingForSleepTimer_M, 
	   SleepTimer = 30, 
	   SET SleepTimer

IF SleepTimer THEN RST WaitingForSleepTimer_M, RST SleepTimer

; MPG Feedrate Override Logic
IF !UsbMpgFeedWheelSelect_M || UsingFeedrateKnob_M THEN RST UsbMpgFeedWheelSet_M
IF (UsbMpgFeedWheelSelect_M && !UsbMpgFeedWheelSet_M) 
  THEN UsbWheelLast = SV_USB_MPG_ENCODER_WHEEL, 
	   SET UsbMpgFeedWheelSet_M,
	   RST UsingFeedrateKnob_M
IF UsbMpgFeedWheelSet_M THEN UsbWheelCurrent = SV_USB_MPG_ENCODER_WHEEL
IF UsbMpgFeedWheelSet_M THEN UsbWheelDelta = (UsbWheelCurrent - UsbWheelLast)
IF UsbMpgFeedWheelSet_M THEN UsbWheelLast = UsbWheelCurrent
IF UsbMpgFeedWheelSet_M THEN KbOverride_W = (KbOverride_W + UsbWheelDelta)

IF SkinFeedOver100 || KbFeedOver100_M THEN KbOverride_W = 100

;IF !OnAtPowerUp_M && (ABS(KbOverride_W - LastKbOverride_W) >=2)  
;  THEN FinalFeedOverride_W = KbOverride_W, (UsingKbOverride_M), LastKbOverride_W = KbOverride_W
;  
;IF !OnAtPowerUp_M && !UsingKbOverride_M && VirtualJpRunning_M
;  THEN (UsingVirtualOverride_M)  
;
;IF UsingVirtualOverride_M && (ABS(SkinFeedOverride_W1 - LastSkinFeedOverride_W) > 0)     
;  THEN FinalFeedOverride_W = SkinFeedOverride_W1
;  
;IF TRUE THEN LastSkinFeedOverride_W = SkinFeedOverride_W1  

; Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
; parm 39, but keeping the KbOverride_W limited keeps the "dead space"
; down and allows the PLC to respond to changes in the FeedrateKnob_W even if
; above 120. Overall override is still limited later but this gives better
; response in changing between KbOverride_W & the FeedrateKnob_W

IF KbOverride_W > SV_MACHINE_PARAMETER_39 THEN KbOverride_W = SV_MACHINE_PARAMETER_39

; Limit the keyboard override to 1
IF KbOverride_W < 1 THEN KbOverride_W = 1

IF TRUE THEN FinalFeedOverride_W = KbOverride_W

;-------------------------------------------------------------------------------
; 4 & 5. Limit override percentage to value set in Parameter 39
;-------------------------------------------------------------------------------

;------------------Limit final override percentage to parm 39------------------

IF FinalFeedOverride_W > SV_MACHINE_PARAMETER_39 THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39

IF FinalFeedOverride_W <= 1 THEN FinalFeedOverride_W = 1

;-------------------------------------------------------------------------------
;  Override Controls
;  It is important that the PLC program only writes to SV_PLC_FEEDRATE_KNOB once per pass
;-------------------------------------------------------------------------------
; Override control bit for the feedrate override
; 1 == feedrate override knob will effect feedrate
; 0 == override knob has NO effect on feedrate

IF  !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN FinalFeedOverride_W = 100

;-------------------------------------------------------------------------------
; 6. Send override percentage to CNC12
;-------------------------------------------------------------------------------

;----------------Send override to PC for modification if needed----------------

IF TRUE THEN SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W

;-------------------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;-------------------------------------------------------------------------------

IF True THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;-------------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and then multiplying the result by 100
; 3. If keyboard jogging is not disabled (it is enabled by default), the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" screen in CNC12 software) stores
;    a value which allows which the PLC program can use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC11 software by setting
;    SV_PLC_FeedrateKnob_W = FinalFeedOverride_W
; 7. CNC11 reads SV_PLC_FEEDRATE_KNOB, factors in it's on own override based
;    on parameter 78 (see operators manual for more info on parm 78) and then
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;-------------------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;-------------------------------------------------------------------------------

IF TRUE THEN FeedrateKnob_W = 1
IF TRUE THEN BTW FeedrateKnob_W JpFeedOrKnobBit0 8

;-------------------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;-------------------------------------------------------------------------------

IF TRUE THEN FeedrateKnob_W = (FeedrateKnob_W/127.5)*100

;-------------------------------------------------------------------------------
; 3.  Determine whether to us FeedrateKnob_W or KbOverride_W
;-------------------------------------------------------------------------------

; This section determines when to use the feedrate override value sent down
; by the jog panel (FeedrateKnob_W) or the feedrate override as determined
; by the PLC monitoring the keyboard override keys (KbOverride_W).

;-------------------------------------------------------------------------------
;     At power-up, default feedrate override is jog panel (FeedrateKnob_W)
;       To use both keyboard or jog panel overrides set p170 to 0 (default)
;       To use jog panel override only set p170 to 2
;       To use keyboard only set p170 to 4
;-------------------------------------------------------------------------------

IF OnAtPowerUp_M && KbOverOnly_M || KbFeedOver100_M THEN KbOverride_W = 100
IF OnAtPowerUp_M && !KbOverOnly_M THEN SET UsingFeedrateKnob_M,
  KbOverride_W = FeedrateKnob_W, Last_FeedrateKnob_W = FeedrateKnob_W

;----------------Calculate keyboard feedrate override---------------------------
; SleepTimer is used to limit the KbOverride_W update rate to 20% per sec
;-------------------------------------------------------------------------------

IF AllowKbInput_M && KbIncFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W + 1, 
	   RST UsingFeedrateKnob_M,
	   SET WaitingForSleepTimer_M, 
	   SleepTimer = 50, 
	   SET SleepTimer

IF AllowKbInput_M && KbDecFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W - 1, 
	   RST UsingFeedrateKnob_M,
	   SET WaitingForSleepTimer_M, 
	   SleepTimer = 50, 
	   SET SleepTimer

IF SleepTimer THEN RST WaitingForSleepTimer_M, 
				   RST SleepTimer

;------------Switch to FeedrateKnob_W if it changes more 3%----------------------
; Once it has changed by more than 3%, it will update as normal (1% increments)
; until it sees another KbOverride_W command at which point it will take
; another 3% change to re-activate the FeedrateKnob_W

IF (abs(Last_FeedrateKnob_W - FeedrateKnob_W) >= 3) || UsingFeedrateKnob_M
  THEN FinalFeedOverride_W = FeedrateKnob_W, 
	   KbOverride_W = FeedrateKnob_W,
	   Last_FeedrateKnob_W = FeedrateKnob_W, 
	   SET UsingFeedrateKnob_M

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W & the FeedrateKnob_W

IF KbOverride_W > SV_MACHINE_PARAMETER_39 THEN KbOverride_W = SV_MACHINE_PARAMETER_39

IF !UsingFeedrateKnob_M && !JogOverOnly_M THEN FinalFeedOverride_W = KbOverride_W

;-------------------------------------------------------------------------------
; 4 & 5. Limit override percentage to value set in Parameter 39
;-------------------------------------------------------------------------------

;------------------Limit final override percentage to parm 39-------------------

IF FinalFeedOverride_W > SV_MACHINE_PARAMETER_39 THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39
  
IF (FinalFeedOverride_W >= 99 && FinalFeedOverride_W <= 101) THEN FinalFeedOverride_W = 100

if FinalFeedOverride_W < 0 THEN FinalFeedOverride_W = 0

;-------------------------------------------------------------------------------
; 6. Send override percentage to CNC12
;-------------------------------------------------------------------------------

;----------------Send override to PC for modification if needed-----------------

IF TRUE THEN SV_PLC_Feedrate_Knob = FinalFeedOverride_W

;-------------------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;-------------------------------------------------------------------------------

IF TRUE THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;-------------------------------------------------------------------------------
;  MPU11 Jog Panel Functions
;-------------------------------------------------------------------------------
IF KB_F9 then (F9PD)
IF KbTogRapidOver_M || (F9PD && SV_PROGRAM_RUNNING) THEN (RapidOverPD)
IF RapidOverPD^ SelectRapidOverride THEN (SelectRapidOverride)

IF OnAtPowerUp_M THEN SET SelectRapidOverride

IF (CycleCancelKey || KbCycleCancel_M || MpgResetKey_M || SkinCycleCancel_M) && 
   (SV_PROGRAM_RUNNING || SV_MDI_MODE) || ErrorFlag_M 
  THEN (DoCycleCancel)

IF (CycleStartKey || KbCycleStart_M || MpgCycleStart_M || SkinCycleStart_M) 
  THEN (DoCycleStart)

IF (Ax1PlusJogKey  || KbJogAx1Plus_M || UsbMpgAxis1JogPlus_M || SkinJogAx1Plus_M) && 
   !Ax1PlusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) 
  THEN (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M || UsbMpgAxis1JogMinus_M || SkinJogAx1Minus_M) && 
   !Ax1MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) 
  THEN (DoAx1MinusJog)
IF (Ax2PlusJogKey  || KbJogAx2Plus_M || UsbMpgAxis2JogPlus_M || SkinJogAx2Plus_M) && 
   !Ax2PlusJogDisabled_M  && !(IncrContLED && FinalFeedOverride_W == 0) 
  THEN (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M || UsbMpgAxis2JogMinus_M || SkinJogAx2Minus_M) && 
   !Ax2MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) 
  THEN (DoAx2MinusJog)

IF (Ax3PlusJogKey  || KbJogAx3Plus_M || UsbMpgAxis3JogPlus_M || SkinJogAx3Plus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M || UsbMpgAxis3JogMinus_M || SkinJogAx3Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M || UsbMpgAxis4JogPlus_M || SkinJogAx4Plus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M || UsbMpgAxis4JogMinus_M || SkinJogAx4Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)

IF MpgMacro1_M THEN (MpgMacro1PD)
IF MpgMacro2_M THEN (MpgMacro2PD)
IF MpgMacro3_M THEN (MpgMacro3PD)
IF MpgMacro4_M THEN (MpgMacro4PD)

IF (Aux1Key || KbAux1Key_M || SkinAux1_M) THEN (DoAux1Key)
IF (Aux2Key || KbAux2Key_M || SkinAux2_M) THEN (DoAux2Key)
IF (Aux3Key || KbAux3Key_M || SkinAux3_M) THEN (DoAux3Key)
IF (Aux4Key || KbAux4Key_M || SkinAux4_M) THEN (DoAux4Key)
IF (Aux5Key || KbAux5Key_M || SkinAux5_M) THEN (DoAux5Key)
IF (Aux6Key || KbAux6Key_M || SkinAux6_M) THEN (DoAux6Key)
;IF (Aux7Key || KbAux7Key_M || SkinAux7_M) THEN (DoAux7Key)
;IF (Aux8Key || KbAux8Key_M || SkinAux8_M) THEN (DoAux8Key)
;IF (Aux9Key || KbAux9Key_M || SkinAux9_M) THEN (DoAux9Key)
IF (Aux10Key || KbAux10Key_M || SkinAux10_M) THEN (DoAux10Key)
IF (Aux11Key || KbAux11Key_M || SkinAux11_M) THEN (DoAux11Key)
IF (Aux12Key || KbAux12Key_M || SkinAux12_M) THEN (DoAux12Key)
IF x1JogLED THEN (SelectX1JogInc)
IF x10JogLED THEN (SelectX10JogInc)
IF x100JogLED THEN (SelectX100JogInc)
IF IncrContLED THEN (SelectIncContJog)
IF FastSlowLED THEN (SelectFastSlowJog)
IF MPGLED THEN (SelectMpgMode)
IF FeedHoldLED && SV_PC_OVERRIDE_CONTROL_FEEDHOLD THEN (DoFeedHold)

;-------------------------------------------------------------------------------
;               Coolant Functions
;-------------------------------------------------------------------------------

;--------------Toggle auto coolant mode---------------
; Toggle auto coolant mode
IF CoolAutoManKey || KbTogCoolAutoMan_M || SkinCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoModeLED && CoolantAutoManualPD) || OnAtPowerUp_M
  THEN SET CoolAutoModeLED

IF (CoolAutoModeLED && CoolantAutoManualPD) THEN RST CoolAutoModeLED

; Report coolant mode to CNC12
IF CoolAutoModeLED THEN (SelectCoolAutoMan)

; Display coolant mode message
; Changing to auto coolant mode ;2050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = AUTO_COOL_MSG

; Changing to manual coolant mode ;2051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = MAN_COOL_MSG

; Flood coolant on/off
;
;  Toggle on/off or off/on if:
;    In manual mode and a toggle key was pressed
;  Turn on if:
;    In auto mode and have M8
;  Turn off if:
;    Any fault or error
;    In auto mode and don't have M8
;    Doing tool check (?)

IF CoolFloodKey || KbFloodOnOff_M || SkinCoolFlood_M THEN (CoolantFloodPD)
IF ((FloodOut ^ (!CoolAutoModeLED && CoolantFloodPD)) || CoolAutoModeLED && M8)
	&& !(SV_STOP || CoolAutoModeLED && !M8 || ErrorFlag_M || DoToolCheck)
		THEN (FloodOut), (CoolFloodLED), (SelectCoolantFlood)

; Mist coolant on/off

IF (CoolMistKey || KbMistOnOff_M || SkinCoolMist_M) THEN (CoolantMistPD)
IF ((MistOut ^ (!CoolAutoModeLED && CoolantMistPD)) || CoolAutoModeLED && M7)
	&& !(SV_STOP || CoolAutoModeLED && !M7 || ErrorFlag_M || DoToolCheck)
		THEN (MistOut), (CoolMistLED), (SelectCoolantMist)
		
;-------------------------------------------------------------------------------
;                       Spindle Control
;-------------------------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
;      Select Auto or Manual Spindle Operation Mode
;-------------------------------------------------------------------------------
;-----Triggers to Toggle Auto/Manual Spindle Mode-------------

IF SpinAutoManKey || KbTogSpinAutoMan_M || SkinSpinAutoMan_M || UsbMpgSpinAutoMan_M
  THEN (SpinAutoManPD)

;----------Set spindle to auto mode on start-up-----------------
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp_M THEN SET SpinAutoModeLED

;---------------Set spindle to manual mode---------------------
IF SpinAutoManPD && SpinAutoModeLED THEN RST SpinAutoModeLED

;----------------------Report the Spindle mode to CNC12-------------------------
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;-------------------------------------------------------------------------------
;         Set triggers to start and stop the spindle
;-------------------------------------------------------------------------------
; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

;Handling for MPG Spindle on/off button MpgSpinOnOff_M
IF UsbMpgSpinOnOff_M && !UsbMpgSpinOnOffPressed_M && !UsbMpgSpinOnState_M
	THEN SET UsbMpgSpinOnState_M, SET UsbMpgSpinOn_M, SET UsbMpgSpinOnOffPressed_M, RST UsbMpgSpinOff_M

IF UsbMpgSpinOnOff_M && !UsbMpgSpinOnOffPressed_M && UsbMpgSpinOnState_M
	THEN SET UsbMpgSpinOff_M, RST UsbMpgSpinOn_M, SET UsbMpgSpinOnOffPressed_M, RST UsbMpgSpinOnState_M  
	
IF !UsbMpgSpinOnOff_M THEN RST UsbMpgSpinOnOffPressed_M, RST UsbMpgSpinOn_M, RST UsbMpgSpinOff_M

IF (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M || UsbMpgSpinOff_M || SkinSpinStop_M))
  THEN SET SpindlePause_M
  
IF ((M3 || M4) && (SpinStartKey || KbSpinStart_M || UsbMpgSpinOn_M || SkinSpinStart_M) ||
    !(SV_PROGRAM_RUNNING || SV_MDI_MODE)) THEN RST SpindlePause_M

IF ((SpinStartKey || KbSpinStart_M || UsbMpgSpinOn_M || SkinSpinStart_M) && !SpinAutoModeLED) ||
  (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M) ||
  ((SpinStartKey || KbSpinStart_M || UsbMpgSpinOn_M) && ((M3 || M4) && SpinAutoModeLED))
  THEN (SpinStart_M)

IF (SpinStopKey || KbSpinStop_M || UsbMpgSpinOff_M || SkinSpinStop_M) ||
   (SpinAutoModeLED && !(M3 || M4)) ||
   (SV_PC_RIGID_TAP_SPINDLE_OFF && SpinAutoModeLED) ||
   ProbeDetect || SV_STOP || ErrorFlag_M || SV_LIMIT_TRIPPED
  THEN (SpinStop_M)

;-------------------------------------------------------------------------------
;Adjust spindle override when entering manual or auto spin mode
;-------------------------------------------------------------------------------

;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 100,
  SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 10, RST SpinAutoModeLED

;-------------------------------------------------------------------------------
;                     Set spindle direction
;-------------------------------------------------------------------------------

;------------------Set Clockwise direction---------------------
IF ((KbSpinCW_M || SpinCWKey || SkinSpinCW_M) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
  THEN RST SpindleDirection_M
IF !SpindleDirection_M THEN (SpindleCWLED), (SelectSpindleCW)

;---------------Set Counterclockwise direction-----------------
IF ((KbSpinCCW_M || SpinCCWKey || SkinSpinCCW_M) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
  THEN SET SpindleDirection_M
IF SpindleDirection_M THEN (SpindleCCWLED), (SelectSpindleCCW)

IF SpindleDirection_M THEN (SpindleDirectionOut)

;-------------------------------------------------------------------------------
;                                Turn spindle on/off
;-------------------------------------------------------------------------------

IF ProbeDetect && SpinStart_M THEN set ProbeFault_M

; Check for limits tripped
IF (!Ax1_MinusLimitOk || !Ax1_PlusLimitOk || !Ax2_MinusLimitOk
	|| !Ax2_PlusLimitOk || !Ax3_MinusLimitOk || !Ax3_PlusLimitOk) THEN (LimitTripped_M)

IF (SpindleEnableOut || SpinStart_M ) && !SpinStop_M && !SV_STOP && !ProbeDetect
  && SpindleInverterOk && !LimitTripped_M THEN SET SpindleOutRequest_M
	
IF SpinStop_M || SV_STOP || ProbeDetect || !SpindleInverterOK || LimitTripped_M THEN RST SpindleOutRequest_M	

IF SpindleOutRequest_M THEN (SpindleEnableOut)
IF DoorInterlockMode_M && !DoorClosed THEN RST SpindleEnableOut
	
IF DoorInterlockMode_M && SpindleOutRequest_M && !DoorClosed THEN ErrorCode_W = DOOR_NOT_CLOSED

IF !SpindleEnableOut  THEN (DoSpindleStop)

;-------------------------------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "shift" + "<", "shift" + ">", "shift" + "<" & ">"
;-------------------------------------------------------------------------------

IF SpinOverPlusKey || KbIncSpinOver_M || SkinSpinOverPlus_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1
IF SpinOverMinusKey || KbDecSpinOver_M || SkinSpinOverMinus_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1
IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp_M || SkinSpin100_M
  THEN SV_PLC_SPINDLE_KNOB = 100
  
;MPG Spindle Logic
IF !UsbMpgSpinWheelSelect_M THEN RST UsbMpgSpinWheelSet_M
IF (UsbMpgSpinWheelSelect_M && !UsbMpgSpinWheelSet_M) THEN UsbWheelLast = SV_USB_MPG_ENCODER_WHEEL, 
														   SET UsbMpgSpinWheelSet_M
IF UsbMpgSpinWheelSet_M THEN UsbWheelCurrent = SV_USB_MPG_ENCODER_WHEEL
IF UsbMpgSpinWheelSet_M THEN UsbWheelDelta = (UsbWheelCurrent - UsbWheelLast)
IF UsbMpgSpinWheelSet_M THEN UsbWheelLast = UsbWheelCurrent
IF UsbMpgSpinWheelSet_M THEN SV_PLC_SPINDLE_KNOB = (SV_PLC_SPINDLE_KNOB + UsbWheelDelta)  
IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN
  (SpinOver100LED),
  (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN
  (SpinOverMinusLED),
  (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN
  (SpinOverPlusLED),
  (DoIncreaseSpindleOr)

;-------------------------------------------------------------------------------
;                  Output 16-bit DAC value for spindle control
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
;             Read spindle range inputs and/or range M codes
;
; NOTE: SV_SPINDLE_LOW_RANGE & SV_SPINDLE_MID_RANGE M are used to report the
; selected spindle range to CNC12
;-------------------------------------------------------------------------------
;    hi   med-high  med-low  low
;    0       1        1       0 	SV_SPINDLE_MID_RANGE M
;    0       0        1       1 	SV_SPINDLE_LOW_RANGE

IF SpinLowRange THEN SET SpinLowRange_M
IF !SpinLowRange THEN RST SpinLowRange_M

IF !SpinLowRange THEN (SpinHighRange_M), 
					  RST SV_SPINDLE_LOW_RANGE,
					  RST SV_SPINDLE_MID_RANGE

IF SpinLowRange_M && (SV_MACHINE_PARAMETER_65 > .01)
	THEN SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_65, 
		 SET SV_SPINDLE_LOW_RANGE,
		 RST SV_SPINDLE_MID_RANGE

IF SpinHighRange_M THEN SpinRangeAdjust_FW = 1
IF SpinRangeAdjust_FW == 0 THEN SpinRangeAdjust_FW = 1

;-------------------------------------------------------------------------------
;              Read commanded spindle speed, max & min
;
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
;-------------------------------------------------------------------------------

IF TRUE THEN SpinSpeedCommand_FW =  SV_PC_COMMANDED_SPINDLE_SPEED,
             CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED

;-------------------------------------------------------------------------------
; If commanded spindle speed is < min spin speed * SpinRangeAdjust_FW
; & commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust_FW.
;-------------------------------------------------------------------------------

IF (SpinSpeedCommand_FW > 0) &&
  (SpinSpeedCommand_FW < (CfgMinSpeed_FW * SpinRangeAdjust_FW))
  THEN SpinSpeedCommand_FW = (CfgMinSpeed_FW * SpinRangeAdjust_FW),
	   ErrorCode_W = MIN_SPEED_MSG

;-------------------------------------------------------------------------------
; If SpinSpeedCommand_FW > max Spin Speed * SpinRangeAdjust_FW, force
; SpinSpeedCommand_FW = max spin speed value * SpinRangeAdjust_FW.
;-------------------------------------------------------------------------------

IF SpinSpeedCommand_FW > (CfgMaxSpeed_FW * SpinRangeAdjust_FW)
  THEN SpinSpeedCommand_FW = (CfgMaxSpeed_FW * SpinRangeAdjust_FW)

;-------------------------------------------------------------------------------
                             ZeroTo5Or10Stage
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Convert spindle "S" command to 16 bit value for output to DAC
;-------------------------------------------------------------------------------
; Commanded spindle speed (includes override factor) is sent down from CNC12
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a
; 16 bit value (0-65535) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED.

;Display calculated RPM value on PC
IF TRUE THEN SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_FW

;Convert RPM to 16 bit value
IF TRUE THEN SixteenBitSpeed_FW = SpinSpeedCommand_FW/RPMPerBit_FW

; Factor in gear range
IF TRUE THEN SixteenBitSpeed_FW = (SixteenBitSpeed_FW/SpinRangeAdjust_FW)

;Convert to integer word for DAC & I/O display
IF TRUE THEN SixteenBitSpeed_W = SixteenBitSpeed_FW

; Bound min to 0, max to 65535
IF SixteenBitSpeed_W < 0 THEN SixteenBitSpeed_W = 0
IF SixteenBitSpeed_W > 65535 THEN SixteenBitSpeed_W = 65535

; Output to DAC
IF TRUE THEN WTB SixteenBitSpeed_W SpinAnalogOutBit0 16

; The following bits control the actual analog hardware output on the OAK.
; Output = 16bit (0-65536) Default 0-10VDC.
; Different analog ranges are available by setting Outputs 15 and 16:
; ----------------------------------------
; | Output 15 | Output 16 | Range         |
; |     0     |     0     | 0 to +10VDC   |
; |     0     |     1     | 0 to +5VDC    |
; |     1     |     0     | -5 to +5VDC   |
; |     1     |     1     | -10 to +10VDC | 
; -----------------------------------------

IF (!SpindleDACModeBit1 && !SpindleDACModeBit2) ||
  (!SpindleDACModeBit1 && SpindleDACModeBit2)
  THEN SET ZeroTo5Or10Stage, RST Minus5Or10ToPlus5Or10Stage
  
IF (SpindleDACModeBit1 && !SpindleDACModeBit2) ||
  (SpindleDACModeBit1 && SpindleDACModeBit2)
  THEN RST ZeroTo5Or10Stage, SET Minus5Or10ToPlus5Or10Stage

;-------------------------------------------------------------------------------
                       Minus5Or10ToPlus5Or10Stage
;-------------------------------------------------------------------------------
; Output to DAC

; 16 bit SpindleCommand (0-65536) is sent to -10-+10 output
; SixteenBitSpeed_W:  0 = -10VDC, 32768 = 0VDC, 65536 = +10VDC  

; Scale RPM command to 16 bit 
IF TRUE THEN SixteenBitSpeed_FW = SpinSpeedCommand_FW/RPMPerBit_FW

; Factor in gear range
IF TRUE THEN SixteenBitSpeed_FW = (SixteenBitSpeed_FW/SpinRangeAdjust_FW)

; Convert to integer word for DAC & I/O display
IF TRUE THEN SixteenBitSpeed_W = SixteenBitSpeed_FW

; 0 RPM = 32768
; If command is CW (SpindleDirectionOut = OFF) + 32768
; If command is CCW (SpindleDirectionOut = OFF), negate SixteenBitSpeed_W
; and add to 32768
IF !SpindleDirectionOut THEN SixteenBitSpeed_W = (SixteenBitSpeed_W + 32768) 
IF SpindleDirectionOut 
  THEN SixteenBitSpeed_W = (((SixteenBitSpeed_W * -1)*.5) + 32768)

; Bound min to 0, max to 65535
IF SixteenBitSpeed_W < 0 THEN SixteenBitSpeed_W = 0
IF SixteenBitSpeed_W > 65535 THEN SixteenBitSpeed_W = 65535

IF TRUE THEN WTB SixteenBitSpeed_W SpinAnalogOutBit0 16

; Display calculated RPM value on PC
IF TRUE THEN SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_FW

;-------------------------------------------------------------------------------
  CheckCycloneStatusStage
;-------------------------------------------------------------------------------
; Due to amount of time it takes to retrieve data from the cyclone, this stage
; is only called few times per second to help reduce scan time of the main PLC
; program.

; Read Axis1FiberOk_M through Axis8FiberOk_M
IF True THEN WTB SV_PC_CYCLONE_STATUS_2 Axis1FiberOk_M

; Generate some messages for fiber or wire to MPU11 having issues
IF SV_AXIS_VALID_1 && !SV_DRIVE_ONLINE_1 THEN ErrorCode_W = AXIS1_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_2 && !SV_DRIVE_ONLINE_2 THEN ErrorCode_W = AXIS2_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_3 && !SV_DRIVE_ONLINE_3 THEN ErrorCode_W = AXIS3_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_4 && !SV_DRIVE_ONLINE_4 THEN ErrorCode_W = AXIS4_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_5 && !SV_DRIVE_ONLINE_5 THEN ErrorCode_W = AXIS5_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_6 && !SV_DRIVE_ONLINE_6 THEN ErrorCode_W = AXIS6_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_7 && !SV_DRIVE_ONLINE_7 THEN ErrorCode_W = AXIS7_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_8 && !SV_DRIVE_ONLINE_8 THEN ErrorCode_W = AXIS8_INFLT, SET DriveComFltIn_M

; Generate some messages for fiber or wire to drive having issues
IF SV_AXIS_VALID_1 && SV_DRIVE_ONLINE_1 && SV_MASTER_ENABLE && !Axis1FiberOk_M
  THEN ErrorCode_W = AXIS1_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_2 && SV_DRIVE_ONLINE_2 && SV_MASTER_ENABLE && !Axis2FiberOk_M
  THEN ErrorCode_W = AXIS2_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_3 && SV_DRIVE_ONLINE_3 && SV_MASTER_ENABLE && !Axis3FiberOk_M
  THEN ErrorCode_W = AXIS3_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_4 && SV_DRIVE_ONLINE_4 && SV_MASTER_ENABLE && !Axis4FiberOk_M
  THEN ErrorCode_W = AXIS4_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_5 && SV_DRIVE_ONLINE_5 && SV_MASTER_ENABLE && !Axis5FiberOk_M
  THEN ErrorCode_W = AXIS5_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_6 && SV_DRIVE_ONLINE_6 && SV_MASTER_ENABLE && !Axis6FiberOk_M
  THEN ErrorCode_W = AXIS6_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_7 && SV_DRIVE_ONLINE_7 && SV_MASTER_ENABLE && !Axis7FiberOk_M
  THEN ErrorCode_W = AXIS7_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_8 && SV_DRIVE_ONLINE_8 && SV_MASTER_ENABLE && !Axis8FiberOk_M
  THEN ErrorCode_W = AXIS8_OUTFLT, SET DriveComFltOut_M

IF !EstopOk THEN RST DriveComFltIn_M, RST DriveComFltOut_M
IF DriveComFltOut_M || DriveComFltIn_M THEN SET AxisFault_M

; Check PLC and JogBoard status bits
IF TRUE THEN CycloneStatus_W = SV_PC_CYCLONE_STATUS_1,
             BITTST CycloneStatus_W 21 PLCBusExtDevEn_M,
             BITTST CycloneStatus_W 23 JogPanelOnline_M

; Check PLC input fiber
IF !SV_PLC_BUS_ONLINE THEN ErrorCode_W = PLC_INFLT,
                           RST PLCBus_Oe_M, SET PLCFault_M

; Check PLC output fiber
IF SV_PLC_BUS_ONLINE && PLCBus_Oe_M && !PLCBusExtDevEn_M
  THEN ErrorCode_W = PLC_OUTFLT, SET PLCFault_M

; Clear PLC errors
IF PLCFault_M && SV_PLC_BUS_ONLINE && PLCBusExtDevEn_M && !EstopOk
  THEN RST PLCFault_M, InfoMsg_W = PLC_FLT_CLR, SET PLCBus_Oe_M

; Check JOGBRD incoming communications
IF SV_JOG_LINK_ONLINE THEN (JogLinkOk_M)
IF JogPanelRequired_M && !JogLinkOk_M
  THEN ErrorCode_W = JOGBOARD_INFLT, SET OtherFault_M

; Check JOGBRD outgoing communications
IF JogPanelRequired_M && JogLinkOk_M && !JogPanelOnline_M
  THEN ErrorCode_W = JOGBOARD_OUTFLT, SET OtherFault_M

; Check MiniPLC board communications
IF TRUE THEN MiniPLCStatus_W = SV_PC_MINI_PLC_ONLINE,
             P900Value_W = SV_MACHINE_PARAMETER_900
IF MiniPLCStatus_W != P900Value_W THEN SET MiniPLCErrorStage

IF TRUE THEN RST CheckCycloneStatusStage

;-------------------------------------------------------------------------------
   MiniPLCErrorStage
;-------------------------------------------------------------------------------
IF TRUE THEN WTB P900Value_W MiniPLCExpected1_M 8,
             WTB MiniPLCStatus_W MiniPLCOk1_M 8

IF MiniPLCExpected1_M && !MiniPLCOk1_M
  THEN ErrorCode_W = MINI_PLC_1_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected2_M && !MiniPLCOk2_M
  THEN ErrorCode_W = MINI_PLC_2_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected3_M && !MiniPLCOk3_M
  THEN ErrorCode_W = MINI_PLC_3_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected4_M && !MiniPLCOk4_M
  THEN ErrorCode_W = MINI_PLC_4_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected5_M && !MiniPLCOk5_M
  THEN ErrorCode_W = MINI_PLC_5_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected6_M && !MiniPLCOk6_M
  THEN ErrorCode_W = MINI_PLC_6_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected7_M && !MiniPLCOk7_M
  THEN ErrorCode_W = MINI_PLC_7_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected8_M && !MiniPLCOk8_M
  THEN ErrorCode_W = MINI_PLC_8_FLT_MSG, SET OtherFault_M

IF MiniPLCOk1_M && !MiniPLCExpected1_M
  THEN InfoMsg_W = MINI_PLC_1_WARNING
IF MiniPLCOk2_M && !MiniPLCExpected2_M
  THEN InfoMsg_W = MINI_PLC_2_WARNING
IF MiniPLCOk3_M && !MiniPLCExpected3_M
  THEN InfoMsg_W = MINI_PLC_3_WARNING
IF MiniPLCOk4_M && !MiniPLCExpected4_M
  THEN InfoMsg_W = MINI_PLC_4_WARNING
IF MiniPLCOk5_M && !MiniPLCExpected5_M
  THEN InfoMsg_W = MINI_PLC_5_WARNING
IF MiniPLCOk6_M && !MiniPLCExpected6_M
  THEN InfoMsg_W = MINI_PLC_6_WARNING
IF MiniPLCOk7_M && !MiniPLCExpected7_M
  THEN InfoMsg_W = MINI_PLC_7_WARNING
IF MiniPLCOk8_M && !MiniPLCExpected8_M
  THEN InfoMsg_W = MINI_PLC_8_WARNING

IF TRUE THEN RST MiniPLCErrorStage

;-------------------------------------------------------------------------------
                     AxesEnableStage
;-------------------------------------------------------------------------------

; Report external drive faults
IF SV_AXIS_VALID_1 && SV_PC_POWER_AXIS_1 && !Axis1DriveOk 
	THEN ErrorCode_W = AXIS1_DRIVE_FAULT, ; 6401(1+256*25)
		 SET AxisFault_M,
		 SET Axis1Fault_M
IF SV_AXIS_VALID_2 && SV_PC_POWER_AXIS_2 && !Axis2DriveOk 
	THEN ErrorCode_W = AXIS2_DRIVE_FAULT, ; 6655(1+256*26)
		 SET AxisFault_M,
		 SET Axis2Fault_M
IF SV_AXIS_VALID_3 && SV_PC_POWER_AXIS_3 && !Axis3DriveOk 
	THEN ErrorCode_W = AXIS3_DRIVE_FAULT, ; 6913(1+256*27)
		 SET AxisFault_M,
		 SET Axis3Fault_M
IF SV_AXIS_VALID_4 && SV_PC_POWER_AXIS_4 && !Axis4DriveOk 
	THEN ErrorCode_W = AXIS4_DRIVE_FAULT, ; 7169(1+256*28)
		 SET AxisFault_M,
		 SET Axis4Fault_M
IF SV_AXIS_VALID_5 && SV_PC_POWER_AXIS_5 && !Axis5DriveOk
	THEN ErrorCode_W = AXIS5_DRIVE_FAULT, ; 7425(1+256*29)
		 SET AxisFault_M,
		 SET Axis5Fault_M

IF SV_AXIS_VALID_3 && SV_PC_POWER_AXIS_3 && Axis3DriveOk
  THEN (ZBrakeRelease)
  
IF !EstopOk THEN RST AxisFault_M, RST Axis1Fault_M, RST Axis2Fault_M, 
	RST Axis3Fault_M, RST Axis4Fault_M, RST Axis5Fault_M

; Read the status bits
IF TRUE THEN SET CycloneStatusTimer
IF CycloneStatusTimer THEN SET CheckCycloneStatusStage, RST CycloneStatusTimer

; Turn on drives if no errors
IF !PLCFault_M && !SV_STALL_ERROR THEN SET SV_MASTER_ENABLE

IF PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE, SET SV_STOP

;****************************************
            MainStage
;****************************************

;Do gather if commanded (uncomment and recompile for debugging purposes)
;IF Aux11Key THEN (Aux11KeyPD)
;IF Aux11KeyPD THEN (SV_TRIGGER_PLOT_DUMP)

IF TRUE THEN BTW SpindleMeterADC_W AnalogInput 16

IF SpindleMeterADC_W > 32767 THEN SpindleMeterADC_W = SpindleMeterADC_W - 65536
 
; TODO: Pre-compute constants in initial stage
; The Delta drives put out +/-8V at max torque 
; The spindle is +/-10V
IF TRUE THEN SpindleMeterADC_W = (100 * SpindleMeterADC_W) / 2048
 
IF TRUE THEN SV_SPINDLE_METER = abs(SpindleMeterADC_W)

; By setting SV_SYS_MACRO to a value of something other than zero, the PLC is 
; requesting CNC12 to run the corresponding macro in the c:\cncm\system directory
; Setting SV_SYS_MACRO = 1, run c:\cncm\system\macro1.mac. Cnc12 will not run the
; same macro twice in a row unless SV_SYS_MACRO has been set to 0 between requests.

IF MpgMacro1PD THEN SV_SYS_MACRO = 1
IF MpgMacro2PD THEN SV_SYS_MACRO = 2
IF MpgMacro3PD THEN SV_SYS_MACRO = 3
IF MpgMacro4PD THEN SV_SYS_MACRO = 4
IF (SV_SYS_MACRO > 0) && !(MpgMacro1PD || MpgMacro2PD || MpgMacro3PD || MpgMacro4PD)
  THEN SV_SYS_MACRO = 0

;-------------------------------------------------------------------------------
;                            USB MPG Section
;-------------------------------------------------------------------------------

; Word to bit for USB mpg operation
IF TRUE THEN WTB SV_USB_MPG_BUTTON_STATE MpgResetKey_M 13
IF (SV_USB_MPG_SCALE_SELECT == 1000) THEN SET UsbMpgSpinWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT != 1000) THEN RST UsbMpgSpinWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT == 10000) THEN SET UsbMpgFeedWheelSelect_M
IF (SV_USB_MPG_SCALE_SELECT != 10000) THEN RST UsbMpgFeedWheelSelect_M

; Handle jog keys for MPGKey
; Reset all keys first
IF !((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogPlus_M) THEN RST UsbMpgAxis1JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogMinus_M) THEN RST UsbMpgAxis1JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogPlus_M) THEN RST UsbMpgAxis2JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogMinus_M) THEN RST UsbMpgAxis2JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogPlus_M) THEN RST UsbMpgAxis3JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogMinus_M) THEN RST UsbMpgAxis3JogMinus_M
IF !((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogPlus_M) THEN RST UsbMpgAxis4JogPlus_M
IF !((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogMinus_M) THEN RST UsbMpgAxis4JogMinus_M

; Set appropriate key
IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogPlus_M) THEN SET UsbMpgAxis1JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 1) && UsbMpgJogMinus_M) THEN SET UsbMpgAxis1JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogPlus_M) THEN SET UsbMpgAxis2JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 2) && UsbMpgJogMinus_M) THEN SET UsbMpgAxis2JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogPlus_M) THEN SET UsbMpgAxis3JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 3) && UsbMpgJogMinus_M) THEN SET UsbMpgAxis3JogMinus_M
IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogPlus_M) THEN SET UsbMpgAxis4JogPlus_M
IF ((SV_USB_MPG_AXIS_SELECT == 4) && UsbMpgJogMinus_M) THEN SET UsbMpgAxis4JogMinus_M
	   
IF MpgSetAxisZero_M && UsbMpgAxis1Active_M && UsbMpgAxis1Selected_M THEN (SetAxis1Part0)
IF MpgSetAxisZero_M && UsbMpgAxis2Active_M && UsbMpgAxis2Selected_M THEN (SetAxis2Part0)
IF MpgSetAxisZero_M && UsbMpgAxis3Active_M && UsbMpgAxis3Selected_M THEN (SetAxis3Part0)
IF MpgSetAxisZero_M && UsbMpgAxis4Active_M && UsbMpgAxis4Selected_M THEN (SetAxis4Part0)

;-------------------------------------------------------------------------------
;           Spindle Chiller Control
;
; The chiller is enabled with the SpindleEnableOut and then
; if the SpindleEnableOut is shut off the chiller stays on 
; until the chiller off timer expires or E-stop is depressed
;-------------------------------------------------------------------------------

IF !SpindleEnableOut THEN SET ChillerOff_T, RST SpindleChillerFault_T
IF SpindleEnableOut THEN SET SpindleChillerOut, RST ChillerOff_T
IF SpindleChillerOut && (!EstopOk || ChillerOff_T) THEN RST SpindleChillerOut
IF SpindleChillerOut THEN (CoolingFanOut)

IF SpindleChillerOut && !ChillerOk THEN SET SpindleChillerFault_T
IF SpindleChillerFault_T && !ChillerOk THEN ErrorCode_W = SPINDLE_CHILLER_FAULT,
											SET SetErrorStage, 
											RST SpindleChillerOut, 
											RST SpindleChillerFault_T,
											SET SV_STOP
   
IF SpindleChillerFault_T && ChillerOk THEN RST SpindleChillerFault_T  
   
IF !SpindleChillerOut THEN RST SpindleChillerFault_T

;-------------------------------------------------------------------------------
;           Probe protection while jogging
;-------------------------------------------------------------------------------

IF MechanicalProbe && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
    DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
    DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog) THEN
    (JogProbeFaultPD)

IF MechanicalProbe && !JogProbeFault_M && FastSlowLED THEN SET LastProbeMode_M
IF MechanicalProbe && !JogProbeFault_M && !FastSlowLED THEN RST LastProbeMode_M
	
IF JogProbeFaultPD && !JogProbeFault_M THEN SET JogProbeFault_M, SET DoCycleCancel

IF JogProbeFault_M THEN ErrorCode_W = (PROBE_JOG_FAULT_MSG + 1), SET FastSlowLED
	
IF !MechanicalProbe && JogProbeFault_M && !LastProbeMode_M THEN RST FastSlowLED

IF !MechanicalProbe THEN RST JogProbeFault_M,
                         RST Ax1PlusJogDisabled_M,
                         RST Ax1MinusJogDisabled_M,
                         RST Ax2PlusJogDisabled_M,
                         RST Ax2MinusJogDisabled_M

;-------------------------------------------------------------------------------
;     Rotary Clamp Section
;-------------------------------------------------------------------------------

;IF SV_PROGRAM_RUNNING && M10 THEN SET ClampOut
;IF !M10 THEN RST ClampOut

IF SkinResetKey_M THEN (SetResetPD)

IF (SetResetPD && ResetSet && EstopOk) || (EstopOK && EstopCycled_M) THEN RST ResetSet, RST EstopCycled_M
IF (SetResetPD && !ResetSet) || !EstopOK THEN SET ResetSet
IF SetResetPD && ResetSet THEN (ResetClearedPD)
IF !EstopOK THEN SET EstopCycled_M

IF ResetSet THEN SET SV_STOP

; Process important keyboard keys all the time
; Cycle Cancel (ESC)
IF Kb_Escape THEN (KbCycleCancel_M)

;KbFeedHold_M (spacebar)
IF Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING THEN (KbFeedHold_M)

IF SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEventsStage if needed
IF Kb_L_Ctrl || Kb_R_Ctrl ||
   Kb_L_Shift || Kb_R_Shift ||
   Kb_R_Alt || Kb_L_Alt || KbJpActive_M
  THEN SET KeyboardEventsStage

IF (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
   && (Kb_j || Kb_f || Kb_a || Kb_s) && !AllowKbInput_M
  THEN InfoMsg_W = KB_JOG_MSG

;-------------------------------------------------------------------------------
;    Reset these M-codes if not in CNC Program Running mode
;-------------------------------------------------------------------------------

IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE THEN RST M3,
											RST M4,
											RST M8,
											RST M7

;-------------------------------------------------------------------------------
;                Chip Flood Pump Control
;-------------------------------------------------------------------------------

IF Aux10Key THEN (Aux10_PD)

IF (M21) THEN (M21PD)

IF ((Aux10_PD && !Aux10LED)) THEN SET ChipPumpOut, SET Aux10LED
IF ((Aux10_PD && Aux10LED)) THEN RST ChipPumpOut, RST Aux10LED

IF (!M21) THEN (M22PD)

IF M21PD THEN SET ChipPumpOut, SET Aux10LED
IF M22PD THEN RST ChipPumpOut, RST Aux10LED

IF (OnAtPowerUp_M && P171Value_W == 1) THEN SET Aux4LED

;-------------------------------------------------------------------------------
; Faults
;-------------------------------------------------------------------------------

IF !EStopOk || PLCFault_M || SV_STALL_ERROR || SpindleFault_M ||
  LubeFault_M || AxisFault_M ||  ProbeFault_M THEN SET SV_STOP
IF !EstopOk && SV_STALL_ERROR THEN RST SV_STALL_ERROR
IF SV_Stop || PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE
IF InitializeTimer && !LubeOk && !SV_PROGRAM_RUNNING && EStopOk
  THEN SET LubeFault_M, ErrorCode_W = LUBE_FAULT_MSG

IF !LubeOk && SV_PROGRAM_RUNNING THEN ErrorCode_W = LUBE_WARNING_MSG

IF !EstopOK && LubeOk THEN RST LubeFault_M    ;clear lube fault
IF !EstopOK && ProbeFault_M THEN RST ProbeFault_M, RST ProbeMsgSent_M
IF InitializeTimer && SpindleFault_T && !SpindleInverterOk THEN ErrorCode_W = SPINDLE_FAULT,
    SET SV_STOP, SET SpindleFault_M
IF !EstopOK && SpindleFault_M THEN (InverterResetOut), RST SpindleFault_M, RST SpindleFault_T

IF EStopOk && !PLCFault_M && !SV_STALL_ERROR && !SpindleFault_M &&
  !LubeFault_M && SV_PLC_BUS_ONLINE && !PLCFault_M && !SoftwareReady_M &&
  !PLCExecutorFault_M && !AxisFault_M THEN RST SV_STOP

IF ProbeFault_M && !ProbeMsgSent_M THEN ErrorCode_W = PROBE_FAULT_MSG, 
										SET SetErrorStage, 
										SET ProbeMsgSent_M

;OpticDirect bits
; SV_DRIVE_STATUS_1
;  5 = alarm bit 3, 6 = alarm bit 2, 7 = alarm bit 1, 8 = /TGON,
;  9 = brake state, 10 = /S_RDY, 11 = quadrature Error, 12 = direction,
;  13 = Index pulse, 14 = diff. error, 15 = drive fault
; SV_DRIVE_CONTROL_1
;  7 = POS_CLR, 8 = P-OT, 9 = N-OT, 10 = /P-CON, 11 = /P-CL, 12 = /N-CL,
;  13 = ABS. send, 14 = Alarm reset, 15 = enable
IF !EstopOk THEN BITSET Sv_Control_1_Shadow 14,
                 BITRST Sv_Control_1_Shadow 7
IF EstopOk THEN BITRST Sv_Control_1_Shadow 14,
                BITSET Sv_Control_1_Shadow 7
				
IF !EstopOk THEN BITSET Sv_Control_2_Shadow 14,
                 BITRST Sv_Control_2_Shadow 7
IF EstopOk THEN BITRST Sv_Control_2_Shadow 14,
                BITSET Sv_Control_2_Shadow 7
				
IF !EstopOk THEN BITSET Sv_Control_3_Shadow 14,
                 BITRST Sv_Control_3_Shadow 7
IF EstopOk THEN BITRST Sv_Control_3_Shadow 14,
                BITSET Sv_Control_3_Shadow 7
				
IF !EstopOk THEN BITSET Sv_Control_4_Shadow 14,
                 BITRST Sv_Control_4_Shadow 7
IF EstopOk THEN BITRST Sv_Control_4_Shadow 14,
                BITSET Sv_Control_4_Shadow 7
				
IF TRUE THEN SV_DRIVE_CONTROL_1 = Sv_Control_1_Shadow,
             SV_DRIVE_CONTROL_2 = Sv_Control_2_Shadow,
             SV_DRIVE_CONTROL_3 = Sv_Control_3_Shadow,
             SV_DRIVE_CONTROL_4 = Sv_Control_4_Shadow,
             SV_DRIVE_CONTROL_5 = Sv_Control_5_Shadow

IF TRUE THEN WTB SV_DRIVE_STATUS_1 Axis1StatusBit0 16,
             WTB SV_DRIVE_STATUS_2 Axis2StatusBit0 16,
             WTB SV_DRIVE_STATUS_3 Axis3StatusBit0 16,
             WTB SV_DRIVE_STATUS_4 Axis4StatusBit0 16,
             WTB SV_DRIVE_STATUS_5 Axis5StatusBit0 16

IF !Axis1DriveALM THEN (Axis1DriveOk)
IF !Axis2DriveALM THEN (Axis2DriveOk)
IF !Axis3DriveALM THEN (Axis3DriveOk)
IF !Axis4DriveALM THEN (Axis4DriveOk)
IF !Axis5DriveALM THEN (Axis5DriveOk)

;-------------------------------------------------------------------------------
; Status Lights:
;   - Red Light for all stop / error conditions
;   - Amber Light when not running a job, doing a tool change,
;     or waiting for operator input
;   - Green Light when running a job normally
;-------------------------------------------------------------------------------

; Red Light
IF (SV_Stop && !LightBlinkOff_M) THEN (RedLightOut)

; Amber Light
IF ((M6 || !SV_PROGRAM_RUNNING) && !RedLightOut && !LightBlinkOff_M) THEN (AmberLightOut)

; Green Light
IF (SV_PROGRAM_RUNNING && !RedLightOut && !AmberLightOut && !LightBlinkOff_M) then (GreenLightOut)

; Use a timer to make the lights blink:
IF LightBlinkOn_T THEN SET LightBlinkOff_M,
					   RST LightBlinkOn_T,
					   SET LightBlinkOff_T

IF LightBlinkOff_T THEN RST LightBlinkOff_M,
						SET LightBlinkOn_T,
						RST LightBlinkOff_T

;-------------------------------------------------------------------------------
; Tool release
;-------------------------------------------------------------------------------

IF ToolRelease && ZeroSpeed && !SV_PROGRAM_RUNNING
   && !DoingM6_M && EStopOk THEN SET ToolUnclampOut, SET AirBlowOut
IF !ToolRelease && !DoingM6_M THEN RST ToolUnclampOut, RST AirBlowOut
	
;-------------------------------------------------------------------------------
; Worklight
;-------------------------------------------------------------------------------

IF (Aux7Key || KbAux7Key_M || SkinAux7_M) THEN (WorklightPD)
IF (WorkLightPD && !WorkLightOut) || OnAtPowerUp_M THEN SET WorkLightOut
IF WorkLightPD && WorkLightOut THEN RST WorkLightOut
IF WorkLightOut THEN (Aux7LED)    

;-------------------------------------------------------------------------------
; Detect auto spindle and coolant requests during manual modes
;-------------------------------------------------------------------------------

IF M3 || M4 THEN (AutoSpindlePD)
IF AutoSpindlePD && !SpinAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_SPINDLE_PROMPT

IF M7 || M8 THEN (AutoCoolantPD)
IF AutoCoolantPD && !CoolAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_COOLANT_PROMPT

IF ActivateFeedHold_M THEN TriggerPause_T=100, SET TriggerPause_T
IF TriggerPause_T THEN RST TriggerPause_T, RST ActivateFeedHold_M

IF TRUE THEN MessageTimer = 200  
IF ResetSet && EstopOK THEN SET MessageTimer, InfoMsg_W = RESET_DETECTED
IF ResetSet && MessageTimer THEN RST MessageTimer

IF ResetSet && EstopOK THEN SET ResetArmed_M

IF !ResetSet && ResetArmed_M THEN SET MessageTimer, InfoMsg_W = RESET_CLEARED
IF !ResetSet && ResetArmed_M && MessageTimer THEN RST MessageTimer, RST ResetArmed_M
																  
IF ResetSet THEN (SkinResetSet_M)

; Turn off default setup variable
IF TRUE THEN RST OnAtPowerUp_M

; *********** RESET INITIAL STAGE ********
; *********** TESTING ONLY!!!!!!! ********

;IF (Aux4Key && Aux5Key && Aux6Key) THEN SET InitialStage
IF !EstopOk THEN RST ATCCount_M, RST ATCRotate_M

; Set SV_PLC_CAROUSEL_POSITION to the current internal PLC bin number,
; the CNC software will then read this to update it's internal bin position
; (reported by Alt-K)
IF TRUE THEN SV_PLC_CAROUSEL_POSITION = Bin_Position_W

;-------------------------------------------------------------------------------
; Reset tool change sequence

IF !EstopOk THEN RST DoingM6_M, RST M6

IF P6Value_W == 1 && EStopOK && !SV_STOP && !DoingM6_M && !M6 THEN SET ATC_InitialStage

IF (EstopOk &&!SV_STOP) && Pre_M6 THEN SET PreToolChangeOrientMem
IF !EstopOk || SV_STOP THEN RST PreToolChangeOrientMem

;-------------------------------------------------------------------------------
; Reset tool change timers if E-stop condition or SV_STOP set

IF !EstopOk || SV_STOP THEN RST AirTimer_T,
							RST ATC_OrientLost_T,
							RST StopReason_T,
							RST Car_Enable_T,
							RST ATC_Orient_T1,
							RST ATC_Unclamp_T1,
							RST ATC_Rotate_T1,
							RST ATC_Rotate_T2,
							RST ATC_Count_T1,
							RST ATC_Count_T2,
							RST ATC_Clamp_T1,
							RST ATC_PotDown_T1,
							RST ATC_End_T1,
							RST ATC_MoveZAxis_T1,
							RST ATC_ARM_HTC_T1,
							RST ATC_AHTCWS_T1,
							RST ATC_PotUp_T1,
							RST ATC_ARM_D180U_T1,
							RST ATC_AD1UWS_T1,
							RST ATC_ARM_CTH_T1,
							RST ATC_ACTHWS_T1,
							RST P176_T,
							RST M14,
							RST M15,
							RST AugerKeyStart_M,
							RST SpindleChillerFault_T

;-------------------------------------------------------------------------------
     ATCMainStage
;-------------------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Understanding the tool change sequence
;
;  State of arm sensors through one cycle
;
;  The clamp positions are when the arm is grabbing both
;  the tool in the spindle and the tool in the extended carousel pot.
;
;  Between Clamp1 and Clamp2 the arm moves down, rotates ~180 degrees
;  and then moves up, thus exchanging the tool in the spindle with the
;  one in the extended tool pot holder.
;
;  To move the arm from one position to another:
;    - Turn ArmMotorOut ON and wait for ArmAtStopInput OFF  (see A below)
;    - Wait for ArmAtStopInput ON and turn ArmMotorOut OFF  (see B below)
;    - Verify arm sensors for intended position, i.e.,
;        ArmAtStopInput and ArmAtHomeInput  (If home position)  (see H below)
;        ArmAtStopInput and ArmAtClampInput (If clamp position) (see C1 and C2 below)
;
;   Note that there is no definitive way to distinguish between Clamp1 and
;   Clamp2 states.
;
;              Home        Clamp1        Clamp2          Home
;
;               H     A  B   C1     A  B   C2     A  B   H
;  Arm_Home   ----+                                   +----
;                 |                                   |
;                 +-----------------------------------+
;
;  Arm_Stop   ------+   +---------+   +---------+   +------
;                   |   |         |   |         |   |
;                   +---+         +---+         +---+
;
;                         +-----+       +-----+
;  Arm_Clamp              |     |       |     |
;             ------------+     +-------+     +-------------
;               H     A  B   C1     A  B   C2     A  B   H
;
;  The entire tool change sequence:
;  Starting from the Arm Home position with tool clamped
;  and pot retracted:
;
;    - Move Z axIS to tool change height
;    - Orient spindle
;    - Extend tool pot
;    - Move arm to clamp1 position
;    - Unclamp tool
;    - Move arm to clamp2 position (exchange the tool in spindle and tool in pot)
;    - Clamp tool
;    - Move arm to home
;    - Retract tool pot
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IF TRUE THEN SV_PLC_CAROUSEL_POSITION = Bin_Position_W

;-------------------------------------------------------------------------------
;  Pot Down
;-------------------------------------------------------------------------------

IF M14 && ATCOverrideKey THEN (PotDownOut)

;-------------------------------------------------------------------------------
;  Pot Up
;-------------------------------------------------------------------------------

IF M15 && ATCOverrideKey THEN (PotUpOut)

;-------------------------------------------------------------------------------
;   Low Air
;-------------------------------------------------------------------------------

IF !AirPressureOk THEN SET AirTimer_T
IF AirPressureOk THEN RST AirTimer_T
IF AirTimer_T && DoingM6_M THEN ErrorCode_W = LOW_AIR_FAULT, ;1 + 256*142, ; LOW AIR FAULT
								SET SetErrorStage, 
								SET SV_STOP

;-------------------------------------------------------------------------------
;   Initialize ATC
;-------------------------------------------------------------------------------

IF M18 THEN (M18_1Shot)
IF M18_1Shot THEN Bin_Position_W = 1,
				  Wanted_Bin_W = Bin_Position_W,
				  ErrorCode_W = ATC_INITIALIZED ;2 + 256*139, ; --- ATC Initialized ---

;-------------------------------------------------------------------------------
;   M19 Orient Spindle
;-------------------------------------------------------------------------------

IF M19 THEN (M19_1Shot)
IF M19_1Shot THEN SET ATC_DoM19Stage
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN RST M19

;IF M19 && !ToolUnclamped THEN ErrorCode_W = M19_FAULT_TOOL_CLAMPED, ;1 + 256*143, ; M19 FAULT TOOL CLAMPED
;        					   SET SetErrorStage

IF M13 THEN (M13_1Shot)
IF M13_1Shot && ATCOverrideKey THEN SET ATC_M13ArmRotateStage

;IF 1==1 && SV_PC_SOFTWARE_READY THEN (StopReason_1Shot)
;IF StopReason_1Shot THEN SET StopReason_T

; Handle tool pre-fetch being sent down from CNC12
; txxx M107

;IF StopReason_1Shot THEN NewM107Bin_W = SV_TOOL_NUMBER
IF SV_PC_SOFTWARE_READY THEN NewM107Bin_W = SV_TOOL_NUMBER

IF NewM107Bin_W != OldM107Binr_W && !DoingRotate_M && !DoingM6_M
   && NewM107Bin_W >= 1 && NewM107Bin_W <= Max_Bins_W
   THEN Wanted_Bin_W = NewM107Bin_W, 
		OldM107Binr_W = NewM107Bin_W,
		SET DoingRotate_M, 
		SET ATC_SetDirectionStage

IF (Aux9Key || KbAux9Key_M || SkinAux9_M) && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  && StopReason_1Shot
   && SV_PC_SOFTWARE_READY
  THEN SET DoingIndex_M,
       SET ATC_DoToolIndexUpStage

IF (Aux8Key || KbAux8Key_M || SkinAux8_M) && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  && StopReason_1Shot
   && SV_PC_SOFTWARE_READY
  THEN SET DoingIndex_M,
       SET ATC_DoToolIndexDnStage

;IF ToolIndexUpKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  THEN SET DoingIndex_M,
;       SET ATC_DoToolIndexUpStage

;IF ToolIndexDnKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  THEN SET DoingIndex_M,
;       SET ATC_DoToolIndexDnStage

;-------------------------------------------------------------------------------
; Check for running a job and not doing an M6 tool change
; and ATC signals not in correct state.
;
; Note that since the carousel must rotate to the next tool while a job is running
; that the ToolCounter sensor is only checked when not doing the rotation.
;-------------------------------------------------------------------------------

IF SV_PROGRAM_RUNNING && !DoingM6_M && !ATCOverrideKey &&
   (
     !ArmAtHomeInput || ArmAtClampInput || !ArmAtStopInput ||
     ToolUnclamped || !ToolClamped ||
     PotDown || !PotUp || (!DoingRotate_M && !ToolCounter)
   )
  THEN (tempbit)

IF tempbit && !ArmAtHomeInput
   THEN ErrorCode_W = ATC_NR_ARM_HOME   ;1 + 256*101 ; ATC NOT READY: ArmAtHomeInput INP

IF tempbit && ArmAtClampInput
   THEN ErrorCode_W = ATC_NR_ARM_AT_CLAMP   ;1 + 256*102 ; ATC NOT READY: ArmAtClamp INP

IF tempbit && !ArmAtStopInput
   THEN ErrorCode_W = ATC_NR_ARM_AT_STOP   ;1 + 256*103 ; ATC NOT READY: ArmAtStopInput INP

IF tempbit && ToolUnclamped
   THEN ErrorCode_W = ATC_NR_TOOL_UNCLMP  ;1 + 256*104 ; ATC NOT READY: ToolUnclamped INP

IF tempbit &&  !ToolClamped
   THEN ErrorCode_W = ATC_NR_TOOL_CLMP  ;1 + 256*105 ; ATC NOT READY: ToolClamped INP

IF tempbit && PotDown
   THEN ErrorCode_W = ATC_NR_POT_DOWN  ;1 + 256*106 ; ATC NOT READY: PotDown INP

IF tempbit && !PotUp
   THEN ErrorCode_W = ATC_NR_POT_UP  ;1 + 256*107 ; ATC NOT READY: PotUp INP

IF tempbit && !ToolCounter
   THEN ErrorCode_W = ATC_NR_TOOL_COUNTER  ;1 + 256*108 ; ATC NOT READY: ToolCounter INP

IF tempbit THEN RST tempbit,
				SET SetErrorStage, 
				SET SV_STOP

;-------------------------------------------------------------------------------
;   Stop condition - reset all solenoids and ATC stages
;-------------------------------------------------------------------------------
IF SV_STOP THEN
;
;  Reset Stages Involved in DoingToolChange
;
   RST OrientRequestOut,
   RST ATC_DoToolIndexUpStage,
   RST ATC_DoToolIndexDnStage,
   RST ATC_M13ArmRotateStage,
   RST M13_ArmWaitStopStage,
   RST ATC_CheckStageRotateStage,
   RST ATC_ReadyStage,
   RST ATC_MoveZAxisStage,
   RST ATC_PotDownStage,
   RST ATC_OrientStage,
   RST ATC_ArmAtHomeToClampStage,
   RST ATC_AHTCWaitStopStage,
   RST ATC_UnclampStage,
   RST ATC_ArmDown180UpStage,
   RST ATC_AD1UWaitStopStage,
   RST ATC_ClampStage,
   RST ATC_ArmAtClampToHomeStage,
   RST ATC_ACTHWaitStopStage,
   RST ATC_PotUpStage,
   RST ATC_EndStage,
   RST ATC_AcceptStage,
   RST ATC_SetDirectionStage,
   RST ATC_RotateStage,
   RST ATC_DoneRotateStage,
   RST ATC_CountStage,
   RST ATC_CheckStage,
;
;  Turn Off Solenoids and Motors
;
   RST PotUpOut,
   RST PotDownOut,
   RST ArmMotorOut,
   RST ToolUnclampOut,
   RST AirBlowOut,
   RST MagMotorEnableOut,
;
;  Reset Tool Change Status Flags
;
   RST DoingM6_M,
   RST DoingRotate_M,
   RST DoingIndex_M,
   RST ArmHasMoved_M,
   RST ArmHasStopped_M,
   RST ChipPumpOut,
   RST SpindleFault_T

;-------------------------------------------------------------------------------
     ATC_InitialStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST END_REQ_M,
			 RST MZ_REQ_M,
			 RST DoingM6_M

IF M6 THEN JMP ATC_CheckStageRotateStage

;-------------------------------------------------------------------------------
     ATC_CheckStageRotateStage
;-------------------------------------------------------------------------------

IF TRUE THEN Wanted_Bin_W = SV_TOOL_NUMBER

IF Wanted_Bin_W < 1 || Wanted_Bin_W > Max_Bins_W
   THEN ErrorCode_W = ATC_BIN_OUT_OF_RANGE, ;1 + 256*109 ;, ; "ATC Bin Out of Range"
        JMP SetErrorStage, 
		SET SV_STOP

IF Wanted_Bin_W != Bin_Position_W && !DoingRotate_M
   THEN SET DoingRotate_M, SET ATC_SetDirectionStage

IF !DoingRotate_M && !MagMotorEnableOut THEN JMP ATC_ReadyStage

;-------------------------------------------------------------------------------
     ATC_ReadyStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST AirBlowOut,
			 RST ArmMotorOut,
			 RST MagMotorEnableOut,
			 RST ToolUnclampOut,
			 RST PotDownOut,
			 RST PotUpOut

IF !MZ_ACK && M6 THEN JMP ATC_MoveZAxisStage,
				 SET DoingM6_M,
				 (tempbit)

IF MZ_ACK THEN ErrorCode_W = ATC_NR_MZ_ACK  ;1 + 256*110 ; ATC NOT READY: MZ_ACK

IF !tempbit THEN JMP SetErrorStage, 
				 SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_MoveZAxisStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET MZ_REQ_M, SET ATC_MoveZAxis_T1

IF MZ_ACK && M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && !PotDown && PotUp  && ToolCounter
   THEN JMP ATC_OrientStage, RST ATC_MoveZAxis_T1

IF ATC_MoveZAxis_T1
   THEN ErrorCode_W = ATC_TIMEOUT_MOVE_Z_STAGE, ;1 + 256*111 ; ATC_MoveZAxisStage TIMEOUT
		JMP SetErrorStage, 
		RST ATC_MoveZAxis_T1, 
		SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_OrientStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST MZ_REQ_M,
			 SET OrientRequestOut,
			 SET ATC_Orient_T1

IF !M19 THEN RST OrientRequestOut

IF !MZ_ACK && M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && !PotDown && PotUp  &&
   ToolCounter && OrientComplete
   THEN JMP ATC_PotDownStage, RST ATC_Orient_T1

IF ATC_Orient_T1 THEN ErrorCode_W = ATC_TIMEOUT_ORIENT_STAGE, ;1 + 256*112, ; ATC_OrientStage TIMEOUT
					  JMP SetErrorStage, 
					  RST ATC_Orient_T1, 
					  SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_PotDownStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET PotDownOut,
			 SET ATC_PotDown_T1

IF !MZ_ACK && M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_ArmAtHomeToClampStage, RST ATC_PotDown_T1

IF ATC_PotDown_T1 THEN ErrorCode_W = ATC_TIMEOUT_POT_DOWN_STAGE, ;1 + 256*113 ; ATC_PotDownStage TIMEOUT
					   JMP SetErrorStage, 
					   RST ATC_PotDown_T1, 
					   SET SV_STOP

IF !OrientComplete THEN ErrorCode_W = ATC_ORIENT_LOST_POT_DOWN_STAGE, ;1 + 256*114 ; ATC_PotDownStage ORIENT LOST
						JMP SetErrorStage, 
						RST ATC_PotDown_T1, 
						SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_ArmAtHomeToClampStage
;-------------------------------------------------------------------------------

;IF TRUE THEN RST PotDownOut,
;         	  SET ArmMotorOut,
;         	  SET ATC_ARM_HTC_T1

;IF !MZ_ACK && M6 && !ArmAtHomeInput && !ArmAtClampInput && !ArmAtStopInput &&
;   !ToolUnclamped && ToolClamped && PotDown && !PotUp &&
;   ToolCounter && OrientComplete
;   THEN JMP ATC_AHTCWaitStopStage, RST ATC_ARM_HTC_T1

;IF ArmAtClampInput THEN ErrorCode_W = ATC_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*115 ; ATC_AHTC CLAMP WITHOUT STOP
;    					 JMP SetErrorStage,
;    					 RST ArmMotorOut, 
;						 RST ATC_ARM_HTC_T1, 
;						 SET SV_STOP

;IF ATC_ARM_HTC_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_TO_CLAMP, ;1 + 256*116 ; ATC_ARM_TO_CLAMP TIMEOUT
;    					JMP SetErrorStage, 
;						RST ATC_ARM_HTC_T1, 
;						SET SV_STOP

IF !ArmHasStopped_M THEN RST PotDownOut,
						 SET ArmMotorOut,
						 SET ATC_ARM_HTC_T1
		 
; Make sure the arm moves before we wait for it to stop
IF !ArmAtHomeInput && !ArmAtStopInput && ArmMotorOut THEN SET ArmHasMoved_M

; If the arm was moving before
IF ArmAtStopInput && ArmHasMoved_M then RST ArmMotorOut, SET ArmHasStopped_M

IF !MZ_ACK && M6 && !ArmAtHomeInput && !ArmAtClampInput && !ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_AHTCWaitStopStage, 
		RST ATC_ARM_HTC_T1, 
		RST ArmHasStopped_M, 
		RST ArmHasMoved_M

;IF ArmAtClampInput THEN ErrorCode_W = ATC_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*115 ; ATC_AHTC CLAMP WITHOUT STOP
;    					 JMP SetErrorStage,
;    					 RST ArmMotorOut, 
;						 RST ATC_ARM_HTC_T1, 
;						 SET SV_STOP

IF ATC_ARM_HTC_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_TO_CLAMP, ;1 + 256*116 ; ATC_ARM_TO_CLAMP TIMEOUT
					   JMP SetErrorStage, 
					   RST ATC_ARM_HTC_T1, 
					   RST ArmHasStopped_M, 
					   RST ArmHasMoved_M, 
					   SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_AHTCWaitStopStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ATC_AHTCWS_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_UnclampStage

IF ArmAtStopInput THEN RST ArmMotorOut, RST ATC_AHTCWS_T1

IF ATC_AHTCWS_T1 THEN ErrorCode_W = ATC_TIMEOUT_WAIT_STOP_AHTC_STAGE, ;1 + 256*117 ; ATC_AHTCWaitStopStage TIMEOUT
					  JMP SetErrorStage, 
					  RST ATC_AHTCWS_T1, 
					  SET SV_STOP

IF (ArmAtHomeInput || ArmAtClampInput) && !ArmAtStopInput
   THEN ErrorCode_W = ATC_HOME_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*118 ; ARM HOME/CLAMP NO STOP
		JMP SetErrorStage,
		RST ArmMotorOut, 
		RST ATC_AHTCWS_T1, 
		SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_UnclampStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST ArmMotorOut,
			 SET ToolUnclampOut,
			 SET AirBlowOut,
			 SET ATC_Unclamp_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && ArmAtClampInput && ArmAtStopInput &&
   ToolUnclamped && !ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN SET P176_T

IF (P176_T && ToolUnclamped && !ToolClamped) THEN JMP ATC_ArmDown180UpStage, 
												  RST ATC_Unclamp_T1

IF ATC_Unclamp_T1 THEN ErrorCode_W = ATC_TIMEOUT_UNCLAMP_STAGE, ;1 + 256*119 ; ATC_UnclampStage TIMEOUT
					   JMP SetErrorStage, 
					   RST ATC_Unclamp_T1, 
					   SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_ArmDown180UpStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ArmMotorOut,
			 SET ATC_ARM_D180U_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && !ArmAtClampInput && !ArmAtStopInput &&
   ToolUnclamped && !ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete 
   THEN JMP ATC_AD1UWaitStopStage, RST ATC_ARM_D180U_T1

IF ATC_ARM_D180U_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_D180UP_STAGE, ;1 + 256*120 ; ATC_ARM_D180U TIMEOUT
						 JMP SetErrorStage, 
						 RST ATC_ARM_D180U_T1, 
						 SET SV_STOP

IF !ToolUnclamped || ToolClamped THEN ErrorCode_W = ATC_CLAMP_FAULT_ARM_D180UP_STAGE, ;1 + 256*131 ; ATC_ARM_D180U CLAMP FAULT
									  JMP SetErrorStage,
									  RST ArmMotorOut, 
									  RST ATC_ARM_D180U_T1, 
									  SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_AD1UWaitStopStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ATC_AD1UWS_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && ArmAtClampInput && ArmAtStopInput &&
   ToolUnclamped && !ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_ClampStage, RST ATC_AD1UWS_T1

IF ArmAtStopInput THEN RST ArmMotorOut, RST ATC_AD1UWS_T1

IF ATC_AD1UWS_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_D1UWS_STAGE, ;1 + 256*121 ; ATC_ARM_D1UWS TIMEOUT
					  JMP SetErrorStage, 
					  RST ATC_AD1UWS_T1, 
					  SET SV_STOP

IF (ArmAtHomeInput || ArmAtClampInput) && !ArmAtStopInput
   THEN ErrorCode_W = ATC_HOME_CLAMP_WO_STOP, ;1 + 256*122 ; ARM HOME/CLAMP NO STOP
		JMP SetErrorStage,
		RST ArmMotorOut, 
		RST ATC_AD1UWS_T1, 
		SET SV_STOP

IF !ToolUnclamped || ToolClamped THEN ErrorCode_W = ATC_CLAMP_FAULT_ARM_D1UWS_STAGE, ;1 + 256*132 ; ATC_ARM_D1UWS CLAMP FAULT
									  JMP SetErrorStage,
									  RST ArmMotorOut, 
									  RST ATC_AD1UWS_T1, 
									  SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_ClampStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST ArmMotorOut,
			 RST ToolUnclampOut, 
			 RST AirBlowOut,
			 SET ATC_Clamp_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_ArmAtClampToHomeStage, RST ATC_Clamp_T1

IF ATC_Clamp_T1 THEN ErrorCode_W = ATC_TIMEOUT_CLAMP_STAGE, ;1 + 256*123 ; ATC_ClampStage TIMEOUT
					 JMP SetErrorStage, 
					 RST ATC_Clamp_T1, 
					 SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_ArmAtClampToHomeStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ArmMotorOut,
			 SET ATC_ARM_CTH_T1

IF !MZ_ACK && M6 && !ArmAtHomeInput && !ArmAtClampInput && !ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp && ToolCounter
   THEN JMP ATC_ACTHWaitStopStage, RST ATC_ARM_CTH_T1

IF ATC_ARM_CTH_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_CTH, ;1 + 256*124 ; ATC_ARM_CTH TIMEOUT
					   JMP SetErrorStage, 
					   RST ATC_ARM_CTH_T1, 
					   SET SV_STOP

IF ArmAtHomeInput THEN ErrorCode_W = ATC_WO_STOP_ACTH_HOME_STAGE, ;1 + 256*125 ; ATC_ACTH HOME NO STOP
					   JMP SetErrorStage,
					   RST ArmMotorOut, 
					   RST ATC_ARM_CTH_T1, 
					   SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_ACTHWaitStopStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ATC_ACTHWS_T1

IF !MZ_ACK && M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && PotDown && !PotUp && ToolCounter
   THEN JMP ATC_PotUpStage, RST ATC_ACTHWS_T1

IF ATC_ACTHWS_T1 THEN ErrorCode_W = ATC_TIMEOUT_ARM_HTCWS_STAGE, ;1 + 256*126 ; ATC_ARM_HTCWS TIMEOUT
					  JMP SetErrorStage, 
					  RST ATC_ACTHWS_T1, 
					  SET SV_STOP

IF ArmAtStopInput THEN RST ArmMotorOut, RST ATC_ACTHWS_T1

IF (ArmAtHomeInput || ArmAtClampInput) && !ArmAtStopInput
   THEN ErrorCode_W = ATC_WO_STOP_ARM_HOME_CLAMP, ;1 + 256*127 ; ARM HOME/CLAMP NO STOP
		JMP SetErrorStage,
		RST ArmMotorOut, 
		RST ATC_ACTHWS_T1, 
		SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_PotUpStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST ArmMotorOut,
			 SET PotUpOut,
			 SET ATC_PotUp_T1

IF !MZ_ACK && M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && !PotDown && PotUp && ToolCounter
   THEN JMP ATC_EndStage, RST ATC_PotUp_T1

IF ATC_PotUp_T1 THEN ErrorCode_W = ATC_TIMEOUT_POT_UP_STAGE, ;1 + 256*128 ; ATC_PotUpStage TIMEOUT
					 JMP SetErrorStage, 
					 RST ATC_PotUp_T1, 
					 SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_EndStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST PotUpOut,
             RST OrientRequestOut,
			 RST SpindleEnableOut,
			 SET END_REQ_M,
			 RST DoingM6_M,
			 SET ATC_End_T1

IF !MZ_ACK && !M6 && ArmAtHomeInput && !ArmAtClampInput && ArmAtStopInput &&
   !ToolUnclamped && ToolClamped && !PotDown && PotUp &&
   ToolCounter && OrientComplete
   THEN JMP ATC_AcceptStage, RST ATC_End_T1

IF ATC_End_T1 THEN ErrorCode_W = ATC_TIMEOUT_END_STAGE, ;1 + 256*129 ; ATC_EndStage TIMEOUT
				   JMP SetErrorStage, 
				   RST ATC_End_T1, 
				   SET SV_STOP

;-------------------------------------------------------------------------------
     ATC_AcceptStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST END_REQ_M,
			 JMP ATC_InitialStage

;-------------------------------------------------------------------------------
   ATC_SetDirectionStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET Car_enable_T

IF Wanted_Bin_W >= Bin_Position_W THEN Distance_W = Wanted_Bin_W - Bin_Position_W,  
									   (Calc_B1_M)

IF Bin_Position_W > Wanted_Bin_W THEN Distance_W = Bin_Position_W - Wanted_Bin_W,  
									  (Calc_B2_M)

IF Calc_B1_M && Distance_W <= Max_Bins_W/2 THEN MotorDir_W = 1
IF Calc_B1_M && Distance_W >  Max_Bins_W/2 THEN MotorDir_W = -1,
												Distance_W = Max_Bins_W - Distance_W

IF Calc_B2_M && Distance_W <= Max_Bins_W/2 THEN MotorDir_W = -1
IF Calc_B2_M && Distance_W >  Max_Bins_W/2 THEN MotorDir_W = 1,
												Distance_W = Max_Bins_W - Distance_W

IF MotorDir_W < 0 THEN SET MagMotorMinusOut
IF MotorDir_W > 0 THEN RST MagMotorMinusOut

IF Distance_W != 0 && Car_Enable_T THEN JMP ATC_RotateStage, 
										RST Car_enable_T
IF Distance_W == 0 THEN JMP ATC_DoneRotateStage, 
						RST Car_enable_T

;-------------------------------------------------------------------------------
   ATC_RotateStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET MagMotorEnableOut,
			 SET ATC_Rotate_T1,
			 SET ATCRotate_M
;          	 SET ATC_Rotate_T2
;
; Wait until the tool sensor changes state.
;
;IF !ToolCounter && (ATC_Rotate_T2 || (Tool_Noise_Fault_M && DoingIndex_M))
;	THEN JMP ATC_CountStage

IF !ToolCounter THEN JMP ATC_CountStage, 
					 RST ATC_Rotate_T1, 
					 RST ATC_Rotate_T2

;IF !ToolCounter && !ATC_Rotate_T2 && !Tool_Noise_Fault_M
;   THEN ErrorCode_W = ATC_TOOL_COUNTER_NOISE, ;1 + 256*133, ; ATC TOOL COUNTER NOISE
;    	 SET Tool_Noise_Fault_M,
;    	 JMP SetErrorStage, 
;		 RST ATC_Rotate_T1, 
;		 RST ATC_Rotate_T2

IF ATC_Rotate_T1 THEN ErrorCode_W = ATC_TIMEOUT_TOOL_COUNTER, ;1 + 256*134, ; ATC TOOL COUNTER TIMEOUT
					  JMP SetErrorStage, 
					  RST ATC_Rotate_T1, 
					  RST ATC_Rotate_T2, 
					  SET SV_STOP

IF PotDown || !PotUp THEN ErrorCode_W = ATC_POT_FAULT_ROTATE_STAGE, ;1 + 256*135, ; ATC_RotateStage POT FAULT
						  JMP SetErrorStage,
						  RST MagMotorEnableOut, 
						  RST ATC_Rotate_T1, 
						  RST ATC_Rotate_T2, 
						  SET SV_STOP

;-------------------------------------------------------------------------------
   ATC_CountStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ATC_Count_T1,
			 SET ATCCount_M,
			 SET ATC_Count_T2

; Wait until the tool sensor changes state.
IF ToolCounter THEN JMP ATC_CheckStage, 
					RST ATC_Count_T1, 
					RST ATC_Count_T2

;IF ToolCounter && !ATC_Count_T2
;   THEN ErrorCode_W = ATC_TOOL_COUNTER_NOISE_COUNT_STAGE, ;1 + 256*136, ; ATC TOOL COUNTER NOISE
;    	 SET Tool_Noise_Fault_M,
;    	 JMP SetErrorStage, 
;		 RST ATC_Count_T1, 
;		 RST ATC_Count_T2

IF ATC_Count_T1 THEN ErrorCode_W = ATC_TIMEOUT_TOOL_COUNTER_COUNT_STAGE, ;1 + 256*137, ; ATC TOOL COUNTER TIMEOUT
					 JMP SetErrorStage, 
					 RST ATC_Count_T1, 
					 RST ATC_Count_T2 , 
					 SET SV_STOP

IF PotDown || !PotUp THEN ErrorCode_W = ATC_POT_FAULT_COUNT_STAGE, ;1 + 256*138, ; ATC_CountStage POT FAULT
						  JMP SetErrorStage,
						  RST MagMotorEnableOut, 
						  RST ATC_Count_T1, 
						  RST ATC_Count_T2 , 
						  SET SV_STOP

;-------------------------------------------------------------------------------
   ATC_CheckStage
;-------------------------------------------------------------------------------

IF MagMotorMinusOut  && MagMotorEnableOut THEN Bin_Position_W = Bin_Position_W - 1
IF !MagMotorMinusOut && MagMotorEnableOut THEN Bin_Position_W = Bin_Position_W + 1
IF Bin_Position_W > Max_Bins_W THEN Bin_Position_W = 1
IF Bin_Position_W < 1 THEN Bin_Position_W = Max_Bins_W

IF Distance_W > 0 THEN Distance_W = Distance_W - 1

IF TRUE THEN JMP ATC_DoneRotateStage

;-------------------------------------------------------------------------------
   ATC_DoneRotateStage
;-------------------------------------------------------------------------------

IF DoingIndex_M && Tool_Noise_Fault_M
   THEN ErrorCode_W = ATC_TOOL_COUNTER_FAULT_CLEARED, ;2 + 256*140, ; Tool Counter Fault Cleared
		RST Tool_Noise_Fault_M


IF Bin_Position_W == Wanted_Bin_W THEN RST MagMotorEnableOut,
									   RST DoingIndex_M,
									   RST DoingRotate_M,
									   RST ATC_DoneRotateStage

IF Bin_Position_W != Wanted_Bin_W THEN JMP ATC_RotateStage

;-------------------------------------------------------------------------------
     ATC_DoToolIndexUpStage
;-------------------------------------------------------------------------------

IF TRUE THEN Wanted_Bin_W = Bin_Position_W + 1,
			 JMP ATC_SetDirectionStage

IF Wanted_Bin_W > Max_Bins_W THEN Wanted_Bin_W = 1

;-------------------------------------------------------------------------------
     ATC_DoToolIndexDnStage
;-------------------------------------------------------------------------------

IF TRUE THEN Wanted_Bin_W = Bin_Position_W - 1,
			 JMP ATC_SetDirectionStage

IF Wanted_Bin_W < 1 THEN Wanted_Bin_W = Max_Bins_W

;-------------------------------------------------------------------------------
     ATC_M13ArmRotateStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET ArmMotorOut
IF !ArmAtStopInput THEN JMP M13_ArmWaitStopStage

;-------------------------------------------------------------------------------
     M13_ArmWaitStopStage
;-------------------------------------------------------------------------------

IF ArmAtStopInput THEN RST ArmMotorOut,
					   RST M13_ArmWaitStopStage

;-------------------------------------------------------------------------------
   ATC_DoM19Stage
;-------------------------------------------------------------------------------

IF SV_PROGRAM_RUNNING || SV_MDI_MODE THEN SET OrientRequestOut

IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE && ATC_OrientLost_T
   THEN ErrorCode_W = M19_STOPPED_M19_STAGE, ;1 + 256*144, ; M19 STOPPED
		JMP SetErrorStage , 
		SET SV_STOP

IF OrientComplete THEN JMP ATC_MonitorM19Stage, RST ATC_OrientLost_T

IF !M19 THEN RST ATC_DoM19Stage, RST ATC_OrientLost_T,
             RST OrientRequestOut

;-------------------------------------------------------------------------------
   ATC_MonitorM19Stage
;-------------------------------------------------------------------------------

IF !OrientComplete THEN SET ATC_OrientLost_T
IF OrientComplete THEN RST ATC_OrientLost_T

IF ATC_OrientLost_T THEN ErrorCode_W = M19_ORIENT_LOST_M19_MON_STAGE, ;1 + 256*145, ; M19 ORIENT LOST
						 JMP SetErrorStage, 
						 RST ATC_OrientLost_T, 
						 SET SV_STOP

IF !M19 THEN RST ATC_MonitorM19Stage,
			 RST OrientRequestOut, 
			 RST ATC_OrientLost_T
		 
;-------------------------------------------------------------------------------
     AugerOffStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST Aux5LED,
			 RST Aux6LED,
			 RST Auger1Enable,
			 RST Auger1DirOut,
			 RST Auger2Enable,
			 RST Auger2DirOut

IF DoAux5Key THEN (CAFWD_PD), SET AugerKeyStart_M	     
IF DoAux6Key THEN (CAREV_PD), SET AugerKeyStart_M
IF M31 || M32 THEN (CA1_PD)

;The following lines prevents the auger while the job is running
;IF (CA1_PD && M31) || (CAFWD_PD && !SV_PROGRAM_RUNNING) THEN JMP AugerFwdStage
;IF (CA1_PD && M32) || (CAREV_PD && !SV_PROGRAM_RUNNING) THEN JMP AugerRevStage
;The following lines allows the auger while the job is running
IF (CA1_PD && M31) || (CAFWD_PD ) THEN JMP AugerFwdStage
IF (CA1_PD && M32) || (CAREV_PD ) THEN JMP AugerRevStage

;-------------------------------------------------------------------------------
    AugerFwdStage
;-------------------------------------------------------------------------------

IF TRUE THEN RST Aux6LED,
			 SET Aux5LED
IF TRUE && P171Value_W == 0 THEN SET Auger1Enable,
								 RST Auger1DirOut, 
								 SET Auger2Enable,
								 RST Auger2DirOut
;
; Set parameter 171 to 1 to enable Auger 1 / 2 Selection Stage
;
IF TRUE && P171Value_W == 1 && Aux4LED THEN SET Auger1Enable,
											RST Auger1DirOut

IF TRUE && P171Value_W == 1 && !Aux4LED THEN SET Auger2Enable,
											 RST Auger2DirOut
     
IF DoAux5Key THEN (CAFWD_OFF_PD), RST AugerKeyStart_M	     
IF DoAux6Key THEN (CAREV_ON_PD)
IF M32 || M33 THEN (CA2_PD)

;The following lines prevents the auger while the job is running
;IF (M32 && CA2_PD) || (CAREV_ON_PD && !SV_PROGRAM_RUNNING) THEN JMP AugerRevStage
;IF (M33 && CA2_PD) || (CAFWD_OFF_PD && !SV_PROGRAM_RUNNING) || !EstopOk THEN JMP AugerOffStage

;The following lines allow the auger while the job is running
IF (M32 && CA2_PD) || (CAREV_ON_PD) THEN JMP AugerRevStage
IF (M33 && CA2_PD) || (CAFWD_OFF_PD) || !EstopOk THEN JMP AugerOffStage

;-------------------------------------------------------------------------------
    AugerRevStage
;-------------------------------------------------------------------------------

IF TRUE THEN SET Aux6LED,
			 RST Aux5LED
IF TRUE && P171Value_W == 0 THEN SET Auger1Enable,
								 SET Auger1DirOut, 
								 SET Auger2Enable,
								 SET Auger2DirOut
;
; Set parameter 171 to 1 to enable Auger 1 / 2 Selection Stage
;
IF TRUE && P171Value_W == 1 && Aux4LED THEN SET Auger1Enable,
											SET Auger1DirOut

IF TRUE && P171Value_W == 1 && !Aux4LED THEN SET Auger2Enable,
											 SET Auger2DirOut
	     
; Method 1
; Only enable Reverse direction when
; 1. Timer declared in the M32
; 2. When Auger_REV_Key is pressed
IF (!DoAux6Key && AugerKeyStart_M) THEN JMP AugerOffStage, RST AugerKeyStart_M

; Method 2
; Turn on Auger Reverse constantly until M31 or M33
IF DoAux5Key THEN (CAFWD_ON_PD)	     
IF DoAux6Key THEN (CAREV_OFF_PD)
IF (M33 || M31) THEN (CA3_PD)

;The following lines prevents the auger while the job is running
;IF (M31 && CA3_PD) || (CAFWD_ON_PD && !SV_PROGRAM_RUNNING) THEN JMP AugerFwdStage
;IF (M33 && CA3_PD) || (CAREV_OFF_PD && !SV_PROGRAM_RUNNING) || !EstopOk THEN JMP AugerOffStage

;The following lines allow the auger while the job is running
IF (M31 && CA3_PD) || (CAFWD_ON_PD ) THEN JMP AugerFwdStage
IF (M33 && CA3_PD) || (CAREV_OFF_PD) || !EstopOk THEN JMP AugerOffStage

;-------------------------------------------------------------------------------
     AugerSelectStage
;-------------------------------------------------------------------------------

; Auger 1 / Auger 2 Selection
; Uses the Aux4LED to signify the state
IF DoAux4Key THEN (AugerSelectPD)
IF (Aux4LED && AugerSelectPD && P171Value_W == 1) THEN RST Aux4LED 
IF (!Aux4LED && AugerSelectPD && P171Value_W == 1) THEN SET Aux4LED 

;-------------------------------------------------------------------------------
	DoorInterlockStage
;-------------------------------------------------------------------------------

; Set and reset Door Interlock Override
IF (!DoorClosed && ProbeDetect && Aux13Key && ATCOverrideKey) THEN SET DoorInterlock_Override_M
IF (DoorClosed || !ProbeDetect || !EstopOK) THEN RST DoorInterlock_Override_M

; If door open and not running a job, and not override then slow jog only:
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE && DoorInterlockMode_M && !DoorClosed && !DoorInterlock_Override_M) 
	THEN (DoorOpenSlowJog_M)

; If the door is opened while running a job and no override,
; then we cancel the job and give an error message:
IF ((SV_PROGRAM_RUNNING || SV_MDI_MODE) && !DoorClosed && !DoorInterlock_Override_M) 
	THEN ErrorCode_W = DOOR_OPEN_MESSAGE,
		 SET SetErrorStage, SET SV_STOP
	
; Control of door messages, and check for door locked:
IF ((SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorLockOut && !DoorClosed && !DoorInterlock_Override_M) 
	THEN SET DoorLockDelay_T,
		 ErrorCode_W = WAITING_FOR_DOOR_LOCKED,
		 SET FeedHoldLED

; Control the door lock solenoid output - when job running, door is locked
IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE && ZeroSpeed THEN RST DoorLockOut
IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorInterlockMode_M THEN SET DoorLockOut

; Reset the error timer if door is locked
IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorLocked THEN RST DoorLockDelay_T,
														  RST FeedHoldLED
IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE THEN RST DoorLockDelay_T

IF DoorLockDelay_T THEN SET FeedHoldLED,
						ErrorCode_W = DOOR_NOT_LOCKED,
						SET SV_STOP

;-------------------------------------------------------------------------------
   SetErrorStage
;-------------------------------------------------------------------------------

IF !((ErrorCode_W % 256 == 1) || (ErrorCode_W % 256 == 2)) THEN JMP BadErrorStage
IF TRUE THEN MSG ErrorCode_W
IF ErrorCode_W != MSG_CLEARED_MSG THEN MsgClear_T = 1000, SET MsgClear_T

IF (!EstopOk && !SoftwareReady_M) || ((ErrorCode_W != MSG_CLEARED_MSG) && (ErrorCode_W % 2 == 0) &&
  MsgClear_T) THEN ErrorCode_W = MSG_CLEARED_MSG, RST MsgClear_T

IF SV_STALL_ERROR THEN (Echo_Stall_M)
IF SV_STOP THEN (Echo_Stop_M)

IF SV_MASTER_ENABLE THEN (MasterEnable_M)
IF !SV_STOP THEN (NoFaultOut)

IF !EstopOk Then (DriveResetOut)
IF EstopOk Then SET SpindleFault_T

;-------------------------------------------------------------------------------
   BadErrorStage
;-------------------------------------------------------------------------------

IF TRUE THEN AsyncMsg_W = 2+256*100, MSG AsyncMsg_W, AsyncMsg_W = 0
IF TRUE THEN RST BadErrorStage
