;-------------------------------------------------------------------------------
; File:        allin1dc-lathe-8te.src
; Programmer:  Lee Johnston, Kai He
; Date:        9 December 2010
; Last Change: 16 December 2010 Used P178 to invert the status of ATC_Tool_lock
;              Corrected out 8: spindledirectionout
;              2011-JUL-25 (240) - added code for amber status light & corrected 
;                                  green light code.
;
; Purpose:     PLC for AllIn1DC + Add16/16 + 8 Tool Electric Turret
; Requires:    CNC11 v3.00 R83+
;
; $Id: gpio4d-lathe-basic.src 337 2010-06-08 18:13:16Z rscott $
;
;NOTE Changes to keyboard jogging bmp needed.  See MEM400+
;     "Invalid key" messages will need to be supressed

; Mpu11 based systems have the ability to invert, force and/or select a custom
; debounce time on PLC inputs 1-240 using SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64.
; Jog Panel inputs are modified in the same manner using SV_JOG_LINK_DEBOUNCE_1
; -SV_JOG_LINK_DEBOUNCE_64. See system variable section for more information.

; The Mpu11 board includes connections for several types of auxillary I/O.
; 4 digital "high speed" inputs (INP769-772) typically used for probe/TT1
; related functions,, 3 auxillary digital inputs (INP784-786), 11 Digital inputs
; used for MPG increment and axis selection and 2 auxillary digital outputs
; (Out770-771).

; GP4IOD Physical I/O: While each GPIO4D that is installed reserves (maps) 32
; inputs and 32 Outputs, only 20 inputs and 24 outputs are accessible through
; hardware.

; Inputs: The GPIO4D provides 20 inputs, 16 of which (1-16) are available for
; general purpose use.  Inputs 1-16 can be configured for 5, 12 or 24VDC
; operation in either a sourcing or sinking configuration.  Inputs 17-20 are a
; contact closure type input (input must be closed to the input common) which
; are generally reserved for drive fault inputs.  One of these inputs are found
; on each of the axis control headers (H11-H14) and are labeled as "Fault In"

; Outputs: The GPIO4D has 16 relay contact closure outputs.  Outputs 1-7, 10-16
; are SPST type relays while Outputs 8 && 9 are SPDT type relays.  Each
; mapped PLC output from 17-20 actually controls 2 Open Collector type outputs.
; The purpose of each of these paired outputs are to control an enable
; and brake output for each axis.  One pair of these outputs are found on each
; of the axis control headers (H11-H14) and are labeled as "Drive Enable" &
; "Brake Out"

; Analog outputs: The 12 bit 0-10VDC analog output on the GPIO4D is mapped to
; outputs 305-316.  NOTE: The spindle speed command that comes down from the PC
; (SV_PC_DAC_SPINDLE_SPEED) is a 16 bit integer value from 0-65535 that must be
; converted to a 12 bit value from 0-4095 by the PLC.  The PLC handles gear ranges
; by looking at the state of inputs and reading parameters (or hard coded values)
; to determine the ratio needed for adjusting the spindle speed display system
; variable

;----------------------------------------------------------------
;                        CONSTANT DEFINITIONS
;----------------------------------------------------------------

PLC_EXECUTOR_FLT_MSG    IS 257;(1+256)


AXIS1_INFLT 	        IS 1282;(2+256*5) Fiber to MPU11 from axis drive has a problem
AXIS2_INFLT 	        IS 1538;(2+256*6)
AXIS3_INFLT 	        IS 1794;(2+256*7)
AXIS4_INFLT 	        IS 2050;(2+256*8)
AXIS5_INFLT 	        IS 2306;(2+256*9)
AXIS6_INFLT 	        IS 2562;(2+256*10)
AXIS7_INFLT 	        IS 2818;(2+256*11)
AXIS8_INFLT 	        IS 3074;(2+256*12)

AXIS1_OUTFLT 	        IS 3330;(2+256*13) Fiber to axis drive from MPU11 has a problem
AXIS2_OUTFLT 	        IS 3586;(2+256*14)
AXIS3_OUTFLT 	        IS 3842;(2+256*15)
AXIS4_OUTFLT 	        IS 4098;(2+256*16)
AXIS5_OUTFLT 	        IS 4354;(2+256*17)
AXIS6_OUTFLT 	        IS 4610;(2+256*18)
AXIS7_OUTFLT 	        IS 4866;(2+256*19)
AXIS8_OUTFLT 	        IS 5122;(2+256*20)

AXIS_FLT_CLR 	        IS 5378;(2+256*21)

PLC_INFLT 	            IS 5634;(2+256*22)
PLC_OUTFLT 	            IS 5890;(2+256*23)
PLC_FLT_CLR 	        IS 6146;(2+256*24)


SPINDLE_FAULT           IS 7681;(1+256*30)
PLC_FAULT_MSG           IS 8449;(1+256*33)
PROBE_FAULT_MSG         IS 8705;(1+256*34)

KB_JOG_MSG              IS 8962;(2+256*35)


LUBE_FAULT_MSG          IS 9217;(1+256*36)
LUBE_WARNING_MSG        IS LUBE_FAULT_MSG+1
PROBE_JOG_FAULT_MSG     IS 9473;(1+256*37)

MIN_SPEED_MSG           IS 9730;(2+256*38)
SOFTWARE_EXIT_MSG       IS 9985;(1+256*39)
MSG_CLEARED_MSG         IS 25345;(1+256*99)

TOOL_CHANGE_CANCELLED   IS 25857;(1 + 256*101)
TURRET_LOCK_FAULT       IS 26113;(1 + 256*102)
TOOL_REQUEST_INVALID    IS 26369;(1 + 256*103)
ATC_TIMEOUT             IS 26625;(1 + 256*104)
TOOL_ENCODER_FAULT      IS 26881;(1 + 256*105)
TOOL_POSITION_FAULT     IS 27137;(1 + 256*106)
ATC_TURRET_NOT_LOCKED   IS 27393;(1 + 256*107)
PART_CATCH_OUT_FAULT    IS 27649;(1 + 256*108)
PART_CATCH_IN_FAULT     IS 27905;(1 + 256*109)
PART_CATCH_W_QUILL_IN   IS 28161;(1 + 256*110)
OD_CLAMP_ERROR          IS 28417;(1 + 256*111)
ID_CLAMP_ERROR          IS 28673;(1 + 256*112)
QUILL_IN_FAULT          IS 28929;(1 + 256*113)
QUILL_OUT_FAULT         IS 29185;(1 + 256*114)
CONVEYOR_JAMMED         IS 29441;(1 + 256*115)
DOOR_OPEN_W_JOB_RUN     IS 29697;(1 + 256*116)
CHUCK_NOT_READY         IS 29953;(1 + 256*117)
GEAR_CHANGE_TIME_OUT    IS 30209;(1 + 256*118)
GEAR_CH_NOT_IN_GEAR     IS 30465;(1 + 256*119)
GEAR_CH_SENSOR_FAULT    IS 30721;(1 + 256*120)
TOOL_POS_FAULT_ODD_TOOL IS 30977;(1 + 256*121)
CHUCK_SENSOR_ERROR      IS 31489;(1 + 256*123)


ID_CHUCK_MODE           IS 32514;(2 + 256*127)
OD_CHUCK_MODE           IS 32770;(2 + 256*128)
SELECT_AUTO_SPINDLE_MSG IS 33026;(2 + 256*129)

ATC_INITIALIZED         IS 50690;(2 + 256*198)

LIVE_TOOL_ZERO_RPM_DAC  IS 32768

;----------------------------------------------------------------
;                        INPUT DEFINITIONS
;               Closed = 1 (green)  Open = 0 (red)
;----------------------------------------------------------------
Ax1_MinusLimitOk   	  IS INP1
Ax1_PlusLimitOk    	  IS INP2
Ax2_MinusLimitOk      IS INP3
Ax2_PlusLimitOk       IS INP4
Z_Axis_Home           IS INP5
ChuckFootPedal        IS INP6
ID_OD_SW              IS INP7
ZeroSpeed             IS INP8
LubeOk                IS INP9  ;Lube is "ok" when input is closed
SpindleInverterOk     IS INP10 ;Inverter is "ok" when input is closed
EStopOk               IS INP11
Low_Gear_SW           IS INP12
MED_Gear_SW           IS INP13
High_Gear_SW          IS INP14
ChuckInSensor         IS INP15
ChuckOutSensor        IS INP16

;If a PLC expansion board (PLCADD1616) is used, the additional inputs will
;begin at input 17.

ATC_Tool_1            IS INP17   ;
ATC_Tool_2            IS INP18   ;
ATC_Tool_3            IS INP19   ;
ATC_Tool_4            IS INP20   ;
ATC_Tool_5 	          IS INP21   ;  
ATC_Tool_6            IS INP22   ;
ATC_Tool_7            IS INP23   ; 
ATC_Tool_8            IS INP24   ; 
ATC_Tool_Lock         IS INP25   ;
;spare                IS INP26   ;
SpindleChillerOk      IS INP27   ;
;spare                IS INP28   ;
DoorClosed              IS INP29   ;  
DoorLocked         	  IS INP30   ;
;spare                IS INP31   ; 
;spare                IS INP32   ; 

;----------------------------------------------------------------
; INP769 - INP784 encompass the MPU11 onboard input connections
; which are generally used for MPG and probing functions.
;----------------------------------------------------------------
MechnicalProbe    	 	IS INP769
DSPProbe           		IS INP770
ProbeDetect        		IS INP771
ProbeAux              IS INP772
MPG_Inc_X_1           IS INP773
MPG_Inc_X_10          IS INP774
MPG_Inc_X_100         IS INP775
MPG_AXIS_1            IS INP776
MPG_AXIS_2            IS INP777
MPG_AXIS_3            IS INP778
MPG_AXIS_4            IS INP779
MPG_AXIS_5            IS INP780
MPG_AXIS_6            IS INP781
MPG_AXIS_7            IS INP782
MPG_AXIS_8            IS INP783

;----------------------------------------------------------------
; Jog panel keys are referenced as JPI1 through JPI256. Alternatively,
; jog panel inputs can also be referenced as INP833-INP1088.
;----------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey       IS JPI1  ; Row  1 Column 1
SpinAutoManKey        IS JPI2  ; Row  1 Column 2
Aux1Key               IS JPI3  ; Row  1 Column 3
Aux2Key               IS JPI4  ; Row  1 Column 4
ToolIndexKey          IS JPI5  ; Row  1 Column 5

SpinOver100Key        IS JPI6  ; Row  2 Column 1
SpinCWKey             IS JPI7  ; Row  2 Column 2
TailInKey             IS JPI8  ; Row  2 Column 3
TailOutKey            IS JPI9  ; Row  2 Column 4
Aux6Key               IS JPI10 ; Row  2 Column 5

SpinOverMinusKey      IS JPI11 ; Row  3 Column 1
SpinCCWKey            IS JPI12 ; Row  3 Column 2
WorklightKey          IS JPI13 ; Row  3 Column 3
ChuckInKey            IS JPI14 ; Row  3 Column 4
ChuckOutKey           IS JPI15 ; Row  3 Column 5

SpinStopKey           IS JPI16 ; Row  4 Column 1
SpinStartKey          IS JPI17 ; Row  4 Column 2
UnusedR4C3Key         IS JPI18 ; Row  4 Column 3
UnusedR4C4Key         IS JPI19 ; Row  4 Column 4
UnusedR4C5Key         IS JPI20 ; Row  4 Column 5

CoolAutoManKey        IS JPI21 ; Row  5 Column 1
CoolFloodKey          IS JPI22 ; Row  5 Column 2
CoolMistKey           IS JPI23 ; Row  5 Column 3
Aux11Key              IS JPI24 ; Row  5 Column 4
ATCOverrideKey        IS JPI25 ; Row  5 Column 5

IncrContKey           IS JPI26  ; Row  6 Column 1
x1JogKey              IS JPI27  ; Row  6 Column 2
x10JogKey             IS JPI28  ; Row  6 Column 3
x100JogKey            IS JPI29  ; Row  6 Column 4
MPGKey                IS JPI30  ; Row  6 Column 5

Ax4PlusJogKey         IS JPI31  ; Row  7 Column 1
UnusedR7C2Key         IS JPI32  ; Row  7 Column 2
Ax2PlusJogKey         IS JPI33  ; Row  7 Column 3
UnusedR7C4Key         IS JPI34  ; Row  7 Column 4
Ax3PlusJogKey         IS JPI35  ; Row  7 Column 5

UnusedR8C1Key         IS JPI36  ; Row  8 Column 1
Ax1MinusJogKey        IS JPI37  ; Row  8 Column 2
FastSlowKey           IS JPI38  ; Row  8 Column 3
Ax1PlusJogKey         IS JPI39  ; Row  8 Column 4
UnusedR8C5Key         IS JPI40  ; Row  8 Column 5

Ax4MinusJogKey        IS JPI41  ; Row  9 Column 1
UnusedR9C2Key         IS JPI42  ; Row  9 Column 2
Ax2MinusJogKey        IS JPI43  ; Row  9 Column 3
UnusedR9C4Key         IS JPI44  ; Row  9 Column 4
Ax3MinusJogKey        IS JPI45  ; Row  9 Column 5

CycleCancelKey        IS JPI46  ; Row 10 Column 1
SingleBlockKey        IS JPI47  ; Row 10 Column 2
ToolCheckKey          IS JPI48  ; Row 10 Column 3
FeedHoldKey           IS JPI49  ; Row 10 Column 4
CycleStartKey         IS JPI50  ; Row 10 Column 5

;----------------------------------------------------------------
;                    Feedrate Override Knob
;----------------------------------------------------------------
JpFeedOrKnobBit0      IS JPI193
JpFeedOrKnobBit1      IS JPI194
JpFeedOrKnobBit2      IS JPI195
JpFeedOrKnobBit3      IS JPI196
JpFeedOrKnobBit4      IS JPI197
JpFeedOrKnobBit5      IS JPI198
JpFeedOrKnobBit6      IS JPI199
JpFeedOrKnobBit7      IS JPI200
JpFeedOrKnobBit8      IS JPI201 ; Current jog panels send first 8 bits
JpFeedOrKnobBit9      IS JPI202 ; unused
JpFeedOrKnobBit10     IS JPI203 ; unused
JpFeedOrKnobBit11     IS JPI204 ; unused
JpFeedOrKnobBit12     IS JPI205 ; unused
JpFeedOrKnobBit13     IS JPI206 ; unused
JpFeedOrKnobBit14     IS JPI207 ; unused
JpFeedOrKnobBit15     IS JPI208 ; unused


;----------------------------------------------------------------
;                 GPIO4D PLC Output Definitions
;       Logic 1 = OUTPUT ON (Green), 0 = OUTPUT OFF (Red)
;----------------------------------------------------------------
NoFaultOut            IS OUT1  ;SPST Type
Lube                  IS OUT2  ;SPST Type
Flood                 IS OUT3  ;SPST Type
Mist                  IS OUT4  ;SPST Type
InverterResetOut      IS OUT5  ;SPST Type
GearMotorEnableOut    IS OUT6  ;SPST Type
SpindleEnableOut      IS OUT7  ;SPST Type
SpindleDirectionOut   IS OUT8  ;SPDT Type
GearMotorDirectionOut IS OUT9  ;SPDT Type

;  NOTE: The GPIO4D features an internally controlled SPDT relay which is
;        physically located next to OUT16 on H2.  This output is not OUT17 ;        nor is it accessible via the PLC.  In the GPIO4D manual it is simply;        referred to as "fault" and is described as follows:;        "The fault output will remain closed as long as the GPIO4D does ;        not detect any serious errors, such as a loss of communication.";;        It is suggested that, when considering your Estop loop, you wire ;        this relay in series with a PLC controllable output such as OUT1,;        NoFaultOut.  Wiring in this manner will ensure that the Estop loop ;        will be disconnected when:;;        1. The operator presses the Estop switch.;        2. The PLC detects a stop fault condition.;        3. Communications are lost to the GPIO4D/PLC.
;        nor is it accessible via the PLC.  In the GPIO4D manual it is simply
;        referred to as "fault" and is described as follows:
;        "The fault output will remain closed as long as the GPIO4D does
;        not detect any serious errors, such as a loss of communication."
;
;        It is suggested that, when considering your Estop loop, you wire
;        this relay in series with a PLC controllable output such as OUT1,
;        NoFaultOut.  Wiring in this manner will ensure that the Estop loop
;        will be disconnected when:
;
;        1. The operator presses the Estop switch.
;        2. The PLC detects a stop fault condition.
;        3. Communications are lost to the GPIO4D/PLC.

; The open collector outputs will pull the signal they are connected to 0VDC
; when turned on.  The common (0V) of the signal your device accepts should ; be connected to the OUT COM of the respective enable/brake output listed ; below. Axis_1_Enable         IS OUT17 ;Controls TWO Open collector type outputs                               ;labeled "Enable Out" and "Brake Out" on H14 Axis_2_Enable         IS OUT18 ;Controls TWO Open collector type outputs                               ;labeled "Enable Out" and "Brake Out" on H13Axis_3_Enable         IS OUT19 ;Controls TWO Open collector type outputs                               ;labeled "Enable Out" and "Brake Out" on H12Axis_4_Enable         IS OUT20 ;Controls TWO Open collector type outputs                               ;labeled "Enable Out" and "Brake Out" on H11                                                                                                         ; These bits control the actual analog hardware output on the GPIO4D.; Output = 12bit (0-4095) 0-10VDC.
; be connected to the OUT COM of the respective enable/brake output listed
; below.

TailStockIN           IS OUT17 ;SPST Type
TailStockOUT          IS OUT18 ;SPST Type
ChuckInSolOut         IS OUT19 ;SPST Type
ChuckOutSolOut        IS OUT20 ;SPST Type
;spare                IS OUT21 ;SPST Type
;spare                IS OUT22 ;SPST Type
ATC_MotorEnableOut    IS OUT23 ;SPST Type
ATC_DirectionOut      IS OUT24 ;SPDT Type
ConveyerDirectionOut  IS OUT25 ;SPDT Type
ConveyerEnableOut     IS OUT26 ;SPST Type
DoorLockOut           IS OUT27 ;SPST Type
WorkLightOut          IS OUT28 ;SPST Type
SpindleChillerOut     IS OUT29 ;SPST Type
RedLightOut           IS OUT30 ;SPST Type
AmberLightOut         IS OUT31 ;SPST Type
GreenLightOut         IS OUT32 ;SPST Type
							   
; These bits control the actual analog hardware output on the ALLIN1DC.
; Output = 12bit (0-4095) 0-10VDC.
SpinAnalogOutBit0     IS OUT241
SpinAnalogOutBit1     IS OUT242
SpinAnalogOutBit2     IS OUT243
SpinAnalogOutBit3     IS OUT244
SpinAnalogOutBit4     IS OUT245
SpinAnalogOutBit5     IS OUT246
SpinAnalogOutBit6     IS OUT247
SpinAnalogOutBit7     IS OUT248
SpinAnalogOutBit8     IS OUT249
SpinAnalogOutBit9     IS OUT250
SpinAnalogOutBit10    IS OUT251
SpinAnalogOutBit11    IS OUT252

MPG_LED_OUT           IS OUT769

;----------------------------------------------------------------
;              Jog Panel Output (LED) Definitions
;       Jog Panel LED's can be addressed as JPO1 - JPO256
;                              OR
;                       OUT833 - OUT1088
;----------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right
;
SpinOverPlusLED       IS JPO1  ; Row  1 Column 1
SpinAutoModeLED       IS JPO2  ; Row  1 Column 2
Aux1LED               IS JPO3  ; Row  1 Column 3
Aux2LED               IS JPO4  ; Row  1 Column 4
Aux3LED               IS JPO5  ; Row  1 Column 5

SpinOver100LED        IS JPO6  ; Row  2 Column 1
SpindleCWLED          IS JPO7  ; Row  2 Column 2
Aux4LED               IS JPO8  ; Row  2 Column 3
Aux5LED               IS JPO9  ; Row  2 Column 4
Aux6LED               IS JPO10 ; Row  2 Column 5

SpinOverMinusLED      IS JPO11 ; Row  3 Column 1
SpindleCCWLED         IS JPO12 ; Row  3 Column 2
WorklightLED          IS JPO13 ; Row  3 Column 3
ChuckInLED            IS JPO14 ; Row  3 Column 4
ChuckOutLED           IS JPO15 ; Row  3 Column 5

SpinStopLED           IS JPO16 ; Row  4 Column 1
SpinStartLED          IS JPO17 ; Row  4 Column 2
UnusedR4C3LED         IS JPO18 ; Row  4 Column 3
UnusedR4C4LED         IS JPO19 ; Row  4 Column 4
UnusedR4C5LED         IS JPO20 ; Row  4 Column 5

CoolAutoManLED        IS JPO21 ; Row  5 Column 1
CoolFloodLED          IS JPO22 ; Row  5 Column 2
CoolMistLED           IS JPO23 ; Row  5 Column 3
Aux11LED              IS JPO24 ; Row  5 Column 4
UnusedR5C5LED         IS JPO25 ; Row  5 Column 5

IncrContLED           IS JPO26  ; Row  6 Column 1
x1JogLED              IS JPO27  ; Row  6 Column 2
x10JogLED             IS JPO28  ; Row  6 Column 3
x100JogLED            IS JPO29  ; Row  6 Column 4
MPGLED                IS JPO30  ; Row  6 Column 5

Ax4PlusJogLED         IS JPO31  ; Row  7 Column 1
UnusedR7C2LED         IS JPO32  ; Row  7 Column 2
Ax2PlusJogLED         IS JPO33  ; Row  7 Column 3
UnusedR7C4LED         IS JPO34  ; Row  7 Column 4
Ax3PlusJogLED         IS JPO35  ; Row  7 Column 5

UnusedR8C1LED         IS JPO36  ; Row  8 Column 1
Ax1MinusJogLED        IS JPO37  ; Row  8 Column 2
FastSlowLED           IS JPO38  ; Row  8 Column 3
Ax1PlusJogLED         IS JPO39  ; Row  8 Column 4
UnusedR8C5LED         IS JPO40  ; Row  8 Column 5

Ax4MinusJogLED        IS JPO41  ; Row  9 Column 1
UnusedR9C2LED         IS JPO42  ; Row  9 Column 2
Ax2MinusJogLED        IS JPO43  ; Row  9 Column 3
UnusedR9C4LED         IS JPO44  ; Row  9 Column 4
Ax3MinusJogLED        IS JPO45  ; Row  9 Column 5

CycleCancelLED        IS JPO46  ; Row 10 Column 1
SingleBlockLED        IS JPO47  ; Row 10 Column 2

; FOR JOGBRD REV??????, the LED outputs do not match Key inputs
; The PLC program should activate all three of these when
; it wants to turn on FeedHoldLED so that future hardware changes
; to put them in the same order as their corresponding inputs will work.
ToolCheckLED          IS JPO50  ; Row 10 Column 3
FeedHoldLED           IS JPO48  ; Row 10 Column 4
CycleStartLED         IS JPO49  ; Row 10 Column 5


;----------------------------------------------------------------
;                        Memory Bit Definitions
;----------------------------------------------------------------
PLCExecutorFault_M   IS MEM1
SoftwareReady_M      IS MEM2
MPGManOffFlag_M      IS MEM3
;                    IS MEM4
MasterEnable_M       IS MEM5
DriveComFltIn_M      IS MEM6
DriveComFltOut_M     IS MEM7
PLCBus_Oe_M          IS MEM8
ErrClr_M             IS MEM9
PLCBus_Online_M      IS MEM10
Ax1PlusJogDisabled_M  IS MEM11
Ax1MinusJogDisabled_M IS MEM12
Ax2PlusJogDisabled_M  IS MEM13
Ax2MinusJogDisabled_M IS MEM14

SV_STALL_M              IS MEM15
SV_MASTER_EN_M          IS MEM16
Echo_Stall_M            IS MEM17
Echo_Stop_M             IS MEM18
ToolChangeDone_M        IS MEM20

ChuckPOS_M	         IS MEM21   ; GRN=IN, RED=OUT	
M18REQ_M		     IS MEM22   ;
ChuckNotReady_M	     IS MEM23
ChuckCheck_M	     IS MEM24   ; For ID/OD switch, overrides the error message
DoorCheck_M          IS MEM25	; 
ChuckReady_M         IS MEM26 	; GRN = OK, RED = not ready 
ID_MODE_M            IS MEM27   ; 
OD_MODE_M            IS MEM28   ; 
ChuckMSG_M	         IS MEM29	 ; Chuck not Ready
DoingIndex_M         IS MEM30 
Doing_M6             IS MEM31  ; 
CalcB1_M             IS MEM32 
CalcB2_M             IS MEM33 
DoorFaultOut_M       IS MEM34
;EndReq_M             IS MEM35
ChuckInMode_M        IS MEM36
ChuckOutMode_M       IS MEM37
ChuckFootReq_M       IS MEM38

ATCRotateReq_M       IS MEM40

ChuckInSensorMEM     IS MEM41
ChuckOutSensorMEM    IS MEM42

M32Mem               IS MEM43
M33Mem               IS MEM44

ATCOverride_M        IS MEM48
LubeFault_M          IS MEM49
PLCFault_M	         IS MEM50
AxisFault_M          IS MEM51
PLCBusExtDevEn_M     IS MEM52
ProbeFault_M         IS MEM53
JogProbeFault_M      IS MEM54
Spindle_Fault_M      IS MEM55
KbJpActive_M         IS MEM60 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
Axis1FiberOk_M       IS MEM70
Axis2FiberOk_M       IS MEM71
Axis3FiberOk_M       IS MEM72
Axis4FiberOk_M       IS MEM73
Axis5FiberOk_M       IS MEM74
Axis6FiberOk_M       IS MEM75
Axis7FiberOk_M       IS MEM76
Axis8FiberOk_M       IS MEM77
ProbeMsgSent_M       IS MEM78
InvertXJogKeys_M     IS MEM79 ; SV_MACHINE_PARAMETER_1 bit 1
SwapAxes_M           IS MEM80 ; SV_MACHINE_PARAMETER_1 bit 2
true                 IS MEM81
SpinLowRange_M       IS MEM82
SpinMedLowRange_M    IS MEM83
SpinMedHighRange_M   IS MEM84
SpinHighRange_M      IS MEM85
SpindlePause_M       IS MEM86

DisableKbInput_M      IS MEM102 ;If 1, disable kb jogging
AllowKbInput_M        IS MEM103 ;If 1, allow kb jogging
JogOverOnly_M         IS MEM105
KbOverOnly_M          IS MEM106
UsingFeedrateKnob_M   IS MEM117
WaitingForSleepTimer_M IS MEM118
X1_M                 IS MEM119
X10_M                IS MEM120
X100_M               IS MEM121

;------
OnAtPowerUp          IS MEM200
InvLubeOk_M          IS MEM300  ; P178 Bit 0  (1)
InvSpinInverterOk_M  IS MEM301  ; P178 Bit 1  (2)
AirSignalNONC        IS MEM302  ; P178 Bit 2  (4)
ToolCounterNONC      IS MEM303  ; P178 Bit 3  (8)
ServoFaultNONC       IS MEM304  ; P178 Bit 4  (16)
ZeroSpeedNONC        IS MEM305  ; P178 Bit 5  (32)
OrientCompleteNONC   IS MEM306  ; P178 Bit 6  (64)
ReverseChuckNONC     IS MEM307  ; P178 Bit 7  (128)
ReverseClamp         IS MEM308  ; P178 Bit 8  (256)
SpinRangeNONC        IS MEM309  ; P178 Bit 9  (512)
ChillerFaultNONC     IS MEM310  ; P178 Bit 10 (1024)
DoorSWNONC           IS MEM311  ; P178 Bit 11 (2048)
ToolThruNONC         IS MEM312  ; P178 Bit 12 (4096)
ToolLockNONC         IS MEM313  ; P178 Bit 13 (8192)
;uP178Bit14          IS MEM314  ; P178 Bit 14 (16384)
DoorSWONOFF          IS MEM315  ; P178 Bit 15 (32768)

KbCycleStart_M       IS MEM400 ; "alt" + "s"
KbCycleCancel_M      IS MEM401 ; escape
KbToolCheck_M        IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M   IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M   IS MEM404 ; "Insert"
KbDecreaseJogInc_M   IS MEM405 ; "Delete"
KbIncFeedOver_M      IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M      IS MEM407 ; "ctrl" + "keyboard "-"
KbFeedOver100_M      IS MEM450 ; "ctrl" + "\"
KbTogIncContJog_M    IS MEM408 ; "ctrl" + "i"
KbTogFastSlowJog_M   IS MEM409 ; "ctrl" + "f"
KbJogAx1Plus_M       IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M      IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M       IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M      IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M       IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M      IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M       IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M      IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M          IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M          IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M          IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M          IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M          IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M          IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M          IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M          IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M          IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M         IS MEM428 ; "ctrl" + "F10"
KbAux11Key_M         IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M         IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M     IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M   IS MEM432 ; "ctrl" + "a"
KbSpinCW_M           IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M          IS MEM434 ; "ctrl" + "w"
KbSpinStart_M        IS MEM435 ; "ctrl" + "s"
KbSpinStop_M         IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M       IS MEM437 ; "ctrl" + "n"
KbMistOnOff_M        IS MEM451 ; "ctrl" + "k"
KbTogCoolAutoMan_M   IS MEM438 ; "ctrl" + "m"
KbFeedHold_M         IS MEM439 ; space bar
KbIncSpinOver_M      IS MEM440 ; "ctrl" + ">" (.)
KbDecSpinOver_M      IS MEM441 ; "ctrl" + "<" (,)
KbSpinOver100_M      IS MEM442 ; "ctrl" + "?" (/)

;-------------------------------------------------------------------------------
;                     ---------SYSTEM VARIABLES--------
;
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;-------------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional reponsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibilty of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel keypress to a specific function.  Pressing a jog key or Aux key
; won't DO anything unless the PLC assigns an action to the keypress.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                                 ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape keypress event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the keypress is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "set" KbCycleCancel_M anytime the escape key is pressed.
;    if Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancle key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_1 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_1 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Keypress: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times------------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 32-17 (Selection 0)
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                    Debounce Time Selection #1
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                      Debounce Time Selection #3
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the charactersitics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 && INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is set as follows:

; Five new operators have been introduced to simplify bit operations:
; BitSet, BitRst, BitTst, LShift && Rshift.  Below we will use bitset to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; bitset and bitrst can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use bitset and
; bitrst to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; Inputs_9_12_W IS W1
; use bitst or bitrst
; if 1 == 1 THEN bitset Inputs_9_12_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; if 1 == 1 THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp1 = bits 31-24        Inp2 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp3 = bits 15-8       Inp4 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Ivert (bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, set the both invert AND force bits
;   for the input.

;-------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/set in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.
;-------------------------------------------------------------------------------


;----------------------------------------------------------------
;  System variables:  Jog Panel Functions
;----------------------------------------------------------------
; Jog panel functions
;Invalid              IS SV_PLC_FUNCTION_0
DoCycleCancel         IS SV_PLC_FUNCTION_1
DoCycleStart          IS SV_PLC_FUNCTION_2
DoToolCheck           IS SV_PLC_FUNCTION_3
SelectSingleBlock     IS SV_PLC_FUNCTION_4
SelectX1JogInc        IS SV_PLC_FUNCTION_5
SelectX10JogInc       IS SV_PLC_FUNCTION_6
SelectX100JogInc      IS SV_PLC_FUNCTION_7
SelectUserJogInc      IS SV_PLC_FUNCTION_8
SelectIncContJog      IS SV_PLC_FUNCTION_9
SelectFastSlowJog     IS SV_PLC_FUNCTION_10
SelectMpgMode         IS SV_PLC_FUNCTION_11
DoAx1PlusJog          IS SV_PLC_FUNCTION_12
DoAx1MinusJog         IS SV_PLC_FUNCTION_13
DoAx2PlusJog          IS SV_PLC_FUNCTION_14
DoAx2MinusJog         IS SV_PLC_FUNCTION_15
DoAx3PlusJog          IS SV_PLC_FUNCTION_16
DoAx3MinusJog         IS SV_PLC_FUNCTION_17
DoAx4PlusJog          IS SV_PLC_FUNCTION_18
DoAx4MinusJog         IS SV_PLC_FUNCTION_19
DoAx5PlusJog          IS SV_PLC_FUNCTION_20
DoAx5MinusJog         IS SV_PLC_FUNCTION_21
DoAx6PlusJog          IS SV_PLC_FUNCTION_22
DoAx6MinusJog         IS SV_PLC_FUNCTION_23
DoAux1Key             IS SV_PLC_FUNCTION_24
DoAux2Key             IS SV_PLC_FUNCTION_25
DoAux3Key             IS SV_PLC_FUNCTION_26
DoAux4Key             IS SV_PLC_FUNCTION_27
DoAux5Key             IS SV_PLC_FUNCTION_28
DoAux6Key             IS SV_PLC_FUNCTION_29
DoAux7Key             IS SV_PLC_FUNCTION_30
DoAux8Key             IS SV_PLC_FUNCTION_31
DoAux9Key             IS SV_PLC_FUNCTION_32
DoAux10Key            IS SV_PLC_FUNCTION_33
SelectRapidOverride   IS SV_PLC_FUNCTION_34
SelectManAutoSpindle  IS SV_PLC_FUNCTION_35
DoSpindleStart        IS SV_PLC_FUNCTION_37
DoSpindleStop         IS SV_PLC_FUNCTION_38
DoAux11Key            IS SV_PLC_FUNCTION_39
DoAux12Key            IS SV_PLC_FUNCTION_40
;SelectCoolantMan     IS SV_PLC_FUNCTION_41 ;deprecated
;SelectCoolantAuto    IS SV_PLC_FUNCTION_42 ;deprecated
SelectCoolantFlood    IS SV_PLC_FUNCTION_43
SelectCoolantMist     IS SV_PLC_FUNCTION_44
DoFeedHold            IS SV_PLC_FUNCTION_45
SelectSpindleCCW      IS SV_PLC_FUNCTION_98
SelectSpindleCW       IS SV_PLC_FUNCTION_99
SelectCoolAutoMan     is SV_PLC_FUNCTION_104
DoIncreaseSpindleOr   IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOr   IS SV_PLC_FUNCTION_107
SelectSpinOr100       IS SV_PLC_FUNCTION_108

;----------------------------------------------------------------
;  System variables:  Keyboard jogging functions
;----------------------------------------------------------------
;-------------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard keypress has occured.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Keypresses are sent down as individual keys.  It is the resposibility of
; the PLC programmer to insure that a keypress is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a keypress form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......


;-------------------------------------------------------------------------------
Kb_a					            IS SV_PC_KEYBOARD_KEY_60
Kb_b					            IS SV_PC_KEYBOARD_KEY_79
Kb_c					            IS SV_PC_KEYBOARD_KEY_77
Kb_d					            IS SV_PC_KEYBOARD_KEY_62
Kb_e					            IS SV_PC_KEYBOARD_KEY_41
Kb_f					            IS SV_PC_KEYBOARD_KEY_63
Kb_g					            IS SV_PC_KEYBOARD_KEY_64
Kb_h					            IS SV_PC_KEYBOARD_KEY_65
Kb_i					            IS SV_PC_KEYBOARD_KEY_46
Kb_j					            IS SV_PC_KEYBOARD_KEY_66
Kb_k					            IS SV_PC_KEYBOARD_KEY_67
Kb_l					            IS SV_PC_KEYBOARD_KEY_68
Kb_m					            IS SV_PC_KEYBOARD_KEY_81
Kb_n					            IS SV_PC_KEYBOARD_KEY_80
Kb_o					            IS SV_PC_KEYBOARD_KEY_47
Kb_p					            IS SV_PC_KEYBOARD_KEY_48
Kb_q					            IS SV_PC_KEYBOARD_KEY_39
Kb_r					            IS SV_PC_KEYBOARD_KEY_42
Kb_s					            IS SV_PC_KEYBOARD_KEY_61
Kb_t					            IS SV_PC_KEYBOARD_KEY_43
Kb_u					            IS SV_PC_KEYBOARD_KEY_45
Kb_v					            IS SV_PC_KEYBOARD_KEY_78
Kb_w					            IS SV_PC_KEYBOARD_KEY_40
Kb_x					            IS SV_PC_KEYBOARD_KEY_76
Kb_y					            IS SV_PC_KEYBOARD_KEY_44
Kb_z					            IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar               IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift 	              IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift 	              IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt			            IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt			            IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl		              IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl		              IS SV_PC_KEYBOARD_KEY_99
Kb_Ins				            IS SV_PC_KEYBOARD_KEY_31
Kb_Home				            IS SV_PC_KEYBOARD_KEY_32
Kb_End                    IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown			            IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp				            IS SV_PC_KEYBOARD_KEY_33
Kb_Del				            IS SV_PC_KEYBOARD_KEY_52
Kb_Back				            IS SV_PC_KEYBOARD_KEY_30
Kb_Tab		  	            IS SV_PC_KEYBOARD_KEY_38
Kb_Up					            IS SV_PC_KEYBOARD_KEY_87
Kb_Down				            IS SV_PC_KEYBOARD_KEY_101
Kb_Left				            IS SV_PC_KEYBOARD_KEY_100
Kb_Right			            IS SV_PC_KEYBOARD_KEY_102
Kb_Escape 		            IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1					            IS SV_PC_KEYBOARD_KEY_2
Kb_F2					            IS SV_PC_KEYBOARD_KEY_3
Kb_F3					            IS SV_PC_KEYBOARD_KEY_4
Kb_F4					            IS SV_PC_KEYBOARD_KEY_5
Kb_F5					            IS SV_PC_KEYBOARD_KEY_6
Kb_F6					            IS SV_PC_KEYBOARD_KEY_7
Kb_F7					            IS SV_PC_KEYBOARD_KEY_8
Kb_F8					            IS SV_PC_KEYBOARD_KEY_9
Kb_F9					            IS SV_PC_KEYBOARD_KEY_10
Kb_F10				            IS SV_PC_KEYBOARD_KEY_11
Kb_F11				            IS SV_PC_KEYBOARD_KEY_12
Kb_F12				            IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn		            IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck 	            IS SV_PC_KEYBOARD_KEY_15
Kb_Break			            IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock		            IS SV_PC_KEYBOARD_KEY_34
Kb_1                      IS SV_PC_KEYBOARD_KEY_18
Kb_2                      IS SV_PC_KEYBOARD_KEY_19
Kb_3                      IS SV_PC_KEYBOARD_KEY_20
Kb_4                      IS SV_PC_KEYBOARD_KEY_21
Kb_5                      IS SV_PC_KEYBOARD_KEY_22
Kb_6                      IS SV_PC_KEYBOARD_KEY_23
Kb_7                      IS SV_PC_KEYBOARD_KEY_24
Kb_8                      IS SV_PC_KEYBOARD_KEY_25
Kb_9                      IS SV_PC_KEYBOARD_KEY_26
Kb_0                      IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div	            IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt	            IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub	            IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0		            IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1		            IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2		            IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3		            IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4		            IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5		            IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6								IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7								IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8								IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9								IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt  				IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus		 				IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter			 				IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket						IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket						IS SV_PC_KEYBOARD_KEY_50
Kb_Hypen				    			IS SV_PC_KEYBOARD_KEY_28
Kb_Equals				  				IS SV_PC_KEYBOARD_KEY_29
Kb_Comma				    			IS SV_PC_KEYBOARD_KEY_82
Kb_Period				  				IS SV_PC_KEYBOARD_KEY_83
Kb_Slash        				  IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash        		  IS SV_PC_KEYBOARD_KEY_86
;----------------------------------------------------------------
; M functions - The System Variables in this section inform the
; PLC that an M function has been requested.
;----------------------------------------------------------------
M3                      IS SV_M94_M95_1 ;(Spindle CW)
M4                      IS SV_M94_M95_2 ;(Spindle CCW)
M8                      IS SV_M94_M95_3 ;(Flood On)
M10                     IS SV_M94_M95_4 ;(Chuck Unclamp) 
M7                      IS SV_M94_M95_5 ;(Mist)
M6                      IS SV_M94_M95_6 ;(ToolChange)
M11                     IS SV_M94_M95_7 ;(Chuck Clamp)
M18                     IS SV_M94_M95_8 ;
Gear_FWD                IS SV_M94_M95_9 ;
Gear_REV                IS SV_M94_M95_10;
Gear_Change_Req         IS SV_M94_M95_11; 
M32                     IS SV_M94_M95_12; 
M33                     IS SV_M94_M95_13; 
M14                     IS SV_M94_M95_14; Turret Down
M15                     IS SV_M94_M95_15; Turret Up
M13                     IS SV_M94_M95_16; Rotate Turret


;----------------------------------------------------------------
;                     Word Definitions (int32)
;----------------------------------------------------------------

BinPosition_W           IS W1 
MaxBins_W               IS W2 
Temp_W                  IS W3
WantedBin_W             IS W4 
MotorDir_W              IS W5      ; 1 = CW, -1 = CCW 
Distance_W              IS W6

ErrorCode_W             IS W7
TwelveBitSpeed_W        IS W8
LubeAccumTime_W         IS W9
KbOverride_W            IS W10
FeedrateKnob_W          IS W11
CycloneStatus_W         IS W12
FinalFeedOverride_W     IS W13
SixteenBitSpeed_W       IS W14
SPindleDACEcho          IS W15
Last_FeedrateKnob_W     IS W16
AsyncMsg_W              IS W17
P148Value_W             IS W18
P1Value_W               IS W19
Lube_W                  IS W20
LubeM_W                 IS W22
LubeS_W                 IS W23
PLC_Fault_W             IS W24
PLCFaultAddr_W          IS W25
Inputs_9_12_W           IS W28
P6Value_W               IS W29
P170Value_W             IS W30
P178Value_W             IS W31
SpinSpeedCommand_W      IS W32

P176Value_W             IS W33 ; Max LiveTool Speed
P177Value_W             IS W34 ; Programmed Live Tool Speed
LiveToolSpeed_W         IS W35 ; Programmed output 
LiveRpmPerBit_W         IS W36 ; Live tool rpm per bit

;----------------------------------------
;           Word Definitions cont. (f32)
;----------------------------------------
SpinRangeAdjust         IS FW1
RPMPerBit_FW            IS FW2
CfgMinSpeed_FW          IS FW3
CfgMaxSpeed_FW          IS FW4
TwelveBitSpeed_FW       IS FW5
SixteenBitSpeed_FW      IS FW6
LiveToolRPMPerBit_FW    IS FW7
LiveToolSixteenBitSpeed_FW IS FW8
SixteenBitRPMPerBit_FW  IS FW9
Temp_FW                 IS FW10

;------------------------------------
;            One Shot Definitions
;------------------------------------
IncrContPD              IS PD1
SlowFastPD              IS PD2
MpgPD                   IS PD3
SingleBlockPD           IS PD4
FeedHoldPD              IS PD5
SpinAutoManPD           IS PD6
SpindlePlusPD           IS PD7
SpinOverMinusPD         IS PD8
SpinOver100PD           IS PD9
SpinStartPD             IS PD10
SpinStopPD              IS PD11
SpinCWPD                IS PD12
SpinCCWPD               IS PD13
F9PD                    IS PD14
x1JogPD                 IS PD15
x10JogPD                IS PD16
x100JogPD               IS PD17
Aux11KeyPD              IS PD18
RapidOverPD             IS PD19
CoolantAutoManualPD     IS PD21
CoolantFloodPD          IS PD22
CoolantMistPD           IS PD23
ToolCheckPD             IS PD24
JogProbeFaultPD         IS PD25
RigidTapPD              IS PD26
WorklightPD             IS PD27
PCSpindleStartStopPD    IS PD30
PCSpindleManualPD       IS PD31
PCSpindleCWPD           IS PD32
PCSpindleCCWPD          IS PD33
StopRunning_PD          IS PD35
SoftwareReadyPD         IS PD36

M6PD                    IS PD37
TSPD                    IS PD38
WLPD                    IS PD39
M18PD                   IS PD40
ChuckPD                 IS PD41
ODPD                	IS PD42 
IDPD	                IS PD43
M10PD                   IS PD44
M11PD                   IS PD45

Aux8KeyPD               IS PD46
Aux9KeyPD               IS PD47
Chuck2PD                IS PD48

M32PD	                IS PD50
M33PD                	IS PD51

M13PD                   IS PD53
M14PD                   IS PD54
M15PD                   IS PD55
ATCRotateReqPD          IS PD56
ATCRotatePD             IS PD57

;---------------------------------------------------------------
;                    Timer Definitions
;----------------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T	             IS T1
SleepTimer               IS T2
CycloneStatusTimer       IS T3
InitializeTimer          IS T4
InitialStage_T           IS T5
LubeM_T                  IS T13
LubeS_T                  IS T14
ATC_DELAY_STAGE_T        IS T15
CC_T                     IS T17  
CU_T                     IS T18 
TEF_T                    IS T19  ; Tool Encode Fault 
ClampError_T            IS T20  ; 2 second Timer for Chuck clamp errors.  
Clamp_Error_T1           IS T21  ; 2 second Timer for Chuck clamp errors.  
Tool_Check_T  	         IS T22  ; Time Delay that allows M code to run b4 door open is tripped. 
Home_T		         IS T23
Door_T		         IS T24
M18_T		         IS T25
ChuckFootSwitch_T             IS T26  ; Min time for foot switch to toggle
FootSwitchCount_T        IS T27  ; Elapsed time of footswitch press
GearChangeTimer_T    IS T28
TailOut_T            IS T29
AtcDirRev_T          IS T30; ATC direction Reverse Timer
RotateMax_T          IS T31
CWCCWDelay_T         IS T32
Reverse_T            IS T33

;----------------------------------------------------------------
;                       Stage Definitions
;----------------------------------------------------------------
WatchDogStage           IS STG1
InitialStage            IS STG2
JOG_PANEL               IS STG3
MainStage               IS STG4
AxesEnableStage         IS STG5
SpindleStage            IS STG6
MPG_Stage               IS STG7
CheckCycloneStatusStage      IS STG8
LoadCNC11Parameters     IS STG9
KeyboardEvents          IS STG10
AxesReconfigured        IS STG11
LubeUsePumpTimers       IS STG13
LubeUsePLCTimers        IS STG14

ATC_MAIN_STAGE          IS STG17
CHUCK_IN_STAGE		    IS STG18
CHUCK_OUT_STAGE		    IS STG19
ATC_START_STAGE         IS STG20 
ATC_ROTATE_TO_TOOL_STAGE  IS STG21 
ATC_CLAMP_OFF_STAGE    	IS STG23 
ATC_ROTATE_STAGE  	    IS STG24
ATC_WAIT_POSITION_STAGE IS STG25 
ATC_CLAMP_ON_STAGE      IS STG26 
ATC_STOP_STAGE   	    IS STG27 
ATC_DONE                IS STG28
ATC_REVERSE_MOTOR       IS STG29
TailStockStage          IS STG30 
TailOutTimerStage       IS STG31
ATC_FINISHED_STAGE      IS STG32 

DoToolIndexStage        IS STG40 

SetErrorStage           IS STG50
BadErrorStage   	    IS STG51

;M18_UnclampStage        IS STG60
;M18_RotateStage         IS STG61
;M18_ClampStage          IS STG62
;M18_SetStage            IS STG63

;----------------------------------------------------------------
;                         Program Start
;----------------------------------------------------------------
;----------------------------------------------------------------

                          WatchDogStage
;----------------------------------------------------------------

; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
if SV_PLC_FAULT_STATUS != 0 THEN
  PLC_Fault_W    = SV_PLC_FAULT_STATUS,
  PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
  ErrorCode_W    = PLC_EXECUTOR_FLT_MSG, MSG ErrorCode_W,
  SET PLCExecutorFault_M, RST SetErrorStage, SET SV_STOP

; Handle software exit.
if !SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN
  SET SoftwareReady_M,
  SET SV_STOP,
  ErrorCode_W = SOFTWARE_EXIT_MSG

if SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN (SoftwareReadyPD)
if SoftwareReadyPD && !SoftwareReady_M || !true THEN SET InitialStage

if SoftwareReadyPD && SoftwareReady_M THEN RST SoftwareReady_M

;----------------------------------------------------------------
                          InitialStage
;----------------------------------------------------------------
;IF !true THEN InitialStage_T = 1000;
;IF !true THEN SET InitialStage_T;
IF 1==1 THEN SET true,
             SET OnAtPowerUp,
             SET AxesEnableStage,
             SET MainStage,
             SET JOG_PANEL,
             SET LoadCNC11Parameters,
             SET MPG_Stage,
             SET PLCBus_Oe_M,
			 RST DriveComFltIn_M,
             RST DriveComFltOut_M,
             SET ErrClr_M,
             RST PLCFault_M,
             CycloneStatusTimer = 300,
             ErrorCode_W = MSG_CLEARED_MSG,
             RST BadErrorStage,
             SET SetErrorStage,
             InitializeTimer = 1000, set InitializeTimer,
	     ;SET ATC_Main_Stage, 
             ATC_DELAY_STAGE_T = 140, 
	     ;BinPosition_W = SV_MACHINE_PARAMETER_175,
             ;WantedBin_W = BinPosition_W,
             CC_T  = 4000,    ; max time for chuck clamp signals to be seen 
             CU_T  = 4000,    ; max time for chuck unclamp signals to be seen 
             ChuckFootSwitch_T = 4000, ;min time the footpedal has to be seen to toggle states
	     ;FootSwitchCount_T = 0,
	     TEF_T = 1,    ; max time before reporting tool encoder fault. 
	     ClampError_T  = 2000, 
	     Clamp_Error_T1 = 2000, 
     	     Tool_Check_T   = 1000,
	     ;M18_T = 500, 
	     ;WantedBin_W = 1,
	     ;BinPosition_W = 1,
	     ;P176Value_W = 1,
	     TailOut_T = 15000,
		 GearChangeTimer_T = 20000,
		 AtcDirRev_T=100,         
         RotateMax_T=5000,       
         CWCCWDelay_T=50,
         Reverse_T=500,
		 SET TailStockStage
	      
;IF InitialStage_T THEN RST InitialStage, RST InitialStage_T

IF !ChuckOutSensorMEM && !ID_OD_SW THEN SET ChuckInMode_M, RST ChuckOutMode_M, SET ChuckInLED 
IF ChuckOutSensorMEM && !ID_OD_SW THEN SET ChuckOutMode_M, RST ChuckInMode_M, SET ChuckOutLED
   
IF ChuckInSensorMEM && ID_OD_SW THEN SET ChuckInMode_M, RST ChuckOutMode_M, SET ChuckInLED
IF !ChuckInSensorMEM && ID_OD_SW THEN SET ChuckOutMode_M, RST ChuckInMode_M, SET ChuckOutLED

if 1==1 THEN P6Value_W = SV_MACHINE_PARAMETER_6
IF (P6Value_W == 1) THEN SET ATC_Main_Stage
		
IF (P6Value_W == 0) THEN RST ATC_Main_Stage

IF true THEN RST InitialStage

;----------------------------------------------------------------
                      LoadCNC11Parameters
;----------------------------------------------------------------
; There are two methods of control for the lube pump and they are set by CNC11
; Machine Parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled soley by PLC).
;
; Load lube pump times from P179 and convert to milliseconds.
IF true THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000

; Set the apprpriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimers, RST LubeUsePLCTimers
IF LubeS_W != 0 THEN SET LubeUsePLCTimers, RST LubeUsePumpTimers

if true THEN P148Value_W = SV_MACHINE_PARAMETER_148,
             P170Value_W = SV_MACHINE_PARAMETER_170,
             P178Value_W = SV_MACHINE_PARAMETER_178,
	     P176Value_W = SV_MACHINE_PARAMETER_176,
	     P177Value_W = SV_MACHINE_PARAMETER_177

If true THEN BitTst P148Value_W 1 DisableKbInput_M
if true && !DisableKbInput_M THEN BitTst P170Value_W 0 AllowKbInput_M
If true THEN BitTst P170Value_W 1 JogOverOnly_M
If true THEN BitTst P170Value_W 2 KbOverOnly_M
if JogOverOnly_M && KbOverOnly_M THEN rst KbOverOnly_M

If true THEN BitTst P178Value_W 0 InvLubeOk_M
If true THEN BitTst P178Value_W 1 InvSpinInverterOk_M
IF true THEN BitTst P178Value_W 2 AirSignalNONC
IF true THEN BitTst P178Value_W 3 ToolCounterNONC
IF true THEN BitTst P178Value_W 5 ZeroSpeedNONC
IF true THEN BitTst P178Value_W 6 OrientCompleteNONC
IF true THEN BitTst P178Value_W 7 ReverseChuckNONC

IF true THEN BitTst P178Value_W 13 ToolLockNONC

IF true THEN BitTst P178Value_W 15 DoorSWONOFF

IF true THEN MaxBins_W = SV_MACHINE_PARAMETER_161

IF (ChuckInSensor ^ ReverseChuckNONC) THEN (ChuckInSensorMEM)
IF (ChuckOutSensor ^ ReverseChuckNONC) THEN (ChuckOutSensorMEM)

;------------------------------------------------------------------------------
                        LubeUsePumpTimers
;------------------------------------------------------------------------------

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be set such that MMM is a
; value that is greater than the cycle time set on the internal timers and
; SS should be set to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is set to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually set with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time set by the inteval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems accoding to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF SV_PROGRAM_RUNNING THEN SET Lube, RST LubeM_T
IF !SV_PROGRAM_RUNNING THEN LubeM_T = LubeM_W, SET LubeM_T
IF LubeM_T || !EStopOk THEN RST Lube

;------------------------------------------------------------------------------
                        LubeUsePLCTimers
;------------------------------------------------------------------------------
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be set so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To set the lube pump power to come on for 5 seconds
;    every 10 minutes, set P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To set the lube pump power to come on for 30 seconds
;    every 2 hours, set P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;

IF SV_PROGRAM_RUNNING  THEN LubeM_T = LubeM_W, SET LubeM_T
IF !SV_PROGRAM_RUNNING THEN (StopRunning_PD)
IF StopRunning_PD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T, RST LubeM_T
IF LubeM_T || (LubeAccumTime_W + LubeM_T > LubeM_W) THEN
  SET Lube, LubeS_T = LubeS_W, SET LubeS_T, RST LubeM_T, LubeAccumTime_W = 0
IF LubeS_T || !EStopOk THEN RST Lube, RST LubeS_T

;----------------------------------------------------------------
                        KeyboardEvents
;----------------------------------------------------------------
; This stage handles functions that are required for menu navigation
; by CNC11, require multiple keypresses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must set parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC11 to aid in menu
; navigation.  NOTE: For backward comaptibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked------------------------
; The for cycle cancel has been moved to the main stage.
; It is commented out below but remains for referrence
;Cycle Cancel
;if Kb_Escape THEN (KbCycleCancel_M)

;Rapidoverride: Ctrl-r
if Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M-------------------
;KbCycle Start: alt-s
if  Kb_s && (Kb_R_Alt || Kb_L_Alt) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
if Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbTogSingleBlock_M: ctrl-b
if Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
if Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
if Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then set KbSpinCW_M, rst KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
if Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then set KbSpinCCW_M, rst KbSpinCW_M

;KbSpinStart_M:  ctrl-s
if Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
if Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
if Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  then (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
if Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  then (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
if Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
if Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
if Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
if Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbMistOnOff_M)

;KbTogIncContJog_M: "ctrl" +  "i"
if Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
if Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogFastSlowJog_M)

;KbAux1Key_M: "ctrl" + "F1"
if Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
if Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
if Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
if Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
if Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
if Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
if Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
if Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
if Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
if Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux11Key_M: "ctrl" + "F11"
if Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux11Key_M)

;KbAux12Key_M: "ctrl" + "F12"
if Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
if Kb_Equals && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
if Kb_Hypen && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
if Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbFeedOver100_M)


;--------Interlocked with AllowKbInput_M && KbJpActive_M-----------

;KbIncreaseJogInc_M: "insert"
if Kb_Ins && AllowKbInput_M && KbJpActive_M
  then (KbIncreaseJogInc_M)
if KbIncreaseJogInc_M && x1JogLED && !X1_M && !X10_M && !X100_M
  then set X10_M
if KbIncreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  then set X100_M

;KbDecreaseJogInc_M: "delete"
if Kb_Del && AllowKbInput_M && KbJpActive_M
  then (KbDecreaseJogInc_M)
if KbDecreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  then set X1_M
if KbDecreaseJogInc_M && x100JogLED && !X1_M && !X10_M && !X100_M
  then set X10_M


;KbJogAx1Plus_M: Right arrow
if Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Right arrow
if Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
if Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
if Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
if Kb_PgUp && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
if Kb_PgDown && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
if Kb_Home && AllowKbInput_M && KbJpActive_M
  then (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
if Kb_End && AllowKbInput_M && KbJpActive_M
  then (KbJogAx4Minus_M)

if true THEN rst KeyboardEvents

;----------------------------------------------------------------
                           MPG_Stage
;----------------------------------------------------------------
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED && on the MPG
IF MPGKey then (MpgPD)
IF MpgPD && MPGLED then set MPGManOffFlag_M
IF (MpgPD && !MPGLED) then RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) && (!MPGManOffFlag_M) THEN SET MPG_LED_OUT, SET MPGLED

IF (MpgPD && MPGLED) THEN RST MPG_LED_OUT, RST MPGLED

;x1, x10, x100 functions
;--------------------------X1-----------------------------------
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp || X1_M || (MPG_Inc_X_1 && MPGLED)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--------------------------X10----------------------------------
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || X10_M || (MPG_Inc_X_10 && MPGLED)
  THEN RST x1JogLED, SET x10JogLED, RST x100JogLED

;--------------------------X100---------------------------------
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || X100_M || (MPG_Inc_X_100 && MPGLED)
  THEN RST x1JogLED, RST x10JogLED, SET x100JogLED

if !KbIncreaseJogInc_M && !KbDecreaseJogInc_M then rst X1_M, rst X10_M,
  rst X100_M
;                          MPG 1 Enable
IF MPGLED THEN (SV_MPG_1_ENABLED)

;                     Select axis to move
IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 2
IF MPG_AXIS_2 THEN SV_MPG_1_AXIS_SELECT = 1

;                   Select MPG 1 Multiplier
IF (x100JogLED) THEN SV_MPG_1_MULTIPLIER = 100
IF (x10JogLED)  THEN SV_MPG_1_MULTIPLIER = 10
IF (x1JogLED)   THEN SV_MPG_1_MULTIPLIER = 1

;            Disable "Windup" mode IF x100 selected
IF (!x100JogLED) THEN (SV_MPG_1_WINDUP_MODE)

;----------------------------------------------------------------
                           JOG_PANEL
;----------------------------------------------------------------
;         Select Incremental or Continuous Jog Mode
IF IncrContKey || KbTogIncContJog_M THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;              Select Fast or Slow Jog Mode
IF FastSlowKey || KbTogFastSlowJog_M THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || OnAtPowerUp ||  MechnicalProbe 
  THEN SET FastSlowLED
IF (SlowFastPD && FastSlowLED) THEN RST FastSlowLED

;---------------------------------------
;       Single Block Mode
;---------------------------------------
IF SingleBlockKey || KbTogSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING
  THEN SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;---------------------------------------
;           Toolcheck
;---------------------------------------
IF (ToolCheckKey || KbToolCheck_M) && EstopOk THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;---------------------------------------
;          Feed Hold Mode
;---------------------------------------
IF (FeedHoldKey || KbFeedHold_M) && SV_PROGRAM_RUNNING THEN (FeedHoldPD)
IF FeedHoldPD && !FeedHoldLED THEN SET FeedHoldLED
IF FeedHoldPD && FeedHoldLED && !SV_PROGRAM_RUNNING && !SV_MDI_MODE
  THEN RST FeedHoldLED
IF FeedHoldLED && (DoCycleStart || DoCycleCancel || ToolCheckPD)
  THEN RST FeedHoldLED
IF FeedHoldLED THEN SET DoFeedHold
IF !FeedHoldLED THEN RST DoFeedHold

;---------------------------------------
;   Feedrate Override Section
;---------------------------------------
;-------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and then multiplying the result by 100
; 3. If keyboard joggin is not disabled (it is enabled by default), the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" scrren in CNC11 software) stores
;    a value which allows which the PLC program can use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC11 software by setting
;    SV_PLC_FeedrateKnob_W = FinalFeedOverride_W
; 7. CNC11 reads SV_PLC_FEEDRATE_KNOB, factors in it's on own override based
;    on parameter 78 (see operators manual for more info on parm 78) and then
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;-----------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;-----------------------------------------------------------------------
IF true THEN FeedrateKnob_W = 0
if true THEN BTW FeedrateKnob_W JpFeedOrKnobBit0 8

;-----------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;-----------------------------------------------------------------------
IF true THEN FeedrateKnob_W = (FeedrateKnob_W/127.5)*100

;-----------------------------------------------------------------------
; 3.  Determine whether to us FeedrateKnob_W or KbOverride_W
;-----------------------------------------------------------------------
; This section determines when to use the feedrate override value sent down
; by the jogpanel (FeedrateKnob_W) or the feedrate override as determined
; by the PLC monitoring the keyboard override keys (KbOverride_W).

;-------------------------------------------------------------------------------
;     At powerup, default feedrate override is jog panel (FeedrateKnob_W)
;       To use both keyboard or jogpanel overrides set p170 to 0 (default)
;       To use jogpanel override only set p170 to 2
;       To use keyboard only set p170 to 4
;-------------------------------------------------------------------------------
IF OnAtPowerUp && KbOverOnly_M || KbFeedOver100_M THEN KbOverride_W = 100
IF OnAtPowerUp && !KbOverOnly_M THEN set UsingFeedrateKnob_M,
  KbOverride_W = FeedrateKnob_W, Last_FeedrateKnob_W = FeedrateKnob_W

;----------------Calculate keyboard feedrate override---------------------------
; SleepTimer is used to limit the KbOverride_W update rate to 20% per sec
;-------------------------------------------------------------------------------
if AllowKbInput_M && KbIncFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W + 1, rst UsingFeedrateKnob_M,
  set WaitingForSleepTimer_M, SleepTimer = 50, set SleepTimer

if AllowKbInput_M && KbDecFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W - 1, rst UsingFeedrateKnob_M,
  set WaitingForSleepTimer_M, SleepTimer = 50, set SleepTimer

if SleepTimer THEN rst WaitingForSleepTimer_M, rst SleepTimer

;------------Switch to FeedrateKnob_W if it changes more 3%----------------------
; Once it has changed by more than 3%, it will update as normal (1% increments)
; until it sees another KbOverride_W command at which point it will take
; another 3% change to re-activate the FeedrateKnob_W

if (abs(Last_FeedrateKnob_W - FeedrateKnob_W) >= 3) || UsingFeedrateKnob_M
  THEN FinalFeedOverride_W = FeedrateKnob_W, KbOverride_W = FeedrateKnob_W,
  Last_FeedrateKnob_W = FeedrateKnob_W, set UsingFeedrateKnob_M

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W && the FeedrateKnob_W
if KbOverride_W > SV_MACHINE_PARAMETER_39
  THEN KbOverride_W = SV_MACHINE_PARAMETER_39

if !UsingFeedrateKnob_M && !JogOverOnly_M
  THEN FinalFeedOverride_W = KbOverride_W


;-----------------------------------------------------------------------
; 4 && 5. Limit override percentage to value set in Parameter 39
;-----------------------------------------------------------------------
;------------------Limit final override percentage to parm 39-------------------
if FinalFeedOverride_W > SV_MACHINE_PARAMETER_39
  THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39

if FinalFeedOverride_W < 0 THEN FinalFeedOverride_W = 0

;-----------------------------------------------------------------------
; 6. Send override percentage to CNC11
;-----------------------------------------------------------------------
;----------------Send override to PC for modification if needed-----------------
if true THEN SV_PLC_Feedrate_Knob = FinalFeedOverride_W

;-----------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;-----------------------------------------------------------------------
;--------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;--------------------------------------------------------------------------
IF true THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;---------------------------------------------------------
;  MPU11 Jog Panel Functions
;---------------------------------------------------------
IF KB_F9 then (F9PD)
IF KbTogRapidOver_M || (F9PD && SV_PROGRAM_RUNNING) THEN (RapidOverPD)
IF RapidOverPD^ SelectRapidOverride THEN (SelectRapidOverride)
if OnAtPowerUp then set SelectRapidOverride

IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)
IF (CycleStartKey  || KbCycleStart_M) THEN (DoCycleStart)
;Standard jogging setup for X && Z
;If parameters are set to reverse the X+ && X- jog keys or to swap X && Z axes,
;the keys are switched in the AxesReconfigured stage
;Z
IF SwapAxes_M || InvertXJogKeys_M Then set AxesReconfigured
;Z
IF (Ax1PlusJogKey  || KbJogAx1Plus_M) && !SwapAxes_M && !InvertXJogKeys_M
  && !Ax1PlusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
  (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M) && !SwapAxes_M && !InvertXJogKeys_M
  && !Ax1MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
  (DoAx1MinusJog)
;X
IF (Ax2PlusJogKey  || KbJogAx2Plus_M) && !SwapAxes_M && !InvertXJogKeys_M &&
  !Ax2PlusJogDisabled_M  &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M) && !SwapAxes_M && !InvertXJogKeys_M &&
  !Ax2MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
  (DoAx2MinusJog)

IF (Ax3PlusJogKey  || KbJogAx3Plus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)

IF (Aux1Key        || KbAux1Key_M) THEN (DoAux1Key)
IF (Aux2Key        || KbAux2Key_M) THEN (DoAux2Key)
IF (ToolIndexKey        || KbAux3Key_M) THEN (DoAux3Key)
IF (TailInKey        || KbAux4Key_M) THEN (DoAux4Key)
IF (TailOutKey        || KbAux5Key_M) THEN (DoAux5Key)
IF (Aux6Key        || KbAux6Key_M) THEN (DoAux6Key)
IF (WorklightKey  || KbAux7Key_M) THEN (DoAux7Key)
IF (ChuckInKey   || KbAux8Key_M) THEN (DoAux8Key), (Aux8KeyPD)
IF (ChuckOutKey  || KbAux9Key_M) THEN (DoAux9Key), (Aux9KeyPD)
;IF (Aux10Key      || KbAux10Key_M) THEN (DoAux10Key)
IF x1JogLED                 THEN (SelectX1JogInc)
IF x10JogLED                THEN (SelectX10JogInc)
IF x100JogLED               THEN (SelectX100JogInc)
IF IncrContLED              THEN (SelectIncContJog)
IF FastSlowLED              THEN (SelectFastSlowJog)
IF MPGLED                   THEN (SelectMpgMode)
IF Aux11LED                 THEN (DoAux11Key)
IF FeedHoldLED              THEN (DoFeedHold)


;----------------------------------------------
;  Override Controls
;----------------------------------------------
; Override control bit for the feedrate override
; 1 == feedrate override knob will effect feedrate
; 0 == override knob has NO effect on feedrate
IF  !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN SV_PLC_Feedrate_Knob = 100


;-----------------------------------------------------
;               Coolant Functions
;-----------------------------------------------------

;--------------Toggle auto coolant mode---------------
IF CoolAutoManKey || KbTogCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoManLED && CoolantAutoManualPD) || OnAtPowerUp
  THEN SET CoolAutoManLED

IF (CoolAutoManLED && CoolantAutoManualPD)
  THEN RST CoolAutoManLED

;------------Report coolant mode to CNC11-------------
IF CoolAutoManLED THEN (SelectCoolAutoMan)

;-----------Display coolant mode message--------------
;changing to auto coolant mode ;9050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoManLED && CoolantAutoManualPD)
  THEN AsyncMsg_W = 12802, MSG AsyncMsg_W;, AsyncMsg_W = 0

;changing to manual coolant mode ;9051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoManLED && CoolantAutoManualPD)
  THEN  AsyncMsg_W = 13058, MSG AsyncMsg_W;, AsyncMsg_W = 0

;--------------------------------------------------------------
;                Flood coolant on/off
;--------------------------------------------------------------
IF ((CoolFloodKey || KbFloodOnOff_M) && !CoolAutoManLED) || 
  (M8 && CoolAutoManLED) || (DoCycleStart && M8 && CoolAutoManLED) 
  THEN (CoolantFloodPD)  

IF CoolantFloodPD && !CoolFloodLED Then SET CoolFloodLED, Set Flood
   
IF SV_STOP || (CoolantFloodPD && CoolFloodLED) || (!M8 && CoolAutoManLED) ||
  (M8 && !CoolAutoManLED) || DoToolCheck THEN Rst Flood, Rst CoolFloodLED
 
IF CoolFloodLED THEN (SelectCoolantFlood)        
;--------------------------------------------------------------
;                  Mist coolant on/off
;--------------------------------------------------------------
IF ((CoolMistKey || KbMistOnOff_M)&& !CoolAutoManLED) || (M7 && CoolAutoManLED)
  || (DoCycleStart && M7 && CoolAutoManLED) THEN (CoolantMistPD)

IF (CoolantMistPD && !CoolMistLED) THEN SET Mist, SET CoolMistLED
   
IF SV_STOP || (CoolantMistPD && CoolMistLED) || (!M7 && CoolAutoManLED) ||
  (M7 && !CoolAutoManLED) || DoToolCheck THEN Rst Mist, Rst CoolMistLED

IF CoolMistLED THEN (SelectCoolantMist)

;-------------------------------------------------------------
;                       Spindle Control
;-------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;-------------------------------------------------------------
;-------------------------------------------------------------
;      Select Auto or Manual Spindle Operation Mode
;-------------------------------------------------------------
;-----Triggers to Toggle Auto/Manual Spindle Mode-------------
IF SpinAutoManKey || KbTogSpinAutoMan_M THEN (SpinAutoManPD)

;----------Set spindle to auto mode on startup-----------------
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp
  THEN SET SpinAutoModeLED

;---------------Set spindle to manual mode---------------------
if SpinAutoManPD && SpinAutoModeLED THEN rst SpinAutoModeLED

;----------------------Report the Spindle mode to CNC11-------------------------
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;--------------------------------------------------------------
;         Set triggers to start and stop the spindle
;--------------------------------------------------------------
; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

IF !SV_MDI_MODE && !SV_PROGRAM_RUNNING THEN rst m3,rst m4
IF ((SpinStartKey || KbSpinStart_M) && !SpinAutoModeLED) ||
  (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M) ||
  ((SpinStartKey || KbSpinStart_M) && ((M3 || M4) && SpinAutoModeLED))
  THEN (SpinStartPD), Rst SpindlePause_M

If (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M))
  THEN set SpindlePause_M

If (SpinStopKey || KbSpinStop_M) || (SpinAutoModeLED && !M3 && !M4) ||
  (SpinAutoManPD && SpindleEnableOut) || (SV_PC_RIGID_TAP_SPINDLE_OFF &&
  SpinAutoModeLED) THEN (SpinStopPD)

;--------------------------------------------------------------
;Adjust spindle override when entering manual or auto spin mode
;--------------------------------------------------------------
;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 100,
  SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 10, Rst SpinAutoModeLED

;--------------------------------------------------------------
;                     Set spindle direction
;--------------------------------------------------------------
;------------------Set Clockwise direction---------------------
IF ((KbSpinCW_M || SpinCWKey) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
  || (M3 && DoCycleStart) then (SpinCWPD)
IF SpinCWPD then rst SpindleDirectionout
IF !SpindleDirectionOut then (SpindleCWLED), (SelectSpindleCW)


;---------------Set Counterclockwise direction-----------------
IF ((KbSpinCCW_M || SpinCCWKey) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
  || (M4 && DoCycleStart) then (SpinCCWPD)
IF SpinCCWPD then set SpindleDirectionOut
IF SpindleDirectionOut then (SpindleCCWLED), (SelectSpindleCCW)

;-------------------------------------------------------------------------------
;                                Turn spindle on/off
;-------------------------------------------------------------------------------
IF ProbeDetect && SpinStartPD THEN set ProbeFault_M

IF (SpindleEnableOut || SpinStartPD ) && !SpinStopPD && !SV_STOP && !ProbeDetect
  && SpindleInverterOk THEN (SpindleEnableOut)

IF !SpindleEnableOut  THEN (DoSpindleStop)


;-------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "shift" + "<", "shift" + ">", "shift" + "<" && ">"
;-------------------------------------------------------
IF SpinOverPlusKey || KbIncSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1
IF SpinOverMinusKey || KbDecSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1
IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp
  THEN SV_PLC_SPINDLE_KNOB = 100

IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN
  (SpinOver100LED),
  (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN
  (SpinOverMinusLED),
  (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN
  (SpinOverPlusLED),
  (DoIncreaseSpindleOr)

;--------------------------------------------------------------------------------
;                  Output 12-bit DAC value for spindle control
;--------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
;             Read spindle range inputs and/or range M codes
;
; NOTE: SV_SPINDLE_LOW_RANGE && SV_SPINDLE_MID_RANGE M are used to report the
; selected spindle range to CNC11
;--------------------------------------------------------------------------------
;    hi      med-high  med-low  low
;    0          1        1      0 SV_SPINDLE_MID_RANGE
;    0          0        1      1 SV_SPINDLE_LOW_RANGE


;-----------------------Low Range--------------------------------
If (Low_Gear_SW && !MED_Gear_SW && !High_Gear_SW && !Gear_Change_Req) then set SpinLowRange_M, 
	rst SpinMedLowRange_M,
	rst SpinHighRange_M

if SpinLowRange_M && (SV_MACHINE_PARAMETER_65 > .01)
  then SpinRangeAdjust = SV_MACHINE_PARAMETER_65
  ;, set SV_SPINDLE_LOW_RANGE,
  ;rst SV_SPINDLE_MID_RANGE

;-----------------------Med Range----------------------------
If (!Low_Gear_SW && MED_Gear_SW && !High_Gear_SW && !Gear_Change_Req) then set SpinMedLowRange_M,
	rst SpinLowRange_M,
	rst SpinHighRange_M

if SpinMedLowRange_M && (SV_MACHINE_PARAMETER_66 > .01)
  then SpinRangeAdjust = SV_MACHINE_PARAMETER_66
  ;, rst SV_SPINDLE_LOW_RANGE,
  ;set SV_SPINDLE_MID_RANGE

;-----------------------High Range----------------------------
If (!Low_Gear_SW && !MED_Gear_SW && High_Gear_SW) || Gear_Change_Req
  then set SpinHighRange_M,
  rst SpinLowRange_M,
  rst SpinLowRange_M

;IF true THEN SET SpinHighRange_M

;if SpinHighRange_M THEN rst SV_SPINDLE_LOW_RANGE,
;  rst SV_SPINDLE_MID_RANGE

if SpinHighRange_M then SpinRangeAdjust = 1
if SpinRangeAdjust == 0 then SpinRangeAdjust = 1

;----------------------------------------------------------------
;              Read commanded spindle speed, max && min
;
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
;----------------------------------------------------------------
if true then SpinSpeedCommand_W =  SV_PC_COMMANDED_SPINDLE_SPEED,
             CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED

;----------------------------------------------------------------
; If commanded spindle speed is < Min Spin Speed * SpinRangeAdjust
; && commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust.
;----------------------------------------------------------------
IF (SpinSpeedCommand_W > 0) &&
  (SpinSpeedCommand_W < (CfgMinSpeed_FW * SpinRangeAdjust))
  then SpinSpeedCommand_W = (CfgMinSpeed_FW * SpinRangeAdjust),
  ErrorCode_W = MIN_SPEED_MSG

;---------------------------------------------------------------------------
; If SpinSpeedCommand_W > Max Spin Speed * SpinRangeAdjust, force
; SpinSpeedCommand_W = max spin speed value * SpinRangeAdjust.
;---------------------------------------------------------------------------
IF SpinSpeedCommand_W > (CfgMaxSpeed_FW * SpinRangeAdjust)
  THEN SpinSpeedCommand_W = (CfgMaxSpeed_FW * SpinRangeAdjust)
;---------------------------------------------------------------- 
; Convert Spindle "S" command to 12 bit value for output to DAC
;----------------------------------------------------------------
; Commanded Spindle speed (includes override factor) is sent down from CNC11
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a  
; 12 bit value (0-4095) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED. 

; Calculate #RPM's per bit of resolution
if CfgMaxSpeed_FW > 0 then RPMPerBit_FW = CfgMaxSpeed_FW/4095
if CfgMaxSpeed_FW > 0 then SixteenBitRPMPerBit_FW = CfgMaxSpeed_FW/65534
if CfgMaxSpeed_FW <= 0 then RPMPerBit_FW = 1
if CfgMaxSpeed_FW <= 0 then SixteenBitRPMPerBit_FW = 1

;Convert RPM to 12 bit value
if true then TwelveBitSpeed_FW = SpinSpeedCommand_W/RPMPerBit_FW
IF true THEN SixteenBitSpeed_FW = SpinSpeedCommand_W/SixteenBitRPMPerBit_FW

; Bound min to 0, max to 4095 
if TwelveBitSpeed_FW < 0 then TwelveBitSpeed_W = 0
if TwelveBitSpeed_FW > 4095 then TwelveBitSpeed_W = 4095

if SixteenBitSpeed_FW < 0 then SixteenBitSpeed_FW = 0
if SixteenBitSpeed_FW > 65534 then SixteenBitSpeed_FW = 65534

; Factor in gear range 
IF true THEN TwelveBitSpeed_FW = (TwelveBitSpeed_FW/SpinRangeAdjust)
IF true THEN SixteenBitSpeed_FW = (SixteenBitSpeed_FW/SpinRangeAdjust)
IF !SpindleDirectionOut then SixteenBitSpeed_FW = -SixteenBitSpeed_FW
IF true THEN SixteenBitSpeed_FW = SixteenBitSpeed_FW / 2

;Convert to integer word for DAC && I/O display
if true then TwelveBitSpeed_W = TwelveBitSpeed_FW
if true then SixteenBitSpeed_W = SixteenBitSpeed_FW
if true then SpindleDACEcho = SV_SPINDLE_DAC

; Output to DAC
If true then WTB TwelveBitSpeed_W SpinAnalogOutBit0 12

;Display calculated RPM value on PC  
IF true 
  then SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_W

IF true THEN SV_SPINDLE_DAC = SixteenBitSpeed_W

;Display calculated RPM value on PC  
IF true 
  then SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_W

;----------------------------------------------------------------
                      AxesReconfigured
;----------------------------------------------------------------

;X axis jog keys inverted, X && Z not swapped
;-----------------------------------------------
;Z
IF InvertXJogKeys_M && !SwapAxes_M && (Ax1PlusJogKey  || KbJogAx1Plus_M)
  THEN (DoAx1PlusJog)
IF InvertXJogKeys_M && !SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
  THEN (DoAx1MinusJog)
;X
IF InvertXJogKeys_M && !SwapAxes_M && (Ax2PlusJogKey  || KbJogAx2Plus_M)
  THEN (DoAx2MinusJog)
IF InvertXJogKeys_M && !SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
  THEN (DoAx2PlusJog)

;-----------------------------------------------

;X && Z axes are swapped, X not inverted
;-----------------------------------------------
;X
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1PlusJogKey || KbJogAx1Plus_M)
  THEN (DoAx2PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
  THEN (DoAx2MinusJog)
;Z
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2PlusJogKey || KbJogAx2Plus_M)
  THEN (DoAx1PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
  THEN (DoAx1MinusJog)

;X && Z axes are swapped, X also inverted
;-----------------------------------------------
;X
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1PlusJogKey || KbJogAx1Plus_M)
  THEN (DoAx2MinusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
  THEN (DoAx2PlusJog)
;Z
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2PlusJogKey || KbJogAx2Plus_M)
  THEN (DoAx1PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
  THEN (DoAx1MinusJog)

;-----------------------
  CheckCycloneStatusStage
;-----------------------
; Due to amount of time it takes to retrieve data from the cyclone, this stage
; is only called few times per second to help reduce scan time of the main PLC
; program.

; The logic below is the equivalent to the following:
; IF true THEN BITTST SV_PC_CYCLONE_STATUS_2 0 Axis1FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 1 Axis2FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 2 Axis3FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 3 Axis4FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 4 Axis5FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 5 Axis6FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 6 Axis7FiberOk_M,
;              BITTST SV_PC_CYCLONE_STATUS_2 7 Axis8FiberOk_M
IF true THEN WTB SV_PC_CYCLONE_STATUS_2 Axis1FiberOk_M

; Generate some messages for fiber or wire to MPU11 having issues
IF SV_AXIS_VALID_1 && !SV_DRIVE_ONLINE_1 THEN ErrorCode_W = AXIS1_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_2 && !SV_DRIVE_ONLINE_2 THEN ErrorCode_W = AXIS2_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_3 && !SV_DRIVE_ONLINE_3 THEN ErrorCode_W = AXIS3_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_4 && !SV_DRIVE_ONLINE_4 THEN ErrorCode_W = AXIS4_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_5 && !SV_DRIVE_ONLINE_5 THEN ErrorCode_W = AXIS5_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_6 && !SV_DRIVE_ONLINE_6 THEN ErrorCode_W = AXIS6_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_7 && !SV_DRIVE_ONLINE_7 THEN ErrorCode_W = AXIS7_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_8 && !SV_DRIVE_ONLINE_8 THEN ErrorCode_W = AXIS8_INFLT, SET DriveComFltIn_M

; Generate some messages for fiber or wire to drive having issues
IF SV_AXIS_VALID_1 && SV_DRIVE_ONLINE_1 && SV_MASTER_ENABLE && !Axis1FiberOk_M
  THEN ErrorCode_W = AXIS1_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_2 && SV_DRIVE_ONLINE_2 && SV_MASTER_ENABLE && !Axis2FiberOk_M
  THEN ErrorCode_W = AXIS2_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_3 && SV_DRIVE_ONLINE_3 && SV_MASTER_ENABLE && !Axis3FiberOk_M
  THEN ErrorCode_W = AXIS3_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_4 && SV_DRIVE_ONLINE_4 && SV_MASTER_ENABLE && !Axis4FiberOk_M
  THEN ErrorCode_W = AXIS4_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_5 && SV_DRIVE_ONLINE_5 && SV_MASTER_ENABLE && !Axis5FiberOk_M
  THEN ErrorCode_W = AXIS5_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_6 && SV_DRIVE_ONLINE_6 && SV_MASTER_ENABLE && !Axis6FiberOk_M
  THEN ErrorCode_W = AXIS6_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_7 && SV_DRIVE_ONLINE_7 && SV_MASTER_ENABLE && !Axis7FiberOk_M
  THEN ErrorCode_W = AXIS7_OUTFLT, set DriveComFltOut_M
IF SV_AXIS_VALID_8 && SV_DRIVE_ONLINE_8 && SV_MASTER_ENABLE && !Axis8FiberOk_M
  THEN ErrorCode_W = AXIS8_OUTFLT, set DriveComFltOut_M

If !EstopOk THEN rst DriveComFltIn_M, rst DriveComFltOut_M
If DriveComFltOut_M || DriveComFltIn_M THEN set AxisFault_M

;check PLC status bit
IF TRUE THEN BitTst SV_PC_CYCLONE_STATUS_1 21 PLCBusExtDevEn_M

;check input fiber
IF !SV_PLC_BUS_ONLINE THEN ErrorCode_W = PLC_INFLT, set SetErrorStage,
  rst PLCBus_Oe_M, set PLCFault_M

;check output fiber
IF SV_PLC_BUS_ONLINE && PLCBus_Oe_M && !PLCBusExtDevEn_M
  THEN ErrorCode_W = PLC_OUTFLT, set SetErrorStage, set PLCFault_M

;clear PLC errors
IF PLCFault_M && SV_PLC_BUS_ONLINE && PLCBusExtDevEn_M && !EstopOk
  THEN rst PLCFault_M, ErrorCode_W = PLC_FLT_CLR, set SetErrorStage, set PLCBus_Oe_M

if true THEN rst CheckCycloneStatusStage

;----------------------------------------------------------------
                     AxesEnableStage
;----------------------------------------------------------------
;clear axis fault errors
If AxisFault_M && !DriveComFltOut_M && !DriveComFltIn_M && !EstopOk
  Then ErrorCode_W = AXIS_FLT_CLR, set SetErrorStage, rst AxisFault_M
  
IF (SV_PC_POWER_AXIS_1) THEN (SV_ENABLE_AXIS_1)
IF (SV_PC_POWER_AXIS_2) THEN (SV_ENABLE_AXIS_2)
IF (SV_PC_POWER_AXIS_3) THEN (SV_ENABLE_AXIS_3)
IF (SV_PC_POWER_AXIS_4) THEN (SV_ENABLE_AXIS_4)
IF (SV_PC_POWER_AXIS_5) THEN (SV_ENABLE_AXIS_5)
IF (SV_PC_POWER_AXIS_6) THEN (SV_ENABLE_AXIS_6)
IF (SV_PC_POWER_AXIS_7) THEN (SV_ENABLE_AXIS_7)
IF (SV_PC_POWER_AXIS_8) THEN (SV_ENABLE_AXIS_8)

;read the status bits
IF true THEN SET CycloneStatusTimer
IF CycloneStatusTimer THEN SET CheckCycloneStatusStage, RST CycloneStatusTimer

;turn on drives if no errors
IF !DriveComFltIn_M && !SV_STALL_ERROR && !DriveComFltOut_M THEN set SV_MASTER_ENABLE

IF DriveComFltIn_M || DriveComFltOut_M THEN rst SV_MASTER_ENABLE, set SV_STOP

;----------------------------------------------------------------
                           MainStage
;----------------------------------------------------------------
;Do gather if commanded (umcomment and recompile for debugging purposes)
;IF Aux11Key THEN (Aux11KeyPD)
;If Aux11KeyPD THEN (SV_TRIGGER_PLOT_DUMP)

;read parameter 178 and check the Lube NO/NC state
; Invert input 9
IF  InvLubeOk_M THEN BITSET Inputs_9_12_W 6
IF !InvLubeOk_M THEN BITRST Inputs_9_12_W 6

 ; Invert input 10
IF  InvSpinInverterOk_M THEN BITSET Inputs_9_12_W 14
IF !InvSpinInverterOk_M THEN BITRST Inputs_9_12_W 14
IF true THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;Latch Aux12Key (ATCOverride) if in Mdi.  Reset ATCoverride_M when mdi is exited
If ATCOverrideKey && SV_MDI_MODE Then Set ATCOverride_M
If !SV_MDI_MODE Then Rst ATCOverride_M

;----------------------------------------------------------------
;           Probe protection while jogging
;----------------------------------------------------------------
If MechnicalProbe && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
  DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
  DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog)
  THEN set JogProbeFault_M, (JogProbeFaultPD)

;IF JogProbeFaultPD THEN set SV_Stop, ErrorCode_W = PROBE_JOG_FAULT_MSG
;IF JogProbeFaultPD && DoAx1PlusJog  THEN SET Ax1PlusJogDisabled_M
;IF JogProbeFaultPD && DoAx1MinusJog THEN SET Ax1MinusJogDisabled_M
;IF JogProbeFaultPD && DoAx2PlusJog  THEN SET Ax2PlusJogDisabled_M
;IF JogProbeFaultPD && DoAx2MInusJog THEN SET Ax2MinusJogDisabled_M

;IF !MechnicalProbe THEN RST JogProbeFault_M,
;                        RST Ax1PlusJogDisabled_M,
;                        RST Ax1MinusJogDisabled_M,
;                        RST Ax2PlusJogDisabled_M,
;                        RST Ax2MinusJogDisabled_M

;--------------------------- 
; Door InterLock
; 1. DoorSWONOFF - special parameter bit to override door check
; 
; 2. Tool_Check_Flag Overrides
; note: Apply 24VDC to unlock door interlock.
;--------------------------- 
IF SV_PROGRAM_RUNNING THEN SET Door_T
IF !SV_PROGRAM_RUNNING THEN RST Door_T
IF (!DoorClosed && !DoorSWONOFF && ( ( SV_PROGRAM_RUNNING && !ToolCheckPD && SV_PC_HOME_SET) || SpindleEnableOut ))
	THEN (DoorFaultOut_M)

IF (DoorFaultOut_M && !SV_STOP)
	THEN ErrorCode_W = DOOR_OPEN_W_JOB_RUN,     ; 1 + 256*116 "Door Open with Job Running"
	SET SetErrorStage, SET SV_STOP
	
IF !SV_PROGRAM_RUNNING || (ZeroSpeed ^ ZeroSpeedNONC )
	THEN SET DoorLockOut ; not running. unlock door.
IF SV_PROGRAM_RUNNING || !(ZeroSpeed ^ ZeroSpeedNONC ) || SV_STOP
	THEN RST DoorLockOut ; running unlock door.

;-------------------------------- 
; Gear Change Handling 61 62 
;   Gear_FWD  (M94/9) - AutoGear Motor CW 
;   Gear_REV (M94/10) - AutoGear Motor CCW 
;-------------------------------- 
IF Gear_FWD && SpinAutoModeLED && !SV_STOP THEN SET GearMotorDirectionOut
IF Gear_REV && SpinAutoModeLED && !SV_STOP THEN RST GearMotorDirectionOut
IF Gear_FWD || Gear_REV && SpinAutoModeLED && !SV_STOP THEN (GearMotorEnableOut)
IF ( Gear_FWD || Gear_REV ) && !SpinAutoModeLED THEN 
	ErrorCode_W = SELECT_AUTO_SPINDLE_MSG
IF Gear_Change_Req THEN SET GearChangeTimer_T
IF !Gear_Change_Req THEN RST GearChangeTimer_T
IF GearChangeTimer_T
   THEN ErrorCode_W = GEAR_CHANGE_TIME_OUT, ;1 + 256*118, ; "9118 GEAR CHANGE FAULT: TIME OUT" 
        SET SetErrorStage, SET SV_STOP 

IF !LOW_Gear_SW && !MED_Gear_SW && !HIGH_Gear_SW && !Gear_Change_Req && SpindleEnableOut && !ATCOverride_M
   THEN ErrorCode_W = GEAR_CH_NOT_IN_GEAR, ; 1 + 256 * 119 "9119 GEAR CHANGE FAULT: NOT IN GEAR"
        SET SetErrorStage, SET SV_STOP

IF ( LOW_Gear_SW && MED_Gear_SW && HIGH_Gear_SW ) && !ATCOverride_M
  THEN ErrorCode_W = GEAR_CH_SENSOR_FAULT, ; 1 + 256*120 "9120 GEAR SENSOR FAULT"  
       SET SetErrorStage, SET SV_STOP

IF !EstopOk THEN RST Gear_Change_Req, RST Gear_FWD, RST Gear_REV
;-----------------------------Keyboard--------------------------------
;Cycle Cancel
if Kb_Escape THEN (KbCycleCancel_M)
;KbFeedHold_M: spacebar
if Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING then (KbFeedHold_M)

;Just a shorter name for SV_PC_VIRTUAL_JOGPANEL_ACTIVE
if SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEvents stage if needed
if Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt ||
  KbJpActive_M THEN set KeyboardEvents

if (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
  && (Kb_j || Kb_f || kb_a || kb_s) && !AllowKbInput_M
  THEN ErrorCode_W = KB_JOG_MSG

;-------------------------------------------
;               Report ATC Position to CNC11:
;-------------------------------------------

IF true THEN SV_PLC_CAROUSEL_POSITION = BinPosition_W

;----------------------------------------------------------------
;                          M-Codes
;----------------------------------------------------------------
;----------------------------------------------------------------
;    Reset these M-codes if not in CNC Program Running mode
;----------------------------------------------------------------
IF !SV_PROGRAM_RUNNING THEN RST M3, RST M4, RST M8

;-----------------------------------------------
; Faults
;-----------------------------------------------
if !EStopOk || PLCFault_M || SV_STALL_ERROR || Spindle_Fault_M ||
  LubeFault_M || AxisFault_M ||  ProbeFault_M THEN set SV_STOP
if !EstopOk && SV_STALL_ERROR THEN rst SV_STALL_ERROR
IF SV_Stop || PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE
IF InitializeTimer && !LubeOk && !SV_PROGRAM_RUNNING && EStopOk
  THEN SET LubeFault_M, ErrorCode_W = LUBE_FAULT_MSG

IF !LubeOk && SV_PROGRAM_RUNNING THEN ErrorCode_W = LUBE_WARNING_MSG

IF !EstopOK && LubeOk THEN RST LubeFault_M	;clear lube fault
IF !EstopOK && ProbeFault_M THEN rst ProbeFault_M, rst ProbeMsgSent_M
IF InitializeTimer && !SpindleInverterOk THEN ErrorCode_W = SPINDLE_FAULT,
  Set SV_STOP, SET Spindle_Fault_M
IF !EstopOK && SV_SPINDLE_FAULT THEN (InverterResetOut), RST Spindle_Fault_M 



if EStopOk && !PLCFault_M && !SV_STALL_ERROR && !Spindle_Fault_M &&
  !LubeFault_M && !DriveComFltIn_M && !DriveComFltOut_M && SV_PLC_BUS_ONLINE && 
  !PLCFault_M && !SoftwareReady_M &&
  !PLCExecutorFault_M THEN RST SV_STOP

IF ProbeFault_M && !ProbeMsgSent_M
  THEN ErrorCode_W = PROBE_FAULT_MSG, set SetErrorStage, set ProbeMsgSent_M
   
;----------------------------------------------
; Status Lights:
;   - Red Light for all stop / error conditions
;   - Amber Light when not running a job, doing a tool change,
;     or waiting for operator input
;   - Green Light when running a job normally
;----------------------------------------------
; Green Light 
IF (SV_PROGRAM_RUNNING && !RedLightOut && !AmberLightOut) then (GreenLightOut)
; Amber Light
IF (!SV_PROGRAM_RUNNING && !RedLightOut) THEN (AmberLightOut)
; Red Light  
IF SV_Stop then (RedLightOut)

;----------------------------------------------
; Worklight
;----------------------------------------------

if (WorkLightKey) then (WorklightPD)
if (WorkLightPD && !WorkLightOut) || OnAtPowerUp then set WorkLightOut
if WorkLightPD && WorkLightOut then rst WorkLightOut
if WorkLightOut then (WorklightLED)	;added by AWG for Blair

;-----------------------------------------------
; turn off default setup variable
;-----------------------------------------------
IF true THEN RST OnAtPowerUp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Spindle Ready Signal
; 	The purpose of this is to make sure the spindle does not 
;	start spinning before we know chuck is ready. 
;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IF ((!ChuckOutSensorMEM && OD_MODE_M) || (!ChuckInSensorMEM && ID_MODE_M)) 
	THEN (ChuckReady_M)

IF (!ChuckReady_M && (SpindleEnableOut || M3 || M4)) THEN (ChuckNotReady_M)

; Set error if spindle running and chuck not ready:

IF ((SpindleEnableOut) || (SpindleEnableOut && SV_PROGRAM_RUNNING)) && ChuckNotReady_M;
	THEN ErrorCode_W = CHUCK_NOT_READY,     ; 1 + 256*117 "Chuck Not Ready"
	SET SetErrorStage, SET SV_STOP
	
;-------------------------------------------------------- 
; Chuck Direction Switch
; Purpose: Physical switch to selection ID or OD chuck operation.
; This will also display messages on display windows to notify user
;---------------------------------------------------------
IF M10 THEN (M10PD)
IF M11 THEN (M11PD)
IF !ID_OD_SW THEN (OD_MODE_M), (ODPD);, ErrorCode_W = OD_CHUCK_MODE
IF ID_OD_SW THEN  (ID_MODE_M), (IDPD);, ErrorCode_W = ID_CHUCK_MODE
IF M10PD || M11PD THEN SET ChuckCheck_M 
IF IDPD || ODPD THEN RST ChuckCheck_M
;IF Hydraulic_Pump THEN (Clamp_Error_T)

;---------------------------------------------------------
; Chuck Foot Pedal
; Purpose: ChuckPOS_M represents the state Chuck suppose to be in
; It acts as memory for Chuck position.
; ChuckPOS_M (GRN) - Chuck Out State
; !ChuckPOS_M (RED) - Chuck In State. 
;----------------------------------------------------------
IF ChuckFootPedal THEN (ChuckPD), (Chuck2PD)
IF !EstopOK THEN RST ChuckFootReq_M 
IF (( ChuckPOS_M ^ ChuckPD ) || (M11 && !ChuckPOS_M)) && !M10  then (ChuckPOS_M) 

;--------------------------- 
;   CHUCK_IN_STAGE 
;  (Chuck In State) 
;--------------------------- 
IF ((Aux8KeyPD) && !SpindleEnableOut && !SV_STOP && !SV_PROGRAM_RUNNING) 
	|| ((M10PD) && !SpindleEnableOut && !SV_STOP)
	THEN SET ChuckInSolOut, 
	RST ChuckOutSolOut, 
	SET ChuckInMode_M,
	RST ChuckOutMode_M,
	SET CC_T,
	RST CU_T,
	SET ChuckInLED,
	RST ChuckOutLED,
	RST ChuckFootReq_M
	;RST ClampError_T
	
IF CC_T then  RST ChuckOutSolOut, 
              RST ChuckInSolOut,
	      SET ChuckInMode_M,
	      RST ChuckOutMode_M,
              ;SET ClampError_T,
	      RST CC_T

; Check to see if foot pedal is held down and enable output:
IF ChuckFootPedal && ChuckPD && ChuckOutMode_M THEN
	SET ChuckInSolOut,
	RST ChuckOutSolOut,
	SET ChuckFootReq_M,
	SET ChuckFootSwitch_T,
	RST CC_T,
	RST CU_T,
	SET ChuckInLED,
	RST ChuckOutLED

; Check to see if the foot pedal is stopped being pressed
; before the timer was raeached	
IF !ChuckFootPedal && ChuckFootReq_M && ChuckOutMode_M THEN
	RST ChuckInSolOut,
	SET ChuckOutSolOut,
	RST ChuckFootSwitch_T,
	RST ChuckFootReq_M,
	SET CU_T,
	RST ChuckInLED,
	SET ChuckOutLED

; If the pedal is still held down and timer expires, toggle states:	
IF ChuckFootPedal && ChuckFootSwitch_T && ChuckOutMode_M THEN
	RST ChuckOutSolOut, 
	RST ChuckInSolOut,
        SET ChuckInMode_M,
	RST ChuckOutMode_M,
        RST ChuckFootSwitch_T,
	SET ChuckInLED,
	RST ChuckOutLED,
	RST ChuckFootReq_M
   
;--------------------------- 
;   CHUCK_OUT_STAGE  
;  (Chuck Out State) 
;--------------------------- 
IF ((Aux9KeyPD) && !SpindleEnableOut && !SV_STOP && !SV_PROGRAM_RUNNING) 
	|| ((M11PD) && !SpindleEnableOut && !SV_STOP)
	THEN RST ChuckInSolOut, 
	SET ChuckOutSolOut,
	RST ChuckInMode_M,
	SET ChuckOutMode_M,		 
	SET CU_T,
	RST CC_T,
	RST ChuckInLED,
	SET ChuckOutLED,
	RST ChuckFootReq_M
	;RST ClampError_T
		 
; If the hydraulic pump is running then start the clamp error timer:		 
IF EstopOk THEN SET ClampError_T
IF !EstopOk THEN RST ClampError_T

IF CU_T then RST ChuckOutSolOut, 
	     RST ChuckInSolOut,
             RST ChuckInMode_M,
	     SET ChuckOutMode_M,
	     ;SET ClampError_T,
	     RST CU_T		   

; Check to see if foot pedal is held down and enable output:
IF ChuckFootPedal && ChuckPD && ChuckInMode_M THEN
	RST ChuckInSolOut,
	SET ChuckOutSolOut,
	SET ChuckFootReq_M,
	SET ChuckFootSwitch_T,
	RST CC_T,
	RST CU_T,
	RST ChuckInLED,
	SET ChuckOutLED

; Check to see if the foot pedal is stopped being pressed
; before the timer was raeached	
IF !ChuckFootPedal && ChuckFootReq_M && ChuckInMode_M THEN
	SET ChuckInSolOut,
	RST ChuckOutSolOut,
	RST ChuckFootSwitch_T,
	RST ChuckFootReq_M,
	SET CC_T,
	SET ChuckInLED,
	RST ChuckOutLED

; If the pedal is still held down and timer expires, toggle states:	
IF ChuckFootPedal && ChuckFootSwitch_T && ChuckInMode_M THEN
	RST ChuckOutSolOut, 
	RST ChuckInSolOut,
        RST ChuckInMode_M,
	SET ChuckOutMode_M,
        RST ChuckFootSwitch_T,
	RST ChuckInLED,
	SET ChuckOutLED,
	RST ChuckFootReq_M

; Ensure that if a stop is detected the Chuck will be shut down:
IF !EstopOk || SV_STOP THEN RST ChuckOutSolOut, RST ChuckInSolOut

;---------------------------
;  Chuck Errors:
;---------------------------

; Check to make sure that both chuck sensors are not on at the same time:
;IF ChuckInSensorMEM && ChuckOutSensorMEM;
;	THEN ErrorCode_W = CHUCK_SENSOR_ERROR, ; 1 + 256*123 "*** CHUCK SENSOR ERROR ***"
;	SET SetErrorStage, SET SV_STOP

; Check to see if we are in OD mode and reach the limit of travel:
;IF (ClampError_T && ChuckInSensorMEM && OD_MODE_M && ChuckInMode_M)
;	THEN ErrorCode_W = OD_CLAMP_ERROR,     ; 1 + 256*111 "OD Clamp Error"
;	SET SetErrorStage, SET SV_STOP

; Check to see if we are in ID mode and reach the limit of travel:
;IF (ClampError_T && ChuckOutSensorMEM && ID_MODE_M && ChuckOutMode_M)
;	THEN ErrorCode_W = ID_CLAMP_ERROR,     ; 1 + 256*112 "ID Clamp Error"
;	SET SetErrorStage, SET SV_STOP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Stop Conditions
; Reset all ATC Solenoids and Stages.
;
IF SV_STOP then 
   RST ATC_DirectionOut, 
   RST ATC_MotorEnableOut,
   RST DoingIndex_M, 
   RST Doing_M6, 
   RST ToolChangeDone_M, 
   RST ATC_START_STAGE,
   RST ATC_ROTATE_TO_TOOL_STAGE,
   RST ATC_ROTATE_STAGE,
   RST ATC_CLAMP_ON_STAGE,
   RST ATC_CLAMP_OFF_STAGE,
   RST ATC_WAIT_POSITION_STAGE,
   RST ATC_STOP_STAGE,
   RST ATC_DONE,
   RST ATC_FINISHED_STAGE,
   RST ATCRotateReq_M,
   RST M32Mem,
   RST M33Mem,
   RST M32,
   RST M33,
   RST TailOutTimerStage,
   RST RotateMax_T,
   RST REVERSE_T,
   RST CWCCWDelay_T

;--------------------------- 
   ATC_Main_Stage 
;--------------------------- 
IF M6 && !Doing_M6 THEN (M6PD) 
IF M6PD THEN SET Doing_M6, 
                 SET ATC_START_STAGE 
				 
IF ATC_Tool_1 then BinPosition_W = 1
IF ATC_Tool_2 then BinPosition_W = 2
IF ATC_Tool_3 then BinPosition_W = 3
IF ATC_Tool_4 then BinPosition_W = 4
IF ATC_Tool_5 then BinPosition_W = 5
IF ATC_Tool_6 then BinPosition_W = 6
IF ATC_Tool_7 then BinPosition_W = 7
IF ATC_Tool_8 then BinPosition_W = 8

IF !ATC_Tool_1 && !ATC_Tool_2 && !ATC_Tool_3 && !ATC_Tool_4 && !ATC_Tool_5 
	&& !ATC_Tool_6 && !ATC_Tool_7 && !ATC_Tool_8 && !Doing_M6 && !DoToolIndexStage 
	&& !ATCOverride_M && !DoingIndex_M
	THEN ErrorCode_W = TOOL_POSITION_FAULT, ;(1+256*106)
             SET SetErrorStage, SET SV_STOP

; Handle M13, M14 and M15 turret override m functions:	

;M13 Turret Rotate, will also unclamp first before rotating:		 
IF (M13 && ATCOverride_M && !DoingIndex_M) THEN (M13PD)
IF M13PD THEN SET DoToolIndexStage

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Tool Index Keys
;
;   
IF (ToolIndexKey && !SV_PROGRAM_RUNNING) 
   && !DoingIndex_M && !SV_STOP 
  then SET DoToolIndexStage 
   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Error Messages
; Check for errors before running
;   
if !M6 && Doing_M6 && !ToolChangeDone_M
   then ErrorCode_W = TOOL_CHANGE_CANCELLED, ;1 + 256*101, ; "TOOL CHANGE CANCELLED" 
        SET SetErrorStage, SET SV_STOP 
				 
IF !Doing_M6 && !(ATC_TOOL_LOCK ^ ToolLockNONC) && SV_Program_Running && !ATCOverride_M
  THEN ErrorCode_W = TURRET_LOCK_FAULT, ;(1+256*102)
       SET SetErrorStage, SET SV_STOP

;----------------------------- 
    DoToolIndexStage 
;----------------------------- 
if true then WantedBin_W = BinPosition_W + 1 
if WantedBin_W > MaxBins_W then WantedBin_W = 1 
if true then set DoingIndex_M, 
             jmp ATC_ROTATE_TO_TOOL_STAGE		 
   
;--------------------------- 
   ATC_START_STAGE 
;--------------------------- 
IF true THEN WantedBin_W = SV_TOOL_NUMBER
   
IF WantedBin_W < 1 || WantedBin_W > MaxBins_W 
   then ErrorCode_W = TOOL_REQUEST_INVALID, ;1 + 256*103, ; "TOOL REQUEST INVALID" 
        JMP SetErrorStage, SET SV_STOP 
   
IF (ErrorCode_W == 0 || ErrorCode_W == MSG_CLEARED_MSG) && WantedBin_W == BinPosition_W THEN JMP ATC_DONE
   
IF (ErrorCode_W == 0 || ErrorCode_W == MSG_CLEARED_MSG) && WantedBin_W != BinPosition_W THEN JMP ATC_ROTATE_TO_TOOL_STAGE

;-------------------- 
   ATC_ROTATE_TO_TOOL_STAGE
;-------------------- 
IF true THEN SET ATC_MotorEnableOut,
             RST ATC_DirectionOut,
             SET RotateMax_T 

if WantedBin_W == BinPosition_W THEN SET AtcDirRev_T
IF AtcDirRev_T && WantedBin_W == BinPosition_W THEN RST RotateMax_T, RST AtcDirRev_T, JMP ATC_STOP_STAGE
IF AtcDirRev_T && WantedBin_W != BinPosition_W THEN 
 	ErrorCode_W = TOOL_POSITION_FAULT, ;(1+256*106)
	SET SV_STOP,
 	RST RotateMax_T,
	RST AtcDirRev_T,
	JMP SetErrorStage

if RotateMax_T 
  then ErrorCode_W = ATC_TIMEOUT, ; 1 + 256*104  "ATC_TIMEOUT"  
  SET SV_STOP,
  RST RotateMax_T,
  RST AtcDirRev_T,
  JMP SetErrorStage

;-------------------- 
   ATC_STOP_STAGE        
;-------------------- 
IF TRUE THEN RST ATC_MotorEnableOut,
			 SET CWCCWDelay_T
            
IF CWCCWDelay_T then RST CWCCWDelay_T, JMP ATC_REVERSE_MOTOR
;-----------------------
    ATC_REVERSE_MOTOR
;-----------------------
if true then SET ATC_MotorEnableOut,
             SET ATC_DirectionOut,
             SET REVERSE_T

if REVERSE_T then RST REVERSE_T, JMP ATC_DONE
;-----------------------
    ATC_DONE
;-----------------------
if true then RST ATC_MotorEnableOut,
             RST ATC_DirectionOut,
             SET ToolChangeDone_M

if WantedBin_W != BinPosition_W 
  then ErrorCode_W = tool_change_cancelled, ; 1 + 256*101,  "TOOL CHANGE FAULT"  
       JMP SetErrorStage, SET SV_STOP

if (!M6 && Doing_M6) || (DoingIndex_M && !Doing_M6)
	THEN JMP ATC_FINISHED_STAGE 
		
;-----------------------
	ATC_FINISHED_STAGE
;-----------------------
if true then RST ToolChangeDone_M,
        RST Doing_M6,
        RST DoingIndex_M, 
        RST ATC_DONE,
		RST ATC_FINISHED_STAGE
;---------------------------
   TailStockStage
;---------------------------
			 
IF M32 THEN SET M32Mem
IF M33 THEN SET M33Mem, SET TailOutTimerStage
IF !M32 THEN RST M32Mem
;IF !M33 THEN RST M33Mem, RST TailOutTimerStage

if (((TailInKey) && !SV_PROGRAM_RUNNING) || M32Mem) && !SV_STOP
	then (TailStockIn), (Aux4LED)
	
if (((TailOutKey) && !SV_PROGRAM_RUNNING) || M33Mem) && !SV_STOP
	then (TailStockOut), (Aux5LED)

	
;-----------------------------
	TailOutTimerStage
;-----------------------------
IF TRUE THEN SET TailOut_T
IF !M33 THEN RST M33Mem, JMP TailStockStage, RST TailOut_T

IF TailOut_T THEN  
	RST M33, RST M33Mem, RST TailStockOut, Rst Aux5LED, JMP TailStockStage, RST TailOut_T
			 
;------------------------
   SetErrorStage
;------------------------
IF !((ErrorCode_W % 256 == 1) || (ErrorCode_W % 256 == 2)) THEN JMP BadErrorStage
IF true THEN MSG ErrorCode_W
If ErrorCode_W != MSG_CLEARED_MSG Then MsgClear_T = 1000, set MsgClear_T

IF (!EstopOk && !SoftwareReady_M) || ((ErrorCode_W != MSG_CLEARED_MSG) && (ErrorCode_W % 2 == 0) &&
  MsgClear_T) Then ErrorCode_W = MSG_CLEARED_MSG, rst MsgClear_T
  
IF SV_STALL_ERROR THEN (Echo_Stall_M)
IF SV_STOP THEN (Echo_Stop_M)

IF SV_MASTER_ENABLE THEN (MasterEnable_M)
IF !SV_STOP THEN (NoFaultOut)

;-----------------------
   BadErrorStage
;-----------------------
IF true THEN AsyncMsg_W = 2+256*100, MSG AsyncMsg_W, AsyncMsg_W = 0
IF true THEN rst BadErrorStage


