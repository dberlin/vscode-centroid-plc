;-------------------------------------------------------------------------------
; File:        Centroid-Mill-Standard-OAK-ACDC-ATC-Umbrella.src
; Programmer:  Scott Pratt, Marc Leonard, Lee Johnston
; Date:        2-DEC-2015
; Purpose:     PLC for OAK Board, ACDC drives and umbrella ATC
; Requires:    CNC11 v3.15+
;
; Mods:		25 JAN 2018 MML	Made the I/O follow the standard I/O list


; The OAK board includes connections for several types of auxiliary I/O.
; 4 digital "high speed" inputs (INP769-772) typically used for probe/TT1
; related functions, 3 auxiliary digital inputs (INP784-786), 11 Digital inputs
; used for MPG increment and axis selection and 2 auxiliary digital outputs
; (Out770-771).

; Inputs: The OAK provides 5, 16 bit analog inputs available on INP241-INP320.
; 16 digital inputs INP1-16 are available for general purpose use.  Inputs 1-16
; can be configured for 5, 12 or 24VDC operation in either a sourcing or 
; sinking configuration.

; Outputs: The OAK has 9 relay contact closure outputs.  Outputs 1-7
; are SPST type relays while Outputs 8 & 9 are SPDT type relays.
; Outputs 15 and 16 are for internal PLC hardware use only, being used to 
; set the mode of operation for the spindle analog output.

; Analog output: The 16 bit analog output on the OAK
; is mapped to outputs 241-256.

;------------------------------------------------------------------------------
;                        CONSTANT DEFINITIONS
;------------------------------------------------------------------------------
MIN_FROR_PCT                  IS 1   ; Minimum allowed feedrate override percentage
ASYNC_MSG_CLEAR               IS 2;(2+256*0)
PLC_EXECUTOR_FLT_MSG          IS 257;(1+256*1)
;spare                        IS 513;(1+256*2)
;spare                        IS 769;(1+256*3)
;spare                        IS 1025;(1+256*4)
AXIS1_INFLT                   IS 1282;(2+256*5) Fiber to MPU11 from axis drive has a problem
AXIS2_INFLT                   IS 1538;(2+256*6)
AXIS3_INFLT                   IS 1794;(2+256*7)
AXIS4_INFLT                   IS 2050;(2+256*8)
AXIS5_INFLT                   IS 2306;(2+256*9)
AXIS6_INFLT                   IS 2562;(2+256*10)
AXIS7_INFLT                   IS 2818;(2+256*11)
AXIS8_INFLT                   IS 3074;(2+256*12)
AXIS1_OUTFLT                  IS 3330;(2+256*13) Fiber to axis drive from MPU11 has a problem
AXIS2_OUTFLT                  IS 3586;(2+256*14)
AXIS3_OUTFLT                  IS 3842;(2+256*15)
AXIS4_OUTFLT                  IS 4098;(2+256*16)
AXIS5_OUTFLT                  IS 4354;(2+256*17)
AXIS6_OUTFLT                  IS 4610;(2+256*18)
AXIS7_OUTFLT                  IS 4866;(2+256*19)
AXIS8_OUTFLT                  IS 5122;(2+256*20)
AXIS_FLT_CLR                  IS 5378;(2+256*21)
PLC_INFLT                     IS 5634;(2+256*22)
PLC_OUTFLT                    IS 5890;(2+256*23)
PLC_FLT_CLR                   IS 6146;(2+256*24)
AXIS1_DRIVE_FAULT             IS 6401;(1+256*25)
AXIS2_DRIVE_FAULT             IS 6657;(1+256*26)
AXIS3_DRIVE_FAULT             IS 6913;(1+256*27)
AXIS4_DRIVE_FAULT             IS 7169;(1+256*28)
AXIS5_DRIVE_FAULT             IS 7425;(1+256*29)
SPINDLE_FAULT_MSG             IS 7681;(1+256*30)
JOGBOARD_INFLT                IS 7937;(1+256*31)
JOGBOARD_OUTFLT               IS 8193;(1+256*32)
TOOL_COUNTER_TIME_OUT_FAULT   IS 8449;(1+256*33)                              
PROBE_FAULT_MSG               IS 8705;(1+256*34)
KB_JOG_MSG                    IS 8962;(2+256*35)
LUBE_FAULT_MSG                IS 9217;(1+256*36)
PROBE_JOG_TRIP_MSG            IS 9474;(2+256*37)
MIN_SPEED_MSG                 IS 9730;(2+256*38)
SOFTWARE_EXIT_MSG             IS 9985;(1+256*39)
CAR_IN_TIME_OUT_FAULT         IS 10241;(1+256*40)
CAR_OUT_TIME_OUT_FAULT        IS 10497;(1+256*41)
TOOL_COUNTER_NOISE_FAULT      IS 10753;(1+256*42) 
INVALID_TOOL_NUMBER_FAULT     IS 11009;(1+256*43)
AIR_PRESSURE_LOW_FAULT        IS 11265;(1+256*44)
ATC_WHILE_MANUAL_INDEX        IS 11522;(2+256*45
MANUAL_INDEX_WHILE_ATC        IS 11778;(2+256*46)
CAROUSEL_IN_OUT_TIME_OUT      IS 12033;(1+256*47)
ORIENT_TIMEOUT                IS 12289;(1+256*48)
;
AUTO_COOL_MSG                 IS 12802;(2+256*50)
MAN_COOL_MSG                  IS 13058;(2+256*51)
LUBE_WARNING_MSG              IS 13314;(2+256*52)
AUTO_SPINDLE_PROMPT           IS 13570;(2+256*53)
AUTO_COOLANT_PROMPT           IS 13826;(2+256*54)
TOOL_CLAMP_UNCLAMP_FAULT      IS 14081;(1+256*55)
ORIENT_LOST_FAULT             IS 14337;(1+256*56)
LOW_AIR_FAULT                 IS 14593;(1+256*57)
;spare                        IS 14849;(1+256*58)
;spare                        IS 15105;(1+256*59)
;spare                        IS 15361;(1+256*60)
MINI_PLC_1_FLT_MSG            IS 15617;(1+256*61)
MINI_PLC_2_FLT_MSG            IS 15873;(1+256*62)
MINI_PLC_3_FLT_MSG            IS 16129;(1+256*63)
MINI_PLC_4_FLT_MSG            IS 16385;(1+256*64)
MINI_PLC_5_FLT_MSG            IS 16641;(1+256*65)
MINI_PLC_6_FLT_MSG            IS 16897;(1+256*66)
MINI_PLC_7_FLT_MSG            IS 17153;(1+256*67)
MINI_PLC_8_FLT_MSG            IS 17409;(1+256*68)
;spare                        IS 17665;(1+256*69)
STALL_POS_ERROR_FAULT         IS 17921;(1+256*70)
STALL_FPWM_FAULT              IS 18177;(1+256*71)
STALL_ENC_DIFF_FAULT          IS 18177;(1+256*72)
STALL_ENC_QUAD_FAULT          IS 18433;(1+256*73)
STALL_SPIN_SLAVE_FAULT        IS 18689;(1+256*74)
STALL_SCALE_DIFF_FAULT        IS 18945;(1+256*75)
STALL_SCALE_QUAD_FAULT        IS 19202;(2+256*76)
STALL_MASTER_ENABLE_OFF_FAULT IS 19258;(2+256*77)
;spare                        IS 19458;(2+256*78)
;spare                        IS 19714;(2+256*79)
CNC11_STALL_AXIS_1_REPORTED   IS 19970;(2+256*80)
CNC11_STALL_AXIS_2_REPORTED   IS 20226;(2+256*81)
CNC11_STALL_AXIS_3_REPORTED   IS 20482;(2+256*82)
CNC11_STALL_AXIS_4_REPORTED   IS 20738;(2+256*83)
CAROUSEL_POSITION_AT_PUTBACK  IS 20994;(2+256*84)
SV_TOOL_AT_PUTBACK            IS 21250;(2+256*85)
REQ_TOOL_AT_PUTBACK           IS 21506;(2+256*86)
PUTBACK_LOC_AT_PUTBACK        IS 21250;(2+256*87)
;spare                        IS 21762;(2+256*88)
;spare                        IS 22018;(2+256*89)
                              
MSG_CLEARED_MSG               IS 25345;(1+256*99)
BAD_MESSAGE_MSG               IS 25602;(2+256*100)
                              
MINI_PLC_1_WARNING            IS 41218;(2+256*161)
MINI_PLC_2_WARNING            IS 41474;(2+256*162)
MINI_PLC_3_WARNING            IS 41730;(2+256*163)
MINI_PLC_4_WARNING            IS 41986;(2+256*164)
MINI_PLC_5_WARNING            IS 42242;(2+256*165)
MINI_PLC_6_WARNING            IS 42498;(2+256*166)
MINI_PLC_7_WARNING            IS 42754;(2+256*167)
MINI_PLC_8_WARNING            IS 43010;(2+256*168)

;------------------------------------------------------------------------------
;                         OAK INPUT DEFINITIONS
;                   Closed = 1 (green)  Open = 0 (red)
;------------------------------------------------------------------------------  
Ax1_MinusLimitOk              IS INP1
Ax1_PlusLimitOk               IS INP2
Ax2_MinusLimitOk              IS INP3
Ax2_PlusLimitOk               IS INP4
Ax3_MinusLimitOk              IS INP5
Ax3_PlusLimitOk               IS INP6
;spare                        IS INP7
;spare                        IS INP8
LubeOk                        IS INP9  ;Lube is "ok" when input is closed      (*)
SpindleInverterOk             IS INP10 ;Inverter is "ok" when input is closed  (*)
EStopOk                       IS INP11
ZeroSpeed                     IS INP12
SpinLowRange                  IS INP13
;spare                        IS INP14
;spare                        IS INP15
;spare                        IS INP16

;If a PLC expansion board (PLCADD1616) is used, the additional inputs will
;begin at input 17.

OrientComplete                IS INP17;1
AirPressureOk                 IS INP18;2
;spare                        IS INP19;3
;spare                        IS INP20;4
ToolClamped                   IS INP21;5
ToolUnclamped                 IS INP22;6
ToolRelease                   IS INP23;7
ToolCounter                   IS INP24;8
;spare                        IS INP25;9
;spare                        IS INP26;10
;spare                        IS INP27;11
CarouselAtHome                IS INP28;12
;spare                        IS INP29;13
;spare                        IS INP30;14
CarouselIsOut                 IS INP31;15
CarouselIsIn                  IS INP32;16


AnalogInput1                  IS INP241; 16 bit. Read on INP241-256
AnalogInput2                  IS INP257; 16 bit. Read on INP257-272
AnalogInput3                  IS INP273; 16 bit. Read on INP273-288
AnalogInput4                  IS INP292; 16 bit. Read on INP289-304
AnalogInput5                  IS INP308; 16 bit. Read on INP305-320
 


;------------------------------------------------------------------------------
; INP769 - INP784 encompass the OAK onboard H13 and H19 input connections
; which are generally used for MPG and probing functions.
; Stadard mapping is below.
;------------------------------------------------------------------------------
MechanicalProbe               IS INP769
DSPProbe                      IS INP770
ProbeDetect                   IS INP771
ProbeAux                      IS INP772
MPG_Inc_X_1                   IS INP773
MPG_Inc_X_10                  IS INP774
MPG_Inc_X_100                 IS INP775
MPG_AXIS_1                    IS INP776
MPG_AXIS_2                    IS INP777
MPG_AXIS_3                    IS INP778
MPG_AXIS_4                    IS INP779
MPG_AXIS_5                    IS INP780
MPG_AXIS_6                    IS INP781
MPG_AXIS_7                    IS INP782
MPG_AXIS_8                    IS INP783

;------------------------------------------------------------------------------
;                 OAK PLC Output Definitions
;       Logic 1 = OUTPUT ON (Green), 0 = OUTPUT OFF (Red)
;       Note: Outputs 10 through 14 are physically unavailable
;------------------------------------------------------------------------------
NoFaultOut                    IS OUT1  ;SPST Type
Lube                          IS OUT2  ;SPST Type
Flood                         IS OUT3  ;SPST Type
Mist                          IS OUT4  ;SPST Type
InverterResetOut              IS OUT5  ;SPST Type
WorkLightOut                  IS OUT6  ;SPST Type
SpindleEnableOut              IS OUT7  ;SPST Type
SpindleDirectionOut           IS OUT8  ;SPDT Type
ZBrakeRelease                 IS OUT9  ;SPDT Type
SpindleDACModeBit1            IS OUT15 ;SPST Type
SpindleDACModeBit2            IS OUT16 ;SPDT Type

;If a PLC expansion board (PLCADD1616) is used, the additional inputs will
;begin at output 17.

OrientRequest                 IS OUT17 ;SPST Type;1
;spare                        IS OUT18 ;SPST Type;2
SpindleFan                    IS OUT19 ;SPST Type;3
;spare		                  IS OUT20 ;SPST Type;4
;spare		                  IS OUT21 ;SPST Type;5
ToolUnclampOut                IS OUT22 ;SPST Type;6
CarouselEnable                IS OUT23 ;SPST Type;7
CarouselCCW                   IS OUT24 ;SPDT Type;8
;spare                        IS OUT25 ;SPDT Type;9
AirBlow                       IS OUT26 ;SPST Type;10
;spare                        IS OUT27 ;SPST Type;11
;spare                        IS OUT28 ;SPST Type;12
;spare                        IS OUT29 ;SPST Type;13
;spare		                  IS OUT30 ;SPST Type;14
CarouselInSol                 IS OUT31 ;SPST Type;15
CarouselOutSol                IS OUT32 ;SPDT Type;16

; The following bits control the actual analog hardware output on the OAK.
; Output = 16bit (0-65536) Default 0-10VDC.
; Different analog ranges are available by setting Outputs 15 and 16:
; ----------------------------------------
; | Output 15 | Output 16 | Range         |
; |     0     |     0     | 0 to +10VDC   |
; |     0     |     1     | 0 to +5VDC    |
; |     1     |     0     | -5 to +5VDC   |
; |     1     |     1     | -10 to +10VDC | 
; -----------------------------------------

SpinAnalogOutBit0             IS OUT241
SpinAnalogOutBit1             IS OUT242
SpinAnalogOutBit2             IS OUT243
SpinAnalogOutBit3             IS OUT244
SpinAnalogOutBit4             IS OUT245
SpinAnalogOutBit5             IS OUT246
SpinAnalogOutBit6             IS OUT247
SpinAnalogOutBit7             IS OUT248
SpinAnalogOutBit8             IS OUT249
SpinAnalogOutBit9             IS OUT250
SpinAnalogOutBit10            IS OUT251
SpinAnalogOutBit11            IS OUT252
SpinAnalogOutBit12            IS OUT253
SpinAnalogOutBit13            IS OUT254
SpinAnalogOutBit14            IS OUT255
SpinAnalogOutBit15            IS OUT256
                              
MPG_LED_OUT                   IS OUT769

;----------------------------------------------------------------
;                        Memory Bit Definitions
;----------------------------------------------------------------
PLCExecutorFault_M            IS MEM1
SoftwareNotReady_M            IS MEM2   ; 0 = okay, 1 = CNC11 not running/ready
DoingM6_M                     IS MEM3 
DoingIndex_M                  IS MEM4 
DoingIndexMinus_M             IS MEM5
DoingIndexPlus_M              IS MEM6
AtPutbackLocation_M           IS MEM7 
ToolChangeComplete_M          IS MEM8
UnclampingTool_M              IS MEM9
MovingCarouselIn_M            IS MEM10
MovingCarouselOut_M           IS MEM11
MonitorOrient_M               IS MEM12
ToolCounterArmed_M            IS MEM13
AtRequestedToolLocation_M     IS MEM14
CarouselReversed_M            IS MEM15
CarouselHomeComplete_M        IS MEM16 
WaitingForPutbackComplete_M   IS MEM17 
DoingM18_M                    IS MEM18
DoingPutback_M                IS MEM19 
WTF_M                         IS MEM20     

AC1Drive1FatalError_M         IS MEM21
AC1Drive2FatalError_M         IS MEM22
AC1Drive3FatalError_M         IS MEM23
AC1Drive4FatalError_M         IS MEM24
AC1Drive5FatalError_M         IS MEM25
AC1Drive6FatalError_M         IS MEM26
AC1Drive7FatalError_M         IS MEM27
AC1Drive8FatalError_M         IS MEM28   
AC1FatalError_M               IS MEM29
  
                              
Ax1PlusJogDisabled_M          IS MEM31
Ax1MinusJogDisabled_M         IS MEM32
Ax2PlusJogDisabled_M          IS MEM33
Ax2MinusJogDisabled_M         IS MEM34
Ax3MinusJogDisabled_M         IS MEM35
Axis1DriveOk                  IS MEM36
Axis2DriveOk                  IS MEM37
Axis3DriveOk                  IS MEM38
Axis4DriveOk                  IS MEM39
MasterEnable_M                IS MEM40  ; 1 = enabled (echo of SV_MASTER_ENABLE)
PLCBus_Oe_M                   IS MEM41  ; 1 = okay, 0 = incoming PLC fiber problem
PLCBusExtDevEn_M              IS MEM42  ; 1 = okay, 0 = PLC reports bad output fiber
JogLinkOk_M                   IS MEM43  ; 1 = okay, 0 = incoming jog panel data problem
JogPanelOnline_M              IS MEM44  ; 1 = okay, 0 = JogBoard reports bad connection
ActivateFeedHold_M            IS MEM45  ; 0 = idle, 1 = trigger feed hold on
ErrorFlag_M                   IS MEM46  ; 0 = okay, 1 = error (but not a fault)
Stop_M                        IS MEM47  ; 0 = okay, 1 = fault (echo of SV_STOP)
Stall_M                       IS MEM48  ; 0 = okay, 1 = stall (echo of SV_STALL_ERROR)
LubeFault_M                   IS MEM49  ; 0 = okay, 1 = lube fault
PLCFault_M                    IS MEM50  ; 0 = okay, 1 = PLC fault
AxisFault_M                   IS MEM51  ; 0 = okay, 1 = drive or drive fiber problem
DriveComFltIn_M               IS MEM52  ; 0 = okay, 1 = incoming drive fiber problem
DriveComFltOut_M              IS MEM53  ; 0 = okay, 1 = outgoing drive fiber problem
ProbeFault_M                  IS MEM54  ; 0 = okay, 1 = tried to start spindle w/probe
JogProbeFault_M               IS MEM55  ; 0 = okay, 1 = tripped probe while jogging
SpindleFault_M                IS MEM56  ; 0 = okay, 1 = spindle drive fault
OtherFault_M                  IS MEM57
MPGManOffFlag_M               IS MEM58
BelowMinSpeed_M               IS MEM59
KbJpActive_M                  IS MEM60 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
Axis1Fault_M                  IS MEM61
Axis2Fault_M                  IS MEM62
Axis3Fault_M                  IS MEM63
Axis4Fault_M                  IS MEM64
Axis5Fault_M                  IS MEM65
                              
Axis1FiberOk_M                IS MEM70
Axis2FiberOk_M                IS MEM71
Axis3FiberOk_M                IS MEM72
Axis4FiberOk_M                IS MEM73
Axis5FiberOk_M                IS MEM74
Axis6FiberOk_M                IS MEM75
Axis7FiberOk_M                IS MEM76
Axis8FiberOk_M                IS MEM77
                              
ProbeMsgSent_M                IS MEM78
True                          IS MEM81
SpinRangeReversed_M           IS MEM82
SpindleDirection_M            IS MEM83
SpindlePause_M                IS MEM84
LimitTripped_M                IS MEM85
SpinStart_M                   IS MEM86
SpinStop_M                    IS MEM87
                              
DisableKbInput_M              IS MEM101 ;If 1, disable kb jogging
AllowKbInput_M                IS MEM102 ;If 1, allow kb jogging
JogOverOnly_M                 IS MEM103
KbOverOnly_M                  IS MEM104
UsingFeedrateKnob_M           IS MEM105
WaitingForSleepTimer_M        IS MEM106
JogPanelRequired_M            IS MEM107
                              
X1_M                          IS MEM111
X10_M                         IS MEM112
X100_M                        IS MEM113
                              
MiniPLCOk1_M                  IS MEM121
MiniPLCOk2_M                  IS MEM122
MiniPLCOk3_M                  IS MEM123
MiniPLCOk4_M                  IS MEM124
MiniPLCOk5_M                  IS MEM125
MiniPLCOk6_M                  IS MEM126
MiniPLCOk7_M                  IS MEM127
MiniPLCOk8_M                  IS MEM128
                              
MiniPLCExpected1_M            IS MEM137
MiniPLCExpected2_M            IS MEM138
MiniPLCExpected3_M            IS MEM139
MiniPLCExpected4_M            IS MEM140
MiniPLCExpected5_M            IS MEM141
MiniPLCExpected6_M            IS MEM142
MiniPLCExpected7_M            IS MEM143
MiniPLCExpected8_M            IS MEM144
                              
OnAtPowerUp_M                 IS MEM200
LastProbeMode_M               IS MEM210
JogModeSaved_M                IS MEM211
                              
KbCycleStart_M                IS MEM400 ; "alt" + "s"
KbCycleCancel_M               IS MEM401 ; escape
KbToolCheck_M                 IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M            IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M            IS MEM404 ; "Insert"
KbDecreaseJogInc_M            IS MEM405 ; "Delete"
KbIncFeedOver_M               IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M               IS MEM407 ; "ctrl" + "keyboard "-"
KbFeedOver100_M               IS MEM408 ; "ctrl" + "\"
KbTogIncContJog_M             IS MEM409 ; "ctrl" + "i"
KbTogFastSlowJog_M            IS MEM410 ; "ctrl" + "f"
KbJogAx1Plus_M                IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M               IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M                IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M               IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M                IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M               IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M                IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M               IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M                   IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M                   IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M                   IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M                   IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M                   IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M                   IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M                   IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M                   IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M                   IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M                  IS MEM428 ; "ctrl" + "F10"
KbAux11Key_M                  IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M                  IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M              IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M            IS MEM432 ; "ctrl" + "a"
KbSpinCW_M                    IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M                   IS MEM434 ; "ctrl" + "w"
KbSpinStart_M                 IS MEM435 ; "ctrl" + "s"
KbSpinStop_M                  IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M                IS MEM437 ; "ctrl" + "n"
KbMistOnOff_M                 IS MEM438 ; "ctrl" + "k"
KbTogCoolAutoMan_M            IS MEM439 ; "ctrl" + "m"
KbFeedHold_M                  IS MEM440 ; space bar
KbIncSpinOver_M               IS MEM441 ; "ctrl" + ">" (.)
KbDecSpinOver_M               IS MEM442 ; "ctrl" + "<" (,)
KbSpinOver100_M               IS MEM443 ; "ctrl" + "?" (/)
                              
Axis1StatusBit0               IS MEM500
Axis1StatusBit1               IS MEM501
Axis1StatusBit2               IS MEM502
Axis1StatusBit3               IS MEM503
Axis1StatusTP                 IS MEM504
Axis1StatusALM3               IS MEM505
Axis1StatusALM2               IS MEM506
Axis1StatusALM1               IS MEM507
Axis1StatusTGON               IS MEM508
Axis1StatusBRAKE              IS MEM509
Axis1StatusSRDY               IS MEM510
Axis1StatusQUADERR            IS MEM511
Axis1StatusDIR                IS MEM512
Axis1StatusZ                  IS MEM513
Axis1StatusDIFF_ERR           IS MEM514
Axis1DriveALM                 IS MEM515
                              
Axis2StatusBit0               IS MEM516
Axis2StatusBit1               IS MEM517
Axis2StatusBit2               IS MEM518
Axis2StatusBit3               IS MEM519
Axis2StatusTP                 IS MEM520
Axis2StatusALM3               IS MEM521
Axis2StatusALM2               IS MEM522
Axis2StatusALM1               IS MEM523
Axis2StatusTGON               IS MEM524
Axis2StatusBRAKE              IS MEM525
Axis2StatusSRDY               IS MEM526
Axis2StatusQUADERR            IS MEM527
Axis2StatusDIR                IS MEM528
Axis2StatusZ                  IS MEM529
Axis2StatusDIFF_ERR           IS MEM530
Axis2DriveALM                 IS MEM531
                              
Axis3StatusBit0               IS MEM532
Axis3StatusBit1               IS MEM533
Axis3StatusBit2               IS MEM534
Axis3StatusBit3               IS MEM535
Axis3StatusTP                 IS MEM536
Axis3StatusALM3               IS MEM537
Axis3StatusALM2               IS MEM538
Axis3StatusALM1               IS MEM539
Axis3StatusTGON               IS MEM540
Axis3StatusBRAKE              IS MEM541
Axis3StatusSRDY               IS MEM542
Axis3StatusQUADERR            IS MEM543
Axis3StatusDIR                IS MEM544
Axis3StatusZ                  IS MEM545
Axis3StatusDIFF_ERR           IS MEM546
Axis3DriveALM                 IS MEM547
                              
Axis4StatusBit0               IS MEM548
Axis4StatusBit1               IS MEM549
Axis4StatusBit2               IS MEM550
Axis4StatusBit3               IS MEM551
Axis4StatusTP                 IS MEM552
Axis4StatusALM3               IS MEM553
Axis4StatusALM2               IS MEM554
Axis4StatusALM1               IS MEM555
Axis4StatusTGON               IS MEM556
Axis4StatusBRAKE              IS MEM557
Axis4StatusSRDY               IS MEM558
Axis4StatusQUADERR            IS MEM559
Axis4StatusDIR                IS MEM560
Axis4StatusZ                  IS MEM561
Axis4StatusDIFF_ERR           IS MEM562
Axis4DriveALM                 IS MEM563
                              
Axis5StatusBit0               IS MEM564
Axis5StatusBit1               IS MEM565
Axis5StatusBit2               IS MEM566
Axis5StatusBit3               IS MEM567
Axis5StatusTP                 IS MEM568
Axis5StatusALM3               IS MEM569
Axis5StatusALM2               IS MEM570
Axis5StatusALM1               IS MEM571
Axis5StatusTGON               IS MEM572
Axis5StatusBRAKE              IS MEM573
Axis5StatusSRDY               IS MEM574
Axis5StatusQUADERR            IS MEM575
Axis5StatusDIR                IS MEM576
Axis5StatusZ                  IS MEM577
Axis5StatusDIFF_ERR           IS MEM578
Axis5DriveALM                 IS MEM579

;----------------------------------------------------------------
; Jog panel keys are referenced as JPI1 through JPI256. Alternatively,
; jog panel inputs can also be referenced as INP1057-INP1312.
;----------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey       IS JPI1  ; Row  1 Column 1
SpinAutoManKey        IS JPI2  ; Row  1 Column 2
Aux1Key               IS JPI3  ; Row  1 Column 3
Aux2Key               IS JPI4  ; Row  1 Column 4
Aux3Key               IS JPI5  ; Row  1 Column 5

SpinOver100Key        IS JPI6  ; Row  2 Column 1
SpinCWKey             IS JPI7  ; Row  2 Column 2
Aux4Key               IS JPI8  ; Row  2 Column 3
Aux5Key               IS JPI9  ; Row  2 Column 4
Aux6Key               IS JPI10 ; Row  2 Column 5

SpinOverMinusKey      IS JPI11 ; Row  3 Column 1
SpinCCWKey            IS JPI12 ; Row  3 Column 2
Aux7Key               IS JPI13 ; Row  3 Column 3
Aux8Key               IS JPI14 ; Row  3 Column 4
Aux9Key               IS JPI15 ; Row  3 Column 5

SpinStopKey           IS JPI16 ; Row  4 Column 1
SpinStartKey          IS JPI17 ; Row  4 Column 2
Aux10Key              IS JPI18 ; Row  4 Column 3
Aux11Key              IS JPI19 ; Row  4 Column 4
Aux12Key              IS JPI20 ; Row  4 Column 5

CoolAutoManKey        IS JPI21 ; Row  5 Column 1
CoolFloodKey          IS JPI22 ; Row  5 Column 2
CoolMistKey           IS JPI23 ; Row  5 Column 3
Aux13Key              IS JPI24 ; Row  5 Column 4
AtcOverrideKey        IS JPI25 ; Row  5 Column 5

IncrContKey           IS JPI26  ; Row  6 Column 1
x1JogKey              IS JPI27  ; Row  6 Column 2
x10JogKey             IS JPI28  ; Row  6 Column 3
x100JogKey            IS JPI29  ; Row  6 Column 4
MPGKey                IS JPI30  ; Row  6 Column 5

Ax4PlusJogKey         IS JPI31  ; Row  7 Column 1
UnusedR7C2Key         IS JPI32  ; Row  7 Column 2
Ax2PlusJogKey         IS JPI33  ; Row  7 Column 3
UnusedR7C4Key         IS JPI34  ; Row  7 Column 4
Ax3PlusJogKey         IS JPI35  ; Row  7 Column 5

UnusedR8C1Key         IS JPI36  ; Row  8 Column 1
Ax1MinusJogKey        IS JPI37  ; Row  8 Column 2
FastSlowKey           IS JPI38  ; Row  8 Column 3
Ax1PlusJogKey         IS JPI39  ; Row  8 Column 4
UnusedR8C5Key         IS JPI40  ; Row  8 Column 5

Ax4MinusJogKey        IS JPI41  ; Row  9 Column 1
UnusedR9C2Key         IS JPI42  ; Row  9 Column 2
Ax2MinusJogKey        IS JPI43  ; Row  9 Column 3
UnusedR9C4Key         IS JPI44  ; Row  9 Column 4
Ax3MinusJogKey        IS JPI45  ; Row  9 Column 5

CycleCancelKey        IS JPI46  ; Row 10 Column 1
SingleBlockKey        IS JPI47  ; Row 10 Column 2
ToolCheckKey          IS JPI48  ; Row 10 Column 3
FeedHoldKey           IS JPI49  ; Row 10 Column 4
CycleStartKey         IS JPI50  ; Row 10 Column 5

;----------------------------------------------------------------
;                    Feedrate Override Knob
;----------------------------------------------------------------
JpFeedOrKnobBit0      IS JPI193
JpFeedOrKnobBit1      IS JPI194
JpFeedOrKnobBit2      IS JPI195
JpFeedOrKnobBit3      IS JPI196
JpFeedOrKnobBit4      IS JPI197
JpFeedOrKnobBit5      IS JPI198
JpFeedOrKnobBit6      IS JPI199
JpFeedOrKnobBit7      IS JPI200
JpFeedOrKnobBit8      IS JPI201 ; Current jog panels send first 8 bits
JpFeedOrKnobBit9      IS JPI202 ; unused
JpFeedOrKnobBit10     IS JPI203 ; unused
JpFeedOrKnobBit11     IS JPI204 ; unused
JpFeedOrKnobBit12     IS JPI205 ; unused
JpFeedOrKnobBit13     IS JPI206 ; unused
JpFeedOrKnobBit14     IS JPI207 ; unused
JpFeedOrKnobBit15     IS JPI208 ; unused

;----------------------------------------------------------------
;              Jog Panel Output (LED) Definitions
;       Jog Panel LED's can be addressed as JPO1 - JPO256
;                              OR
;                       OUT1057 - OUT1312
;----------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right
;
SpinOverPlusLED       IS JPO1  ; Row  1 Column 1
SpinAutoModeLED       IS JPO2  ; Row  1 Column 2
Aux1LED               IS JPO3  ; Row  1 Column 3
Aux2LED               IS JPO4  ; Row  1 Column 4
Aux3LED               IS JPO5  ; Row  1 Column 5

SpinOver100LED        IS JPO6  ; Row  2 Column 1
SpindleCWLED          IS JPO7  ; Row  2 Column 2
Aux4LED               IS JPO8  ; Row  2 Column 3
Aux5LED               IS JPO9  ; Row  2 Column 4
Aux6LED               IS JPO10 ; Row  2 Column 5

SpinOverMinusLED      IS JPO11 ; Row  3 Column 1
SpindleCCWLED         IS JPO12 ; Row  3 Column 2
Aux7LED               IS JPO13 ; Row  3 Column 3
Aux8LED               IS JPO14 ; Row  3 Column 4
Aux9LED               IS JPO15 ; Row  3 Column 5

SpinStopLED           IS JPO16 ; Row  4 Column 1
SpinStartLED          IS JPO17 ; Row  4 Column 2
Aux10LED              IS JPO18 ; Row  4 Column 3
Aux11LED              IS JPO19 ; Row  4 Column 4
Aux12LED              IS JPO20 ; Row  4 Column 5

CoolAutoModeLED       IS JPO21 ; Row  5 Column 1
CoolFloodLED          IS JPO22 ; Row  5 Column 2
CoolMistLED           IS JPO23 ; Row  5 Column 3
Aux13LED              IS JPO24 ; Row  5 Column 4
Aux14LED              IS JPO25 ; Row  5 Column 5

IncrContLED           IS JPO26  ; Row  6 Column 1
x1JogLED              IS JPO27  ; Row  6 Column 2
x10JogLED             IS JPO28  ; Row  6 Column 3
x100JogLED            IS JPO29  ; Row  6 Column 4
MPGLED                IS JPO30  ; Row  6 Column 5

Ax4PlusJogLED         IS JPO31  ; Row  7 Column 1
UnusedR7C2LED         IS JPO32  ; Row  7 Column 2
Ax2PlusJogLED         IS JPO33  ; Row  7 Column 3
UnusedR7C4LED         IS JPO34  ; Row  7 Column 4
Ax3PlusJogLED         IS JPO35  ; Row  7 Column 5

UnusedR8C1LED         IS JPO36  ; Row  8 Column 1
Ax1MinusJogLED        IS JPO37  ; Row  8 Column 2
FastSlowLED           IS JPO38  ; Row  8 Column 3
Ax1PlusJogLED         IS JPO39  ; Row  8 Column 4
UnusedR8C5LED         IS JPO40  ; Row  8 Column 5

Ax4MinusJogLED        IS JPO41  ; Row  9 Column 1
UnusedR9C2LED         IS JPO42  ; Row  9 Column 2
Ax2MinusJogLED        IS JPO43  ; Row  9 Column 3
UnusedR9C4LED         IS JPO44  ; Row  9 Column 4
Ax3MinusJogLED        IS JPO45  ; Row  9 Column 5

CycleCancelLED        IS JPO46  ; Row 10 Column 1
SingleBlockLED        IS JPO47  ; Row 10 Column 2
; FOR JOGBRD REV??????, the LED outputs do not match Key inputs
; The PLC program should activate all three of these when
; it wants to turn on FeedHoldLED so that future hardware changes
; to put them in the same order as their corresponding inputs will work.
ToolCheckLED          IS JPO50  ; Row 10 Column 3
FeedHoldLED           IS JPO48  ; Row 10 Column 4
CycleStartLED         IS JPO49  ; Row 10 Column 5

;-------------------------------------------------------------------------------
;                     ---------SYSTEM VARIABLES--------
;
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;-------------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional reponsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibilty of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel keypress to a specific function.  Pressing a jog key or Aux key
; won't DO anything unless the PLC assigns an action to the keypress.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                        ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape keypress event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the keypress is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "SET" KbCycleCancel_M anytime the escape key is pressed.
;    IF Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancel key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING
;      THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_0 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_0 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Keypress: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times------------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 0-15 (Selection 0)
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                    Debounce Time Selection #1
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                      Debounce Time Selection #3
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the charactersitics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 & INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is set as follows:

; Five new operators have been introduced to simplify bit operations:
; BITSET, BITRST, BITTST, LSHIFT & RSHIFT.  Below we will use BITSET to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; BITSET and BITRST can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use BITSET and
; BITRST to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; InputsConfig_W IS W1
; use BITSET or BITRST
; if 1 == 1 THEN BITSET InputsConfig_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; IF 1 == 1 THEN SV_PLC_DEBOUNCE_3 = InputsConfig_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp4 = bits 31-24        Inp3 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp2 = bits 15-8       Inp1 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Invert(bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, set the both invert AND force bits
;   for the input.

;-------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/set in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.
;-----------------------------------------------------------------------------


;----------------------------------------------------------------
;  System variables:  Jog Panel Functions
;----------------------------------------------------------------
; Jog panel functions
;Invalid              IS SV_PLC_FUNCTION_0
DoCycleCancel         IS SV_PLC_FUNCTION_1
DoCycleStart          IS SV_PLC_FUNCTION_2
DoToolCheck           IS SV_PLC_FUNCTION_3
SelectSingleBlock     IS SV_PLC_FUNCTION_4
SelectX1JogInc        IS SV_PLC_FUNCTION_5
SelectX10JogInc       IS SV_PLC_FUNCTION_6
SelectX100JogInc      IS SV_PLC_FUNCTION_7
SelectUserJogInc      IS SV_PLC_FUNCTION_8
SelectIncContJog      IS SV_PLC_FUNCTION_9
SelectFastSlowJog     IS SV_PLC_FUNCTION_10
SelectMpgMode         IS SV_PLC_FUNCTION_11
DoAx1PlusJog          IS SV_PLC_FUNCTION_12
DoAx1MinusJog         IS SV_PLC_FUNCTION_13
DoAx2PlusJog          IS SV_PLC_FUNCTION_14
DoAx2MinusJog         IS SV_PLC_FUNCTION_15
DoAx3PlusJog          IS SV_PLC_FUNCTION_16
DoAx3MinusJog         IS SV_PLC_FUNCTION_17
DoAx4PlusJog          IS SV_PLC_FUNCTION_18
DoAx4MinusJog         IS SV_PLC_FUNCTION_19
DoAx5PlusJog          IS SV_PLC_FUNCTION_20
DoAx5MinusJog         IS SV_PLC_FUNCTION_21
DoAx6PlusJog          IS SV_PLC_FUNCTION_22
DoAx6MinusJog         IS SV_PLC_FUNCTION_23
DoAux1Key             IS SV_PLC_FUNCTION_24
DoAux2Key             IS SV_PLC_FUNCTION_25
DoAux3Key             IS SV_PLC_FUNCTION_26
DoAux4Key             IS SV_PLC_FUNCTION_27
DoAux5Key             IS SV_PLC_FUNCTION_28
DoAux6Key             IS SV_PLC_FUNCTION_29
DoAux7Key             IS SV_PLC_FUNCTION_30
DoAux8Key             IS SV_PLC_FUNCTION_31
DoAux9Key             IS SV_PLC_FUNCTION_32
DoAux10Key            IS SV_PLC_FUNCTION_33
SelectRapidOverride   IS SV_PLC_FUNCTION_34
SelectManAutoSpindle  IS SV_PLC_FUNCTION_35
DoSpindleStart        IS SV_PLC_FUNCTION_37
DoSpindleStop         IS SV_PLC_FUNCTION_38
DoAux11Key            IS SV_PLC_FUNCTION_39
DoAux12Key            IS SV_PLC_FUNCTION_40
;SelectCoolantMan     IS SV_PLC_FUNCTION_41 ;deprecated
;SelectCoolantAuto    IS SV_PLC_FUNCTION_42 ;deprecated
SelectCoolantFlood    IS SV_PLC_FUNCTION_43
SelectCoolantMist     IS SV_PLC_FUNCTION_44
DoFeedHold            IS SV_PLC_FUNCTION_45
SelectSpindleCCW      IS SV_PLC_FUNCTION_98
SelectSpindleCW       IS SV_PLC_FUNCTION_99
SelectCoolAutoMan     IS SV_PLC_FUNCTION_104
DoIncreaseSpindleOR   IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOR   IS SV_PLC_FUNCTION_107
SelectSpinOR100       IS SV_PLC_FUNCTION_108
DoEscapeKey           IS SV_PLC_FUNCTION_109

;----------------------------------------------------------------
;  System variables:  Keyboard jogging functions
;----------------------------------------------------------------
;-------------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard keypress has occured.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Keypresses are sent down as individual keys.  It is the responsibility of
; the PLC programmer to insure that a keypress is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a keypress form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......
;-------------------------------------------------------------------------------
Kb_a              IS SV_PC_KEYBOARD_KEY_60
Kb_b              IS SV_PC_KEYBOARD_KEY_79
Kb_c              IS SV_PC_KEYBOARD_KEY_77
Kb_d              IS SV_PC_KEYBOARD_KEY_62
Kb_e              IS SV_PC_KEYBOARD_KEY_41
Kb_f              IS SV_PC_KEYBOARD_KEY_63
Kb_g              IS SV_PC_KEYBOARD_KEY_64
Kb_h              IS SV_PC_KEYBOARD_KEY_65
Kb_i              IS SV_PC_KEYBOARD_KEY_46
Kb_j              IS SV_PC_KEYBOARD_KEY_66
Kb_k              IS SV_PC_KEYBOARD_KEY_67
Kb_l              IS SV_PC_KEYBOARD_KEY_68
Kb_m              IS SV_PC_KEYBOARD_KEY_81
Kb_n              IS SV_PC_KEYBOARD_KEY_80
Kb_o              IS SV_PC_KEYBOARD_KEY_47
Kb_p              IS SV_PC_KEYBOARD_KEY_48
Kb_q              IS SV_PC_KEYBOARD_KEY_39
Kb_r              IS SV_PC_KEYBOARD_KEY_42
Kb_s              IS SV_PC_KEYBOARD_KEY_61
Kb_t              IS SV_PC_KEYBOARD_KEY_43
Kb_u              IS SV_PC_KEYBOARD_KEY_45
Kb_v              IS SV_PC_KEYBOARD_KEY_78
Kb_w              IS SV_PC_KEYBOARD_KEY_40
Kb_x              IS SV_PC_KEYBOARD_KEY_76
Kb_y              IS SV_PC_KEYBOARD_KEY_44
Kb_z              IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar       IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift        IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift        IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt          IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt          IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl         IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl         IS SV_PC_KEYBOARD_KEY_99
Kb_Ins            IS SV_PC_KEYBOARD_KEY_31
Kb_Home           IS SV_PC_KEYBOARD_KEY_32
Kb_End            IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown         IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp           IS SV_PC_KEYBOARD_KEY_33
Kb_Del            IS SV_PC_KEYBOARD_KEY_52
Kb_Back           IS SV_PC_KEYBOARD_KEY_30
Kb_Tab            IS SV_PC_KEYBOARD_KEY_38
Kb_Up             IS SV_PC_KEYBOARD_KEY_87
Kb_Down           IS SV_PC_KEYBOARD_KEY_101
Kb_Left           IS SV_PC_KEYBOARD_KEY_100
Kb_Right          IS SV_PC_KEYBOARD_KEY_102
Kb_Escape         IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1             IS SV_PC_KEYBOARD_KEY_2
Kb_F2             IS SV_PC_KEYBOARD_KEY_3
Kb_F3             IS SV_PC_KEYBOARD_KEY_4
Kb_F4             IS SV_PC_KEYBOARD_KEY_5
Kb_F5             IS SV_PC_KEYBOARD_KEY_6
Kb_F6             IS SV_PC_KEYBOARD_KEY_7
Kb_F7             IS SV_PC_KEYBOARD_KEY_8
Kb_F8             IS SV_PC_KEYBOARD_KEY_9
Kb_F9             IS SV_PC_KEYBOARD_KEY_10
Kb_F10            IS SV_PC_KEYBOARD_KEY_11
Kb_F11            IS SV_PC_KEYBOARD_KEY_12
Kb_F12            IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn       IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck       IS SV_PC_KEYBOARD_KEY_15
Kb_Break          IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock       IS SV_PC_KEYBOARD_KEY_34
Kb_1              IS SV_PC_KEYBOARD_KEY_18
Kb_2              IS SV_PC_KEYBOARD_KEY_19
Kb_3              IS SV_PC_KEYBOARD_KEY_20
Kb_4              IS SV_PC_KEYBOARD_KEY_21
Kb_5              IS SV_PC_KEYBOARD_KEY_22
Kb_6              IS SV_PC_KEYBOARD_KEY_23
Kb_7              IS SV_PC_KEYBOARD_KEY_24
Kb_8              IS SV_PC_KEYBOARD_KEY_25
Kb_9              IS SV_PC_KEYBOARD_KEY_26
Kb_0              IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div     IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt     IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub     IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0       IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1       IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2       IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3       IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4       IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5       IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6       IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7       IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8       IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9       IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt  IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus    IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter      IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket   IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket   IS SV_PC_KEYBOARD_KEY_50
Kb_Hyphen         IS SV_PC_KEYBOARD_KEY_28
Kb_Equals         IS SV_PC_KEYBOARD_KEY_29
Kb_Comma          IS SV_PC_KEYBOARD_KEY_82
Kb_Period         IS SV_PC_KEYBOARD_KEY_83
Kb_Slash          IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash      IS SV_PC_KEYBOARD_KEY_86

;----------------------------------------------------------------
; M functions - The System Variables in this section inform the
; PLC that an M function has been requested.
;----------------------------------------------------------------
M3                            IS SV_M94_M95_1 ;(Spindle CW)
M4                            IS SV_M94_M95_2 ;(Spindle CCW)
M8                            IS SV_M94_M95_3 ;(Flood On)
M10                           IS SV_M94_M95_4 ;(Clamp)
M7                            IS SV_M94_M95_5 ;(Mist)
;                             IS SV_M94_M95_6 ;
;                             IS SV_M94_M95_7 ;
M6                            IS SV_M94_M95_8 ; Tool change request
;                             IS SV_M94_M95_9 ;
;                             IS SV_M94_M95_10;
;                             IS SV_M94_M95_11;
;                             IS SV_M94_M95_12;
;                             IS SV_M94_M95_13;
;                             IS SV_M94_M95_14;
M15                           IS SV_M94_M95_15;Unclamp tool
;                             IS SV_M94_M95_16;

M18                           IS SV_M94_M95_18;Carousel at position 1
M19                           IS SV_M94_M95_19;Orient Spindle

M32                           IS SV_M94_M95_32;Chip Auger 1 FWD
M33                           IS SV_M94_M95_33;Chip Auger 2 FWD 

PutbackComplete               IS SV_M94_M95_40;PutbackComplete
M80                           IS SV_M94_M95_80;Carousel In
M81                           IS SV_M94_M95_81;Carousel Out

;M5 Turn off spindle and cancel orientation (M19)
;M15 Tool Unclamp and Air Blow On (spindle must be oriented or at zero speed)
;M16 Tool Clamp and Air Blow Off
;M17 Turn off spindle and coolant and start spindle orient process.
;M18 ATC Reset. 
;M19 Spindle Orient
;M21 Move Z axis to home position
;M22 Move Z axis to carousel height
;M31/M32 Chip Auger FWD/REV (optional)
;M33 Chip Auger Off (optional)
;M50/M51 Rotate Carousel FWD/REV. These commands can be used within a running program to rotate
;the tool carousel and are typically us
;ed when there are large tools in th
;e tool carousel that would interfere
;with a part or fixture.
;M80* Carousel in (extend into the spindle)
;M81* Carousel out (retract away from the spindle)
;M6 A complete tool change sequence. 

;----------------------------------------------------------------
;                     Word Definitions (int32)
;----------------------------------------------------------------
CarouselPosition_W            IS W1
RequestedBinPosition_W        IS W2
MaxBinLocation_W              IS W3
PutBackPosition_W             IS W4
LastCarouselDir_W             IS W5
SvToolNum_W                   IS W6



FaultMsg_W                    IS W11
ErrorMsg_W                    IS W12
InfoMsg_W                     IS W13
                              
                              
Lube_W                        IS W26
LubeM_W                       IS W27
LubeS_W                       IS W28
SpindleRange_W                IS W29  ; 1 = low ... 4 = high
PrevFeedOverride_W            IS W30
P148Value_W                   IS W31
P146Value_W                   IS W32
P170Value_W                   IS W33

P900Value_W                   IS W35
MiniPLCStatus_W               IS W36
StallReason_W                 IS W37
StallAxis_W                   IS W38
Sv_Control_1_Shadow           IS W39
Sv_Control_2_Shadow           IS W40
Sv_Control_3_Shadow           IS W41
Sv_Control_4_Shadow           IS W42
Sv_Control_5_Shadow           IS W43
PLC_Fault_W                   IS W44
PLCFaultAddr_W                IS W45
BadMsg_W                      IS W46
XMeterADC_W                   IS W47
YMeterADC_W                   IS W48
ZMeterADC_W                   IS W49
AMeterADC_W                   IS W50
SpindleMeterADC_W             IS W51
LubeAccumTime_W               IS W52
KbOverride_W                  IS W53
FeedrateKnob_W                IS W54
FinalFeedOverride_W           IS W55
Last_FeedrateKnob_W           IS W56
CycloneStatus_W               IS W57
SixteenBitSpeed_W             IS W58

Axis1DriveMapping_W           IS W59
Axis2DriveMapping_W           IS W60
Axis3DriveMapping_W           IS W61
Axis4DriveMapping_W           IS W62
Axis5DriveMapping_W           IS W63
Axis6DriveMapping_W           IS W64
Axis7DriveMapping_W           IS W65
Axis8DriveMapping_W           IS W66

AcdcDrive1EstWatts_W          IS W68
AcdcDrive2EstWatts_W          IS W69
AcdcDrive3EstWatts_W          IS W70
AcdcDrive4EstWatts_W          IS W71
AcdcDrive5EstWatts_W          IS W72
AcdcDrive6EstWatts_W          IS W73
AcdcDrive7EstWatts_W          IS W74
AcdcDrive8EstWatts_W          IS W75




;----------------------------------------
;           Word Definitions cont. (f32)
;----------------------------------------
SpinRangeAdjust_FW            IS FW1
RPMPerBit_FW                  IS FW2
CfgMinSpeed_FW                IS FW3
CfgMaxSpeed_FW                IS FW4
SixteenBitSpeed_FW            IS FW5
SpinSpeedCommand_FW           IS FW6


;------------------------------------
;            One Shot Definitions
;------------------------------------
IncrContPD                    IS PD1
SlowFastPD                    IS PD2
MpgPD                         IS PD3
SingleBlockPD                 IS PD4
FeedHoldPD                    IS PD5
SpinAutoManPD                 IS PD6
SpindlePlusPD                 IS PD7
SpinOverMinusPD               IS PD8
SpinOver100PD                 IS PD9
ProbePD                       IS PD10
SaveJogModePD                 IS PD11
AutoSpindlePD                 IS PD12
AutoCoolantPD                 IS PD13
F9PD                          IS PD14
x1JogPD                       IS PD15
x10JogPD                      IS PD16
x100JogPD                     IS PD17
LowLubePD                     IS PD18
RapidOverPD                   IS PD19
CoolantAutoManualPD           IS PD21
CoolantFloodPD                IS PD22
CoolantMistPD                 IS PD23
ToolCheckPD                   IS PD24
JogProbeFaultPD               IS PD25
RigidTapPD                    IS PD26
ToolCounterPD                 IS PD27
M6PD                          IS PD28 
AC1FatalErrorPD               IS PD29


PCSpindleStartStopPD          IS PD30
PCSpindleManualPD             IS PD31
PCSpindleCWPD                 IS PD32
PCSpindleCCWPD                IS PD33
StopRunningPD                 IS PD35
SoftwareReadyPD               IS PD36
Aux1PD                        IS PD41
Aux2PD                        IS PD42
Aux3PD                        IS PD43
Aux4PD                        IS PD44
Aux5PD                        IS PD45
Aux6PD                        IS PD46
Aux7PD                        IS PD47
Aux8PD                        IS PD48
Aux9PD                        IS PD49
Aux10PD                       IS PD50
Aux11PD                       IS PD51
Aux12PD                       IS PD52
Aux13PD                       IS PD53
Aux14PD                       IS PD54
MinSpeedPD                    IS PD55

;----------------------------------------------------------------
;                    Timer Definitions
;----------------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T                    IS T1
SleepTimer                    IS T2
CycloneStatus_T               IS T3
Initialize_T                  IS T4
ErrorFlag_T                   IS T5
TriggerPause_T                IS T6
ToolClampUnclampTimer         IS T7
CarouselInOutTimer            IS T8
OrientTimer                   IS T9
OrientLostTimer               IS T10  
MasterEnable_T                IS T11
                              
LubeM_T                       IS T13
LubeS_T                       IS T14

;----------------------------------------------------------------
;                       Stage Definitions
;----------------------------------------------------------------
WatchDogStage                 IS STG1
InitialStage                  IS STG2
JogPanelStage                 IS STG3
MainStage                     IS STG4
AxesEnableStage               IS STG5
ChipAugerStage                IS STG6
MPGStage                      IS STG7
CheckCycloneStatusStage       IS STG8
MiniPLCErrorStage             IS STG9
LoadParametersStage           IS STG10
KeyboardEventsStage           IS STG11
ResetCarouselStage            IS STG12
LubeUsePumpTimersStage        IS STG13
LubeUsePLCTimersStage         IS STG14
MonitorIndexATCRequestStage   IS STG15

ReportCarouselPositionStage   IS STG16
SetRequestedBinPositionStage  IS STG17
SetCarouselDirectionStage     IS STG18 
RotateCarouselStage           IS STG19

                              
MessageStage                  IS STG90
ShowFaultStage                IS STG91
ShowErrorStage                IS STG92
ShowInfoStage                 IS STG93
BadMsgStage                   IS STG94

;#############################################################################
;                         Program Start
;#############################################################################

;=============================================================================
                          WatchDogStage
;=============================================================================

; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
IF SV_PLC_FAULT_STATUS != 0
  THEN PLC_Fault_W    = SV_PLC_FAULT_STATUS,
       PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
       FaultMsg_W    = PLC_EXECUTOR_FLT_MSG, MSG FaultMsg_W,
       SET PLCExecutorFault_M, RST MessageStage, SET SV_STOP

; Handle software exit.
IF !SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0)
  THEN SET SoftwareNotReady_M,
       SET SV_STOP,
       FaultMsg_W = SOFTWARE_EXIT_MSG

IF SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0)
  THEN RST SoftwareNotReady_M

; If the memory bit we call "True" is not yet true, it is because this is
; the first scan after power up.  In that case execute InitialStage.
IF !True THEN SET InitialStage

;==============================================================================
                              InitialStage
;==============================================================================
IF 1==1 THEN SET True,
             SET OnAtPowerUp_M,
             SET AxesEnableStage,
             SET MainStage,
             SET JogPanelStage,
             SET LoadParametersStage,
             SET MPGStage,
             SET PLCBus_Oe_M,
             RST PLCFault_M,
             CycloneStatus_T = 300,
             FaultMsg_W = MSG_CLEARED_MSG,
             RST BadMsgStage,
             SET MessageStage,
             Initialize_T = 1000, SET Initialize_T,
             ErrorFlag_T = 1000,
             MsgClear_T = 5000,
			 CarouselPosition_W = SV_ATC_CAROUSEL_POSITION,
			 RequestedBinPosition_W = CarouselPosition_W,
			 PutBackPosition_W = SV_ATC_TOOL_IN_SPINDLE,
			 SET MonitorIndexATCRequestStage,
			 SET ReportCarouselPositionStage,
             SET ResetCarouselStage,			 
             RST InitialStage


;==============================================================================
                          LoadParametersStage
;==============================================================================

; There are two methods of control for the lube pump and they are set by CNC11
; Machine Parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled soley by PLC).
;
; Load lube pump times from P179 and convert to milliseconds.
IF True THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000

; Set the appropriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimersStage, RST LubeUsePLCTimersStage
IF LubeS_W != 0 THEN SET LubeUsePLCTimersStage, RST LubeUsePumpTimersStage

IF True THEN P146Value_W = SV_MACHINE_PARAMETER_146,  ; Feed hold threshold
             P148Value_W = SV_MACHINE_PARAMETER_148,  ; Misc Jogging Options
             P170Value_W = SV_MACHINE_PARAMETER_170  ; Enable Keyboard Jogging
             

IF True THEN BITTST P148Value_W 1 DisableKbInput_M,
             BITTST P170Value_W 0 AllowKbInput_M,
             BITTST P170Value_W 1 JogOverOnly_M,
             BITTST P170Value_W 2 KbOverOnly_M

IF DisableKbInput_M THEN RST AllowKbInput_M
IF JogOverOnly_M && KbOverOnly_M THEN RST KbOverOnly_M

IF SV_JOG_PANEL_REQUIRED THEN (JogPanelRequired_M)

; The following section allows cnc11 to invert or override Inputs and 
; Outputs.
if true then (SV_ENABLE_IO_OVERRIDE),
             SV_INVERT_INP1_16_BITS      = SV_MACHINE_PARAMETER_911,
             SV_INVERT_INP17_32_BITS     = SV_MACHINE_PARAMETER_912,
             SV_INVERT_INP33_48_BITS     = SV_MACHINE_PARAMETER_913,
             SV_INVERT_INP49_64_BITS     = SV_MACHINE_PARAMETER_914,
	     SV_INVERT_INP65_80_BITS     = SV_MACHINE_PARAMETER_915,
             SV_FORCE_INP1_16_BITS       = SV_MACHINE_PARAMETER_916,
             SV_FORCE_INP17_32_BITS      = SV_MACHINE_PARAMETER_917,
             SV_FORCE_INP33_48_BITS      = SV_MACHINE_PARAMETER_918,
             SV_FORCE_INP49_64_BITS      = SV_MACHINE_PARAMETER_919,
	     SV_FORCE_INP65_80_BITS      = SV_MACHINE_PARAMETER_920,
             SV_FORCE_ON_OUT1_16_BITS    = SV_MACHINE_PARAMETER_921,
             SV_FORCE_ON_OUT17_32_BITS   = SV_MACHINE_PARAMETER_922,
             SV_FORCE_ON_OUT33_48_BITS   = SV_MACHINE_PARAMETER_923,
             SV_FORCE_ON_OUT49_64_BITS   = SV_MACHINE_PARAMETER_924,
             SV_FORCE_ON_OUT65_80_BITS   = SV_MACHINE_PARAMETER_925,
	     SV_FORCE_OFF_OUT1_16_BITS   = SV_MACHINE_PARAMETER_926,
             SV_FORCE_OFF_OUT17_32_BITS  = SV_MACHINE_PARAMETER_927,
             SV_FORCE_OFF_OUT33_48_BITS  = SV_MACHINE_PARAMETER_928,
             SV_FORCE_OFF_OUT49_64_BITS  = SV_MACHINE_PARAMETER_929,
	     SV_FORCE_OFF_OUT65_80_BITS  = SV_MACHINE_PARAMETER_930

;=============================================================================
                        LubeUsePumpTimersStage
;=============================================================================

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be set such that MMM is a
; value that is greater than the cycle time set on the internal timers and
; SS should be set to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is set to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually set with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time set by the inteval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems accoding to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF SV_PROGRAM_RUNNING THEN SET Lube, RST LubeM_T
IF !SV_PROGRAM_RUNNING THEN LubeM_T = LubeM_W, SET LubeM_T
IF LubeM_T || SV_STOP THEN RST Lube

;=============================================================================
                        LubeUsePLCTimersStage
;=============================================================================
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be set so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To set the lube pump power to come on for 5 seconds
;    every 10 minutes, set P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To set the lube pump power to come on for 30 seconds
;    every 2 hours, set P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;

IF SV_PROGRAM_RUNNING  THEN LubeM_T = LubeM_W, SET LubeM_T
IF !SV_PROGRAM_RUNNING THEN (StopRunningPD)
IF StopRunningPD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T, RST LubeM_T
IF LubeM_T || (LubeAccumTime_W + LubeM_T > LubeM_W)
  THEN SET Lube, LubeS_T = LubeS_W, SET LubeS_T, RST LubeM_T, LubeAccumTime_W = 0
IF LubeS_T || SV_STOP THEN RST Lube, RST LubeS_T

;=============================================================================
                        KeyboardEventsStage
;=============================================================================
; This stage handles functions that are required for menu navigation
; by CNC11, require multiple keypresses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must set parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC11 to aid in menu
; navigation.  NOTE: For backward comaptibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked------------------------
; The code for cycle cancel has been moved to the main stage.
; It is commented out below but remains for reference
;Cycle Cancel
;IF Kb_Escape THEN (KbCycleCancel_M)

;Rapidoverride: Ctrl-r
IF Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M-------------------
;KbCycle Start: alt-s
IF  Kb_s && (Kb_R_Alt || Kb_L_Alt) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
IF Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbTogSingleBlock_M: ctrl-b
IF Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
IF Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
IF Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCW_M,
    RST KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
IF Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCCW_M,
    RST KbSpinCW_M

;KbSpinStart_M:  ctrl-s
IF Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
IF Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
IF Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
IF Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
IF Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
IF Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
IF Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
IF Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbMistOnOff_M)

;KbTogIncContJog_M: "ctrl" +  "i"
IF Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
IF Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbTogFastSlowJog_M)

;KbAux1Key_M: "ctrl" + "F1"
IF Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
IF Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
IF Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
IF Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
IF Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
IF Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
IF Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
IF Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
IF Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
IF Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux11Key_M: "ctrl" + "F11"
IF Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux11Key_M)

;KbAux12Key_M: "ctrl" + "F12"
IF Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
IF (Kb_Equals || Kb_10_Key_Plus) && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
IF (Kb_Hyphen || Kb_10_Key_Sub) && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
IF Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  THEN (KbFeedOver100_M)


;--------Interlocked with AllowKbInput_M && KbJpActive_M-----------

;KbIncreaseJogInc_M: "insert"
IF Kb_Ins && AllowKbInput_M && KbJpActive_M
  THEN (KbIncreaseJogInc_M)
IF KbIncreaseJogInc_M && x1JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X10_M
IF KbIncreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X100_M

;KbDecreaseJogInc_M: "delete"
IF Kb_Del && AllowKbInput_M && KbJpActive_M
  THEN (KbDecreaseJogInc_M)
IF KbDecreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X1_M
IF KbDecreaseJogInc_M && x100JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X10_M


;KbJogAx1Plus_M: Right arrow
IF Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Left arrow
IF Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
IF Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
IF Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
IF Kb_PgUp && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
IF Kb_PgDown && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
IF Kb_Home && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
IF Kb_End && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Minus_M)

IF True THEN RST KeyboardEventsStage

;=============================================================================
                           MPGStage
;=============================================================================
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED & on the MPG
IF MPGKey THEN (MpgPD)
IF MpgPD && MPGLED THEN SET MPGManOffFlag_M
IF !SV_MPG_1_ENABLED || (MpgPD && !MPGLED) THEN RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) || (SV_MPG_1_ENABLED && !MPGManOffFlag_M) &&
   !SV_PROGRAM_RUNNING THEN SET MPG_LED_OUT, SET MPGLED

IF (!SV_MPG_1_ENABLED || (MpgPD && MPGLED))
   || SV_PROGRAM_RUNNING THEN RST MPG_LED_OUT, RST MPGLED

;x1, x10, x100 functions
;--X1
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp_M || X1_M || (MPG_Inc_X_1 && MPGLED)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--X10
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || X10_M || (MPG_Inc_X_10 && MPGLED)
  THEN RST x1JogLED, SET x10JogLED, RST x100JogLED

;--X100
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || X100_M || (MPG_Inc_X_100 && MPGLED)
  THEN RST x1JogLED, RST x10JogLED, SET x100JogLED

IF !KbIncreaseJogInc_M && !KbDecreaseJogInc_M THEN RST X1_M, RST X10_M,
  RST X100_M

;--MPG 1 Enable
IF MPG_AXIS_1 || MPG_AXIS_2 || MPG_AXIS_3 || MPG_AXIS_4 ||
  MPG_AXIS_5 || MPG_AXIS_6 || MPG_AXIS_7 || MPG_AXIS_8
  THEN (SV_MPG_1_ENABLED)

;                     Select axis to move
IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
IF MPG_AXIS_2 THEN SV_MPG_1_AXIS_SELECT = 2
IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4
IF MPG_AXIS_5 THEN SV_MPG_1_AXIS_SELECT = 5

;                   Select MPG 1 Multiplier
IF (MPG_Inc_X_100) THEN SV_MPG_1_MULTIPLIER = 100
IF (MPG_Inc_X_10) THEN  SV_MPG_1_MULTIPLIER = 10
IF (MPG_Inc_X_1) THEN   SV_MPG_1_MULTIPLIER = 1

;            Disable "Windup" mode if x100 selected
IF (!MPG_Inc_X_100) THEN (SV_MPG_1_WINDUP_MODE)


;=============================================================================
                           JogPanelStage
;=============================================================================
;--Select Incremental or Continuous Jog Mode
IF IncrContKey || KbTogIncContJog_M THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp_M THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;--Select Fast or Slow Jog Mode
IF FastSlowKey || KbTogFastSlowJog_M THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || OnAtPowerUp_M
  THEN SET FastSlowLED
IF (SlowFastPD && FastSlowLED) THEN RST FastSlowLED

;--Single Block Mode

IF SingleBlockKey || KbTogSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING
  THEN SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;--Toolcheck

IF (ToolCheckKey || KbToolCheck_M) && !SV_STOP THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;--Feed Hold Mode
; Note: the feedrate override values used here for testing against P146
; are those calculated in the previous scan.  There is no problem with that.
IF (FeedHoldKey || KbFeedHold_M) THEN (FeedHoldPD)
IF FeedHoldPD || ActivateFeedHold_M ||
   (FinalFeedOverride_W < P146Value_W && !OnAtPowerUp_M)
  THEN SET FeedHoldLED
IF !SV_PROGRAM_RUNNING || DoCycleStart || DoCycleCancel || DoToolCheck ||
   (FinalFeedOverride_W >= P146Value_W &&
    PrevFeedOverride_W < P146Value_W)
  THEN RST FeedHoldLED
IF True THEN PrevFeedOverride_W = FinalFeedOverride_W
; (FeedHoldLED will be used later to signal MPU11 to do Feed Hold)

;--Feedrate Override Section
;-------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and then multiplying the result by 100
; 3. If keyboard jogging is enabled, the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" screen in CNC11 software) stores
;    a value which the PLC program must use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC11 software by setting
;    SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W
; 7. CNC11 reads SV_PLC_FEEDRATE_KNOB, factors in its own override based
;    on parameter 78 (see operators manual for more info on parm 78) and then
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;-----------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;-----------------------------------------------------------------------
IF True THEN FeedrateKnob_W = 0,
             BTW FeedrateKnob_W JpFeedOrKnobBit0 8

;-----------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;-----------------------------------------------------------------------
IF True THEN FeedrateKnob_W = (FeedrateKnob_W/127.5)*100
IF FeedrateKnob_W == 99 || FeedrateKnob_W == 101 THEN FeedrateKnob_W = 100
IF FeedrateKnob_W < MIN_FROR_PCT THEN FeedrateKnob_W = MIN_FROR_PCT

;-----------------------------------------------------------------------
; 3.  Determine whether to use FeedrateKnob_W or KbOverride_W
;-----------------------------------------------------------------------
; This section determines when to use the feedrate override value sent down
; by the jogpanel (FeedrateKnob_W) or the feedrate override as determined
; by the PLC monitoring the keyboard override keys (KbOverride_W).

;-----------------------------------------------------------------------------
;     At powerup, default feedrate override is jog panel (FeedrateKnob_W)
;       To use both keyboard or jogpanel overrides set p170 to 0 (default)
;       To use jogpanel override only set p170 to 2
;       To use keyboard only set p170 to 4
;-----------------------------------------------------------------------------
IF OnAtPowerUp_M && KbOverOnly_M || KbFeedOver100_M THEN KbOverride_W = 100
IF OnAtPowerUp_M && !KbOverOnly_M THEN SET UsingFeedrateKnob_M,
                                       KbOverride_W = FeedrateKnob_W,
                                       Last_FeedrateKnob_W = FeedrateKnob_W

;----------------Calculate keyboard feedrate override-------------------------
; SleepTimer is used to limit the KbOverride_W update rate to 20% per sec
;-----------------------------------------------------------------------------
IF AllowKbInput_M && KbIncFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W + 1,
       RST UsingFeedrateKnob_M,
       SET WaitingForSleepTimer_M,
       SleepTimer = 50, SET SleepTimer

IF AllowKbInput_M && KbDecFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W - 1, RST UsingFeedrateKnob_M,
       SET WaitingForSleepTimer_M, SleepTimer = 50, SET SleepTimer

IF SleepTimer THEN RST WaitingForSleepTimer_M, RST SleepTimer

;------------Switch to FeedrateKnob_W if it changes more than 3%--------------
; Once it has changed by more than 3%, it will update as normal (1% increments)
; until it sees another KbOverride_W command at which point it will take
; another 3% change to re-activate the FeedrateKnob_W

IF (ABS(Last_FeedrateKnob_W - FeedrateKnob_W) >= 3) || UsingFeedrateKnob_M
  THEN FinalFeedOverride_W = FeedrateKnob_W, KbOverride_W = FeedrateKnob_W,
       Last_FeedrateKnob_W = FeedrateKnob_W, SET UsingFeedrateKnob_M

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W & the FeedrateKnob_W
IF KbOverride_W > SV_MACHINE_PARAMETER_39
  THEN KbOverride_W = SV_MACHINE_PARAMETER_39

IF KbOverride_W < MIN_FROR_PCT THEN KbOverride_W = MIN_FROR_PCT

IF !UsingFeedrateKnob_M && !JogOverOnly_M
  THEN FinalFeedOverride_W = KbOverride_W

;-----------------------------------------------------------------------
; 4 & 5. Limit override percentage to value set in Parameter 39
;-----------------------------------------------------------------------
;------------------Limit final override percentage to parm 39-------------------
IF FinalFeedOverride_W > SV_MACHINE_PARAMETER_39
  THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39

;----------------------------------------------
;  Override Controls
;  It is important that the plc program only writes to SV_PLC_FEEDRATE_KNOB once per pass
;----------------------------------------------
; Override control bit for the feedrate override
; 1 == feedrate override knob will affect feedrate
; 0 == override knob has NO effect on feedrate
IF  !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN FinalFeedOverride_W = 100

;-----------------------------------------------------------------------
; 6. Send override percentage to CNC11
;-----------------------------------------------------------------------
;----------------Send override to PC for modification if needed---------------
IF True THEN SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W

;-----------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;-----------------------------------------------------------------------
;--------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;--------------------------------------------------------------------------
IF True THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;--MPU11 Jog Panel Key Functions
IF KB_F9 THEN (F9PD)
IF KbTogRapidOver_M || (F9PD && SV_PROGRAM_RUNNING)
  THEN (RapidOverPD)
IF (RapidOverPD ^ SelectRapidOverride) || OnAtPowerUp_M
  THEN (SelectRapidOverride)

IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING
   || ErrorFlag_M
  THEN (DoCycleCancel)
IF (CycleStartKey  || KbCycleStart_M) THEN (DoCycleStart)

;IF CycleCancelKey  THEN (DoEscapeKey) ; uncomment if CANCEL should exit menus

IF (Ax1PlusJogKey  || KbJogAx1Plus_M)  && !Ax1PlusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M) && !Ax1MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax2PlusJogKey  || KbJogAx2Plus_M)  && !Ax2PlusJogDisabled_M  &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M) && !Ax2MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

IF (Ax3PlusJogKey  || KbJogAx3Plus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M) && !Ax3MinusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)

IF (Aux1Key  || KbAux1Key_M) THEN (DoAux1Key)
IF (Aux2Key  || KbAux2Key_M) THEN (DoAux2Key)
IF (Aux3Key  || KbAux3Key_M) THEN (DoAux3Key)
IF (Aux4Key  || KbAux4Key_M) THEN (DoAux4Key)
IF (Aux5Key  || KbAux5Key_M) THEN (DoAux5Key)
IF (Aux6Key  || KbAux6Key_M) THEN (DoAux6Key)
IF (Aux7Key  || KbAux7Key_M) THEN (DoAux7Key)
IF (Aux8Key  || KbAux8Key_M) THEN (DoAux8Key)
IF (Aux9Key  || KbAux9Key_M) THEN (DoAux9Key)
IF (Aux10Key || KbAux10Key_M) THEN (DoAux10Key)
IF (Aux11Key || KbAux11Key_M) THEN (DoAux11Key)
IF (Aux12Key || KbAux12Key_M) THEN (DoAux12Key)
IF x1JogLED     THEN (SelectX1JogInc)
IF x10JogLED    THEN (SelectX10JogInc)
IF x100JogLED   THEN (SelectX100JogInc)
IF IncrContLED  THEN (SelectIncContJog)
IF FastSlowLED  THEN (SelectFastSlowJog)
IF MPGLED       THEN (SelectMpgMode)
IF FeedHoldLED && SV_PC_OVERRIDE_CONTROL_FEEDHOLD THEN (DoFeedHold)

;--Coolant Functions

;--Toggle auto coolant mode
IF CoolAutoManKey || KbTogCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoModeLED && CoolantAutoManualPD) || OnAtPowerUp_M
  THEN SET CoolAutoModeLED

IF (CoolAutoModeLED && CoolantAutoManualPD)
  THEN RST CoolAutoModeLED

;--Report coolant mode to CNC11
IF CoolAutoModeLED THEN (SelectCoolAutoMan)

;--Display coolant mode message
;changing to auto coolant mode ;2050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = AUTO_COOL_MSG

;changing to manual coolant mode ;2051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoModeLED && CoolantAutoManualPD && AllowKbInput_M)
  THEN InfoMsg_W = MAN_COOL_MSG

;--Flood coolant on/off
;
;  Toggle on/off or off/on if:
;    In manual mode and a toggle key was pressed
;  Turn on if:
;    In auto mode and have M8
;  Turn off if:
;    Any fault or error
;    In auto mode and don't have M8
;    Doing tool check (?)
IF CoolFloodKey || KbFloodOnOff_M THEN (CoolantFloodPD)
IF ((Flood ^ (!CoolAutoModeLED && CoolantFloodPD))
   || CoolAutoModeLED && M8)
   && !(SV_STOP ||
        CoolAutoModeLED && !M8 ||
        ErrorFlag_M ||
        DoToolCheck)
  THEN (Flood), (CoolFloodLED), (SelectCoolantFlood)

;--Mist coolant on/off
IF (CoolMistKey || KbMistOnOff_M) THEN (CoolantMistPD)
IF ((Mist ^ (!CoolAutoModeLED && CoolantMistPD))
   || CoolAutoModeLED && M7)
   && !(SV_STOP ||
        CoolAutoModeLED && !M7 ||
        ErrorFlag_M ||
        DoToolCheck)
  THEN (Mist), (CoolMistLED), (SelectCoolantMist)

;--Spindle Control
;-------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;-------------------------------------------------------------
;--Select Auto or Manual Spindle Operation Mode
;Triggers to Toggle Auto/Manual Spindle Mode
IF SpinAutoManKey || KbTogSpinAutoMan_M THEN (SpinAutoManPD)

;--Set spindle to auto mode on startup
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp_M
  THEN SET SpinAutoModeLED

;--Set spindle to manual mode
IF SpinAutoManPD && SpinAutoModeLED THEN RST SpinAutoModeLED

;--Report the Spindle mode to CNC11
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;--Set triggers to start and stop the spindle

; Check for tripped limits, which force a spindle stop per CE requirements.
IF SV_LIMIT_TRIPPED THEN (LimitTripped_M)

; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

IF (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M))
  THEN SET SpindlePause_M
IF ((M3 || M4) && (SpinStartKey || KbSpinStart_M) ||
    !SV_PROGRAM_RUNNING)
  THEN RST SpindlePause_M

IF ((SpinStartKey || KbSpinStart_M) && !SpinAutoModeLED) ||
   (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M) ||
   ((SpinStartKey || KbSpinStart_M) && ((M3 || M4) && SpinAutoModeLED))
  THEN (SpinStart_M)

IF (SpinStopKey || KbSpinStop_M) ||
   (SpinAutoModeLED && !(M3 || M4)) ||
   (SV_PC_RIGID_TAP_SPINDLE_OFF && SpinAutoModeLED) ||
   ProbeDetect || SV_STOP || ErrorFlag_M || LimitTripped_M
  THEN (SpinStop_M)

;--Adjust spindle override when entering manual or auto spin mode
;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 100,
       SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 10, RST SpinAutoModeLED

;--Set spindle direction
;------------------Set Clockwise direction
IF ((KbSpinCW_M || SpinCWKey) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
  THEN RST SpindleDirection_M
IF !SpindleDirection_M THEN (SpindleCWLED), (SelectSpindleCW)

;---------------Set Counterclockwise direction
IF ((KbSpinCCW_M || SpinCCWKey) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
  THEN SET SpindleDirection_M
IF SpindleDirection_M THEN (SpindleCCWLED), (SelectSpindleCCW)

IF SpindleDirection_M ^ SpinRangeReversed_M THEN (SpindleDirectionOut)

;-------------------------------------------------------------------------------
;                                Turn spindle on/off
;-------------------------------------------------------------------------------
IF ProbeDetect && SpinStart_M THEN SET ProbeFault_M

IF (SpindleEnableOut || SpinStart_M ) && !SpinStop_M
  THEN (SpindleEnableOut), (SpindleFan)

IF !SpindleEnableOut THEN (DoSpindleStop)

;-------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "ctrl" + "<", "ctrl" + ">", "ctrl" + "/"
;-------------------------------------------------------
IF SpinOverPlusKey || KbIncSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1
IF SpinOverMinusKey || KbDecSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1
IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp_M
  THEN SV_PLC_SPINDLE_KNOB = 100

IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN
  (SpinOver100LED),
  (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN
  (SpinOverMinusLED),
  (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN
  (SpinOverPlusLED),
  (DoIncreaseSpindleOr)

;--Output 12-bit DAC value for spindle control
;-----------------------------------------------------------------------------
;             Read spindle range inputs and/or range M codes
;
; NOTE: SV_SPINDLE_LOW_RANGE & SV_SPINDLE_MID_RANGE M are used to report the
; selected spindle range to CNC11
;-----------------------------------------------------------------------------
;   4 hi   3 med-high  2 med-low  1 low
;    0          1         1         0   SV_SPINDLE_MID_RANGE M
;    0          0         1         1   SV_SPINDLE_LOW_RANGE

; Use input switches, M functions, or other means to determine the gear
; range number (1-4).  For basic mills, look for one low-range switch.
; Default to high range until proven otherwise (fail-safe choice)
IF True THEN SpindleRange_W = 4
IF (SpinLowRange) THEN SpindleRange_W = 1

; Use the gear range number to set the range flags and speed ratio.

IF SpindleRange_W == 1 THEN SET SV_SPINDLE_LOW_RANGE,
                            RST SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_65

IF SpindleRange_W == 2 THEN SET SV_SPINDLE_LOW_RANGE,
                            SET SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_66

IF SpindleRange_W == 3 THEN RST SV_SPINDLE_LOW_RANGE,
                            SET SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = SV_MACHINE_PARAMETER_67

IF SpindleRange_W == 4 THEN RST SV_SPINDLE_LOW_RANGE,
                            RST SV_SPINDLE_MID_RANGE,
                            SpinRangeAdjust_FW = 1.0

; If the speed ratio parameter is negative, reverse the motor.
; Always use the absolute value of the parameter as the real ratio.
IF SpinRangeAdjust_FW < 0.0 THEN (SpinRangeReversed_M),
                                 SpinRangeAdjust_FW = -SpinRangeAdjust_FW

; Force the ratio to be non-zero, because we are going to divide by it later.
IF SpinRangeAdjust_FW < 0.001 THEN SpinRangeAdjust_FW = 0.001

;----------------------------------------------------------------
;              Read commanded spindle speed, max & min
;
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
;----------------------------------------------------------------
IF True THEN CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED
; Calculate #RPM's per bit of resolution
IF CfgMaxSpeed_FW > 0.0 THEN RPMPerBit_FW = CfgMaxSpeed_FW/65535.0
IF CfgMaxSpeed_FW <= 0.0 THEN RPMPerBit_FW = 1.0

IF SpinAutoModeLED THEN SpinSpeedCommand_FW = SV_PC_COMMANDED_SPINDLE_SPEED
IF !SpinAutoModeLED THEN SpinSpeedCommand_FW = CfgMaxSpeed_FW *
                                               SV_PLC_SPINDLE_KNOB / 200.0 *
                                               SpinRangeAdjust_FW
IF !SpindleEnableOut THEN SpinSpeedCommand_FW = 0.0

;----------------------------------------------------------------
; If commanded spindle speed is < Min Spin Speed * SpinRangeAdjust
; & commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust.
;----------------------------------------------------------------
IF (SpinSpeedCommand_FW > 0.0) &&
   (SpinSpeedCommand_FW < (CfgMinSpeed_FW * SpinRangeAdjust_FW))
  THEN SpinSpeedCommand_FW = (CfgMinSpeed_FW * SpinRangeAdjust_FW),
       (BelowMinSpeed_M)
IF BelowMinSpeed_M THEN (MinSpeedPD)
IF MinSpeedPD THEN InfoMsg_W = MIN_SPEED_MSG

;---------------------------------------------------------------------------
; If SpinSpeedCommand_FW > Max Spin Speed * SpinRangeAdjust, force
; SpinSpeedCommand_FW = max spin speed value * SpinRangeAdjust.
;---------------------------------------------------------------------------
IF SpinSpeedCommand_FW > (CfgMaxSpeed_FW * SpinRangeAdjust_FW)
  THEN SpinSpeedCommand_FW = (CfgMaxSpeed_FW * SpinRangeAdjust_FW)

;----------------------------------------------------------------
; Convert Spindle "S" command to 16 bit value for output to DAC
;----------------------------------------------------------------
; Commanded Spindle speed (includes override factor) is sent down from CNC11
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a
; 16 bit value (0-65535) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED.

;Display calculated RPM value on PC
IF True THEN SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_FW

;Convert RPM to 16 bit value
IF True THEN SixteenBitSpeed_FW = SpinSpeedCommand_FW/RPMPerBit_FW

; Factor in gear range
IF True THEN SixteenBitSpeed_FW = (SixteenBitSpeed_FW/SpinRangeAdjust_FW)

;Convert to integer word for DAC & I/O display
IF True THEN SixteenBitSpeed_W = SixteenBitSpeed_FW

; Bound min to 0, max to 65535
IF SixteenBitSpeed_W < 0 THEN SixteenBitSpeed_W = 0
IF SixteenBitSpeed_W > 65535 THEN SixteenBitSpeed_W = 65535

; Output to DAC
IF True THEN WTB SixteenBitSpeed_W SpinAnalogOutBit0 16

;=============================================================================
  CheckCycloneStatusStage
;=============================================================================
; Due to amount of time it takes to retrieve data from the cyclone, this stage
; is only called few times per second to help reduce scan time of the main PLC
; program.

; Read Axis1FiberOk_M through Axis8FiberOk_M
IF True THEN WTB SV_PC_CYCLONE_STATUS_2 Axis1FiberOk_M

; Generate some messages for fiber or wire to MPU11 having issues
IF SV_AXIS_VALID_1 && !SV_DRIVE_ONLINE_1 THEN FaultMsg_W = AXIS1_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_2 && !SV_DRIVE_ONLINE_2 THEN FaultMsg_W = AXIS2_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_3 && !SV_DRIVE_ONLINE_3 THEN FaultMsg_W = AXIS3_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_4 && !SV_DRIVE_ONLINE_4 THEN FaultMsg_W = AXIS4_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_5 && !SV_DRIVE_ONLINE_5 THEN FaultMsg_W = AXIS5_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_6 && !SV_DRIVE_ONLINE_6 THEN FaultMsg_W = AXIS6_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_7 && !SV_DRIVE_ONLINE_7 THEN FaultMsg_W = AXIS7_INFLT, SET DriveComFltIn_M
IF SV_AXIS_VALID_8 && !SV_DRIVE_ONLINE_8 THEN FaultMsg_W = AXIS8_INFLT, SET DriveComFltIn_M

; Generate some messages for fiber or wire to drive having issues
IF SV_AXIS_VALID_1 && SV_DRIVE_ONLINE_1 && SV_MASTER_ENABLE && !Axis1FiberOk_M
  THEN FaultMsg_W = AXIS1_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_2 && SV_DRIVE_ONLINE_2 && SV_MASTER_ENABLE && !Axis2FiberOk_M
  THEN FaultMsg_W = AXIS2_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_3 && SV_DRIVE_ONLINE_3 && SV_MASTER_ENABLE && !Axis3FiberOk_M
  THEN FaultMsg_W = AXIS3_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_4 && SV_DRIVE_ONLINE_4 && SV_MASTER_ENABLE && !Axis4FiberOk_M
  THEN FaultMsg_W = AXIS4_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_5 && SV_DRIVE_ONLINE_5 && SV_MASTER_ENABLE && !Axis5FiberOk_M
  THEN FaultMsg_W = AXIS5_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_6 && SV_DRIVE_ONLINE_6 && SV_MASTER_ENABLE && !Axis6FiberOk_M
  THEN FaultMsg_W = AXIS6_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_7 && SV_DRIVE_ONLINE_7 && SV_MASTER_ENABLE && !Axis7FiberOk_M
  THEN FaultMsg_W = AXIS7_OUTFLT, SET DriveComFltOut_M
IF SV_AXIS_VALID_8 && SV_DRIVE_ONLINE_8 && SV_MASTER_ENABLE && !Axis8FiberOk_M
  THEN FaultMsg_W = AXIS8_OUTFLT, SET DriveComFltOut_M

IF !EstopOk THEN RST DriveComFltIn_M, RST DriveComFltOut_M
IF DriveComFltOut_M || DriveComFltIn_M THEN SET AxisFault_M

;check PLC and JogBoard status bits
IF True THEN CycloneStatus_W = SV_PC_CYCLONE_STATUS_1,
             BITTST CycloneStatus_W 21 PLCBusExtDevEn_M,
             BITTST CycloneStatus_W 23 JogPanelOnline_M

;check PLC input fiber
IF !SV_PLC_BUS_ONLINE THEN FaultMsg_W = PLC_INFLT,
                           RST PLCBus_Oe_M, SET PLCFault_M

;check PLC output fiber
IF SV_PLC_BUS_ONLINE && PLCBus_Oe_M && !PLCBusExtDevEn_M
  THEN FaultMsg_W = PLC_OUTFLT, SET PLCFault_M

;clear PLC errors
IF PLCFault_M && SV_PLC_BUS_ONLINE && PLCBusExtDevEn_M && !EstopOk
  THEN RST PLCFault_M, InfoMsg_W = PLC_FLT_CLR, SET PLCBus_Oe_M

;check JogBoard incoming communications
IF SV_JOG_LINK_ONLINE THEN (JogLinkOk_M)
IF JogPanelRequired_M && !JogLinkOk_M
  THEN FaultMsg_W = JOGBOARD_INFLT, SET OtherFault_M

;check JogBoard outgoing communications
IF JogPanelRequired_M && JogLinkOk_M && !JogPanelOnline_M
  THEN FaultMsg_W = JOGBOARD_OUTFLT, SET OtherFault_M

; Check MiniPLC board communications
IF True THEN MiniPLCStatus_W = SV_PC_MINI_PLC_ONLINE,
             P900Value_W = SV_MACHINE_PARAMETER_900
IF MiniPLCStatus_W != P900Value_W THEN SET MiniPLCErrorStage

IF True THEN RST CheckCycloneStatusStage

;=============================================================================
   MiniPLCErrorStage
;=============================================================================
IF True THEN WTB P900Value_W MiniPLCExpected1_M 8,
             WTB MiniPLCStatus_W MiniPLCOk1_M 8

IF MiniPLCExpected1_M && !MiniPLCOk1_M
  THEN FaultMsg_W = MINI_PLC_1_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected2_M && !MiniPLCOk2_M
  THEN FaultMsg_W = MINI_PLC_2_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected3_M && !MiniPLCOk3_M
  THEN FaultMsg_W = MINI_PLC_3_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected4_M && !MiniPLCOk4_M
  THEN FaultMsg_W = MINI_PLC_4_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected5_M && !MiniPLCOk5_M
  THEN FaultMsg_W = MINI_PLC_5_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected6_M && !MiniPLCOk6_M
  THEN FaultMsg_W = MINI_PLC_6_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected7_M && !MiniPLCOk7_M
  THEN FaultMsg_W = MINI_PLC_7_FLT_MSG, SET OtherFault_M
IF MiniPLCExpected8_M && !MiniPLCOk8_M
  THEN FaultMsg_W = MINI_PLC_8_FLT_MSG, SET OtherFault_M

IF MiniPLCOk1_M && !MiniPLCExpected1_M
  THEN InfoMsg_W = MINI_PLC_1_WARNING
IF MiniPLCOk2_M && !MiniPLCExpected2_M
  THEN InfoMsg_W = MINI_PLC_2_WARNING
IF MiniPLCOk3_M && !MiniPLCExpected3_M
  THEN InfoMsg_W = MINI_PLC_3_WARNING
IF MiniPLCOk4_M && !MiniPLCExpected4_M
  THEN InfoMsg_W = MINI_PLC_4_WARNING
IF MiniPLCOk5_M && !MiniPLCExpected5_M
  THEN InfoMsg_W = MINI_PLC_5_WARNING
IF MiniPLCOk6_M && !MiniPLCExpected6_M
  THEN InfoMsg_W = MINI_PLC_6_WARNING
IF MiniPLCOk7_M && !MiniPLCExpected7_M
  THEN InfoMsg_W = MINI_PLC_7_WARNING
IF MiniPLCOk8_M && !MiniPLCExpected8_M
  THEN InfoMsg_W = MINI_PLC_8_WARNING

IF True THEN RST MiniPLCErrorStage

;=============================================================================
   AxesEnableStage
;=============================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handle ACDC Fatal Errors
; On a fatal error, the AC1 will set the FatalError bit in the drive status.
; The AC1 will clear the FatalError bit on the rising edge of
; SV_MASTER_ENABLE, but it may be immediately set again if the fatal
; error condition persists. 
;
; The PLC is not guaranteed to see another rising edge of the fatal error bit
; since (1) the drive status packets are updated at 250Hz
; and the PLC runs at 50Hz, and 2) even if monitored in a fast stage,
; the AC1 can re-generate an error at 4000Hz before a new status from
; the AC1 drive is ever sent.
; 
; The PLC therefore will catch the error on the rising edge of the
; fatal error bit of any AC1 axis, or if SV_MASTER_ENABLE has been on for 
; one second and the fatal error bit is still set on any axis.
; Check the fatal error bit from each drive
IF TRUE THEN BITTST SV_HSC_DRIVE_1_STATUS_4 0 AC1Drive1FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_2_STATUS_4 0 AC1Drive2FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_3_STATUS_4 0 AC1Drive3FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_4_STATUS_4 0 AC1Drive4FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_5_STATUS_4 0 AC1Drive5FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_6_STATUS_4 0 AC1Drive6FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_7_STATUS_4 0 AC1Drive7FatalError_M
IF TRUE THEN BITTST SV_HSC_DRIVE_8_STATUS_4 0 AC1Drive8FatalError_M



; Maintain  a timer that expires one second after SV_MASTER_ENABLE is turned on,
; so that we can check if the FatalError bit is not getting cleared by the ACDC.
IF !SV_MASTER_ENABLE THEN RST MasterEnable_T
IF SV_MASTER_ENABLE THEN MasterEnable_T = 1000, set MasterEnable_T




IF AC1Drive1FatalError_M || AC1Drive2FatalError_M || AC1Drive3FatalError_M 
    || AC1Drive4FatalError_M || AC1Drive5FatalError_M THEN (AC1FatalErrorPD)
;NOTE: SV_HSC_DRIVE_1_STATUS_4 through SV_HSC_DRIVE_8_STATUS_4 refer only to 
;      the DRIVE numbers and are not necessarily associated with Axis1-Axis8
;      respectively. For example, if the machine has 4 axes mapped 300 = 2, 
;      301 = 3, 302 = 4, 303 = 1 the following logic will not perform as you 
;      might expect:

;IF SV_AXIS_VALID_1 && AC1Axis1FatalError_M && (AC1FatalErrorPD || MasterEnable_T)
;  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS1_DRIVE_FAULT  

; The above logic will check if DRIVE1 has an error when Axis1 is valid,
; but DRIVE1 is mapped to AXIS4 ( 303 = 1 ). To correct this, pair 
; SV_AXIS_VALID_# with SV_HSC_DRIVE_#... based on the drive mapping:

IF True THEN Axis1DriveMapping_W = SV_MACHINE_PARAMETER_300,
             Axis2DriveMapping_W = SV_MACHINE_PARAMETER_301,
             Axis3DriveMapping_W = SV_MACHINE_PARAMETER_302,
             Axis4DriveMapping_W = SV_MACHINE_PARAMETER_303,
             Axis5DriveMapping_W = SV_MACHINE_PARAMETER_304,
             Axis6DriveMapping_W = SV_MACHINE_PARAMETER_305,
             Axis7DriveMapping_W = SV_MACHINE_PARAMETER_306,
             Axis8DriveMapping_W = SV_MACHINE_PARAMETER_307

             
             
             
             
IF SV_AXIS_VALID_1 && MEM[Axis1DriveMapping_W + 20] && (AC1FatalErrorPD || MasterEnable_T)
  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS1_DRIVE_FAULT
IF SV_AXIS_VALID_2 && MEM[Axis2DriveMapping_W + 20] && (AC1FatalErrorPD || MasterEnable_T)
  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS2_DRIVE_FAULT
IF SV_AXIS_VALID_3 && MEM[Axis3DriveMapping_W + 20] && (AC1FatalErrorPD || MasterEnable_T)
  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS3_DRIVE_FAULT
IF SV_AXIS_VALID_4 && MEM[Axis4DriveMapping_W + 20] && (AC1FatalErrorPD || MasterEnable_T)
  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS4_DRIVE_FAULT
IF SV_AXIS_VALID_5 && MEM[Axis4DriveMapping_W + 20] && (AC1FatalErrorPD || MasterEnable_T)
  THEN SET AC1FatalError_M, ErrorMsg_W = AXIS5_DRIVE_FAULT  
  
IF SV_AXIS_VALID_3 && SV_PC_POWER_AXIS_3 THEN (ZBrakeRelease) 
             
             
;turn on drives IF no errors
IF !PLCFault_M && !SV_STALL_ERROR THEN SET SV_MASTER_ENABLE

IF PLCFault_M || SV_STALL_ERROR || AC1FatalError_M THEN RST SV_MASTER_ENABLE, SET SV_STOP
IF !EstopOK THEN RST AC1FatalError_M
;=============================================================================
                    MainStage
;=============================================================================



if true then BTW XMeterADC_W AnalogInput1 16,
             BTW YMeterADC_W AnalogInput2 16,
			 BTW ZMeterADC_W AnalogInput3 16,
			 BTW AMeterADC_W AnalogInput4 16,
    		 BTW SpindleMeterADC_W AnalogInput5 16

if XMeterADC_W > 32767 then XMeterADC_W = XMeterADC_W - 65536
if YMeterADC_W > 32767 then YMeterADC_W = YMeterADC_W - 65536
if ZMeterADC_W > 32767 then ZMeterADC_W = ZMeterADC_W - 65536
if SpindleMeterADC_W > 32767 then SpindleMeterADC_W = SpindleMeterADC_W - 65536
 
; TODO: Pre-compute constants in initial stage
; The Delta drives put out +/-8V at max torque 
; The spindle is +/-10V
if true then XMeterADC_W = (100 * XMeterADC_W) / 1638,
             YMeterADC_W = (100 * YMeterADC_W) / 1638,
             ZMeterADC_W = (100 * ZMeterADC_W) / 1638,
             SpindleMeterADC_W = (100 * SpindleMeterADC_W) / 2048
 
if true then SV_METER_1 = abs(XMeterADC_W),
             SV_METER_2 = abs(YMeterADC_W),
             SV_METER_3 = abs(ZMeterADC_W),
             SV_METER_5 = abs(SpindleMeterADC_W)
			 
			 
;Do gather if commanded (uncomment and recompile for debugging purposes)
;IF Aux11Key THEN (Aux11KeyPD)
;IF Aux11KeyPD THEN (SV_TRIGGER_PLOT_DUMP)

;----------------------------------------------------------------
;           Probe protection while jogging
;----------------------------------------------------------------
; If the probe comes to be tripped while a jogging move is active,
; then trigger an error (stop jog and output message),
; and also disable jogging in the direction it was going.
IF MechanicalProbe THEN (ProbePD)

IF ProbePD && DoAx1PlusJog THEN SET Ax1PlusJogDisabled_M,
                                SET Ax2MinusJogDisabled_M,
								SET Ax2PlusJogDisabled_M
IF ProbePD && DoAx1MinusJog THEN SET Ax1MinusJogDisabled_M,
                                 SET Ax2MinusJogDisabled_M,
								 SET Ax2PlusJogDisabled_M
IF ProbePD && DoAx2PlusJog THEN SET Ax2PlusJogDisabled_M,
                                SET Ax1MinusJogDisabled_M,
								SET Ax1PlusJogDisabled_M
IF ProbePD && DoAx2MinusJog THEN SET Ax2MinusJogDisabled_M,
                                 SET Ax1MinusJogDisabled_M,
								 SET Ax1PlusJogDisabled_M
IF ProbePD THEN SET Ax3MinusJogDisabled_M

IF ProbePD && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
   DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
   DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog)
  THEN (JogProbeFaultPD)

IF JogProbeFaultPD THEN SET JogProbeFault_M,
                        SET ErrorFlag_M,
                        ErrorMsg_W = PROBE_JOG_TRIP_MSG

; If the probe comes to be tripped while no program cycle is running,
; then save the previous jog mode (fast/slow) and force slow mode.
IF MechanicalProbe && !SV_PROGRAM_RUNNING && !JogModeSaved_M
  THEN (SaveJogModePD),
       SET JogModeSaved_M
IF SaveJogModePD && FastSlowLED THEN SET LastProbeMode_M
IF SaveJogModePD && !FastSlowLED THEN RST LastProbeMode_M
IF MechanicalProbe && !SV_PROGRAM_RUNNING THEN SET FastSlowLED

; Once the probe clears, restore the saved mode and reset
IF !MechanicalProbe && JogModeSaved_M && !LastProbeMode_M
  THEN RST FastSlowLED

IF !MechanicalProbe THEN RST JogModeSaved_M,
                         RST JogProbeFault_M,
                         RST Ax1PlusJogDisabled_M,
                         RST Ax1MinusJogDisabled_M,
                         RST Ax2PlusJogDisabled_M,
                         RST Ax2MinusJogDisabled_M,
                         RST Ax3MinusJogDisabled_M


;Handle Tool Release:
IF ToolRelease && !SpindleEnableOut && !SV_PROGRAM_RUNNING
   && EStopOk THEN SET ToolUnclampOut
IF !ToolRelease THEN RST ToolUnclampOut 

;--Clamp
;IF M10 THEN (Clamp)  ; cleared by M11 or by program not running

;--Process important Keyboard keys all the time
;--Cycle Cancel (ESC)
IF Kb_Escape THEN (KbCycleCancel_M)
;KbFeedHold_M (spacebar)
IF Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING THEN (KbFeedHold_M)

IF SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEventsStage if needed
IF Kb_L_Ctrl || Kb_R_Ctrl ||
   Kb_L_Shift || Kb_R_Shift ||
   Kb_R_Alt || Kb_L_Alt || KbJpActive_M
  THEN SET KeyboardEventsStage

IF (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
   && (Kb_j || Kb_f || Kb_a || Kb_s) && !AllowKbInput_M
  THEN InfoMsg_W = KB_JOG_MSG

;--Handle Faults
IF !EStopOk || PLCFault_M || SV_STALL_ERROR || SpindleFault_M ||
   LubeFault_M || AxisFault_M || ProbeFault_M || OtherFault_M THEN SET SV_STOP

IF SV_STOP THEN RST SV_MASTER_ENABLE

IF !EStopOk THEN RST SV_STALL_ERROR,
                 RST LubeFault_M,
                 RST SpindleFault_M,
                 RST OtherFault_M,
                 RST ProbeFault_M,
                 RST ProbeMsgSent_M

IF Initialize_T && !LubeOk && !SV_PROGRAM_RUNNING
  THEN SET LubeFault_M, FaultMsg_W = LUBE_FAULT_MSG

IF !LubeOk THEN (LowLubePD)
IF LowLubePD && SV_PROGRAM_RUNNING THEN InfoMsg_W = LUBE_WARNING_MSG


IF Initialize_T && !SpindleInverterOk
  THEN FaultMsg_W = SPINDLE_FAULT_MSG, SET SpindleFault_M
IF !EStopOk && !SpindleInverterOk THEN (InverterResetOut)

;OpticDirect bits
; SV_DRIVE_STATUS_1
;  5 = alarm bit 3, 6 = alarm bit 2, 7 = alarm bit 1, 8 = /TGON,
;  9 = brake state, 10 = /S_RDY, 11 = quadrature Error, 12 = direction,
;  13 = Index pulse, 14 = diff. error, 15 = drive fault
; SV_DRIVE_CONTROL_1
;  7 = POS_CLR, 8 = P-OT, 9 = N-OT, 10 = /P-CON, 11 = /P-CL, 12 = /N-CL,
;  13 = ABS. send, 14 = Alarm reset, 15 = enable
IF !EstopOk THEN BITSET Sv_Control_1_Shadow 14,
                 BITRST Sv_Control_1_Shadow 7
IF EstopOk THEN BITRST Sv_Control_1_Shadow 14,
                BITSET Sv_Control_1_Shadow 7

IF True THEN SV_DRIVE_CONTROL_1 = Sv_Control_1_Shadow,
             SV_DRIVE_CONTROL_2 = Sv_Control_1_Shadow,
             SV_DRIVE_CONTROL_3 = Sv_Control_1_Shadow,
             SV_DRIVE_CONTROL_4 = Sv_Control_1_Shadow,
             SV_DRIVE_CONTROL_5 = Sv_Control_1_Shadow

IF True THEN WTB SV_DRIVE_STATUS_1 Axis1StatusBit0 16,
             WTB SV_DRIVE_STATUS_2 Axis2StatusBit0 16,
             WTB SV_DRIVE_STATUS_3 Axis3StatusBit0 16,
             WTB SV_DRIVE_STATUS_4 Axis4StatusBit0 16,
             WTB SV_DRIVE_STATUS_5 Axis5StatusBit0 16

IF !Axis1DriveALM THEN (Axis1DriveOk)
IF !Axis2DriveALM THEN (Axis2DriveOk)
IF !Axis3DriveALM THEN (Axis3DriveOk)
IF !Axis4DriveALM THEN (Axis4DriveOk)

IF true THEN SvToolNum_W = SV_TOOL_NUMBER


; Echo some system variables to memory bits, for troubleshooting only
IF SV_MASTER_ENABLE THEN (MasterEnable_M)
IF SV_STALL_ERROR THEN (Stall_M),
                       StallReason_W = SV_STALL_REASON,
                       StallAxis_W = SV_STALL_AXIS
IF SV_STOP THEN (Stop_M)

IF !SV_STOP THEN (NoFaultOut)

; Reset faults if E-stop is released and no fault condition persists
IF EStopOk &&
   !(PLCFault_M || SV_STALL_ERROR || SpindleFault_M || LubeFault_M ||
     AxisFault_M || OtherFault_M || SoftwareNotReady_M || PLCExecutorFault_M)
  THEN RST SV_STOP

; Automatically reset non-fault errors after a short time
IF ErrorFlag_M THEN SET ErrorFlag_T
IF ErrorFlag_T THEN RST ErrorFlag_M, RST ErrorFlag_T

IF ProbeFault_M && !ProbeMsgSent_M
  THEN FaultMsg_W = PROBE_FAULT_MSG, SET ProbeMsgSent_M

;--M-Codes
; Reset these M-codes if not in CNC Program Running mode
IF !SV_PROGRAM_RUNNING
  THEN RST M3,
       RST M4,
       RST M8,
       RST M7,
       RST M10

; Detect auto spindle and coolant requests during manual modes
IF M3 || M4 THEN (AutoSpindlePD)
IF AutoSpindlePD && !SpinAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_SPINDLE_PROMPT

IF M7 || M8 THEN (AutoCoolantPD)
IF AutoCoolantPD && !CoolAutoModeLED
  THEN SET ActivateFeedHold_M,
       InfoMsg_W = AUTO_COOLANT_PROMPT

IF ActivateFeedHold_M THEN TriggerPause_T=100, SET TriggerPause_T
IF TriggerPause_T THEN RST TriggerPause_T, RST ActivateFeedHold_M

;Clamp/Unclamp tool - Tool release & M15
IF true THEN ToolClampUnclampTimer = 1500
IF !SV_STOP && ZeroSpeed && (ToolRelease || (M15 && SV_PROGRAM_RUNNING)) 
  THEN (ToolUnclampOut), SET UnclampingTool_M, SET ToolClampUnclampTimer
  
IF ToolUnclampOut THEN (AirBlow)  
  
IF (UnclampingTool_M && ToolUnclamped) 
  THEN RST ToolClampUnclampTimer
  
IF !ToolRelease && !M15 
  THEN RST UnclampingTool_M, RST ToolClampUnclampTimer    
  
IF !SV_PROGRAM_RUNNING THEN RST M15  

IF ToolClampUnclampTimer 
  THEN FaultMsg_W = TOOL_CLAMP_UNCLAMP_FAULT, SET OtherFault_M
  
;Orient spindle
IF true THEN OrientTimer = 5000, OrientLostTimer = 200
IF M19 THEN set OrientRequest  
IF OrientRequest THEN SET OrientTimer
IF OrientRequest && OrientComplete THEN SET MonitorOrient_M, RST OrientTimer 
IF OrientRequest && !OrientComplete && MonitorOrient_M 
  THEN SET OrientLostTimer
IF OrientComplete THEN RST OrientLostTimer  
  
IF ToolUnclampOut || !SV_PROGRAM_RUNNING 
  THEN RST M19, RST OrientRequest, RST MonitorOrient_M, RST OrientLostTimer,
  RST OrientTimer

IF OrientLostTimer THEN FaultMsg_W = ORIENT_LOST_FAULT, SET OtherFault_M  
IF OrientLostTimer THEN FaultMsg_W = ORIENT_TIMEOUT, SET OtherFault_M  
  

  

;Carousel In
IF true THEN CarouselInOutTimer = 3500
IF ZeroSpeed && ((OrientComplete && M80 && M6) || (M80 && AtcOverrideKey))
  THEN RST M81, SET CarouselInSol, SET CarouselInOutTimer, 
  SET MovingCarouselIn_M, RST MovingCarouselOut_M
  
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselIn_M && CarouselIsIn)
  THEN RST CarouselInSol, RST M80 

;CarouselOut
IF (M81 && M6) || (M81 && AtcOverrideKey)
  THEN RST M80, SET CarouselOutSol, SET CarouselInOutTimer, 
  SET MovingCarouselOut_M, RST MovingCarouselIn_M
  
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselOut_M && CarouselIsOut)
  THEN RST CarouselOutSol, RST M81  
  
;RST Timer on successful completion, job cancellation or fault
IF SV_STOP || !SV_PROGRAM_RUNNING || (MovingCarouselIn_M && CarouselIsIn) || 
  (MovingCarouselOut_M && CarouselIsOut)
  THEN RST CarouselInOutTimer, RST MovingCarouselIn_M, RST MovingCarouselOut_M 

IF (MovingCarouselIn_M && CarouselInOutTimer) || 
  (MovingCarouselOut_M && CarouselInOutTimer) 
  THEN FaultMsg_W = CAROUSEL_IN_OUT_TIME_OUT, SET OtherFault_M 

IF !AirPressureOk && (ToolUnclampOut || M80 || M81)
  THEN FaultMsg_W = LOW_AIR_FAULT, SET OtherFault_M   

;--Worklight
IF Aux7Key THEN (Aux7PD)
IF (Aux7PD ^ Aux7LED) || OnAtPowerUp_M THEN (Aux7LED)
IF Aux7LED THEN (WorkLightOut)

;--turn off default setup variable
IF True THEN RST OnAtPowerUp_M


;==============================================================================
                        MonitorIndexATCRequestStage
;==============================================================================
IF Aux8Key && !SV_STOP THEN (Aux8PD)
IF (Aux8PD && !DoingIndex_M) && (!SV_PROGRAM_RUNNING ||(SV_MDI_MODE && 
  SV_PROGRAM_RUNNING && !DoingM6_M)) 
  THEN SET DoingIndexMinus_M, SET DoingIndex_M, SET SetRequestedBinPositionStage  

IF Aux9Key && !SV_STOP THEN (Aux9PD)  
IF (Aux9PD && !DoingIndex_M) && (!SV_PROGRAM_RUNNING ||(SV_MDI_MODE && 
  SV_PROGRAM_RUNNING && !DoingM6_M)) 
  THEN SET DoingIndexPlus_M, SET DoingIndex_M, SET SetRequestedBinPositionStage

IF (Aux8PD || Aux9PD) && M6
  THEN InfoMsg_W = MANUAL_INDEX_WHILE_ATC, RST DoingIndex_M   

IF M6 && !DoingIndex_M 
  THEN (M6PD)
  
IF M6 && (DoingIndexMinus_M || DoingIndexPlus_M)
  THEN RST M6, InfoMsg_W = ATC_WHILE_MANUAL_INDEX 
  
IF M6PD THEN SET DoingM6_M, SET SetRequestedBinPositionStage

  
;==============================================================================
                         ReportCarouselPositionStage
;==============================================================================
;Note, when carousel is reversed, the first count received after the carousel 
;direction was changed needs to be thrown out. This is accomplished with 
;by setting CarouselReversed_M when the Carousel direction is changed. 
;After the first count has been ignored, CarouselReversed_M is reset and counting
;is resumed. M18 is used in in cncm.hom to drive the carousel in the CW direction
;until CarouselAtHome (INP28) so that the initial direction is always known.

IF true THEN MaxBinLocation_W = SV_MACHINE_PARAMETER_161
IF !ToolCounter && CarouselEnable 
  THEN SET ToolCounterArmed_M 
IF ToolCounterArmed_M && ToolCounter 
  THEN (ToolCounterPD), RST ToolCounterArmed_M

IF ToolCounterPD && !CarouselCCW
  THEN CarouselPosition_W = CarouselPosition_W - 1
IF ToolCounterPD && CarouselCCW
  THEN CarouselPosition_W = CarouselPosition_W + 1

IF CarouselPosition_W > MaxBinLocation_W THEN CarouselPosition_W = 1  
IF CarouselPosition_W < 1 THEN CarouselPosition_W = MaxBinLocation_W
IF M18 THEN CarouselPosition_W = 1, RequestedBinPosition_W = 1, PutBackPosition_W = 1
IF !SV_PROGRAM_RUNNING THEN RST M18, RST DoingM18_M

IF true THEN SV_PLC_CAROUSEL_POSITION = CarouselPosition_W

;==============================================================================
                       SetRequestedBinPositionStage
;==============================================================================
IF DoingIndexPlus_M THEN RequestedBinPosition_W = CarouselPosition_W + 1 
IF DoingIndexMinus_M THEN RequestedBinPosition_W = CarouselPosition_W - 1
IF DoingIndex_M && (RequestedBinPosition_W > MaxBinLocation_W)
  THEN RequestedBinPosition_W = 1 
IF DoingIndex_M && (RequestedBinPosition_W < 1) 
  THEN RequestedBinPosition_W = MaxBinLocation_W   

IF DoingM6_M && (CarouselPosition_W == PutBackPosition_W)   
  THEN RequestedBinPosition_W = SV_TOOL_NUMBER, 
  SET AtPutbackLocation_M, SET WaitingForPutbackComplete_M
  
IF DoingM6_M && RequestedBinPosition_W - 1 != CarouselPosition_W
  THEN SET WTF_M   
  
IF PutBackPosition_W == 0 THEN RST WaitingForPutbackComplete_M  
  
IF DoingM6_M && (CarouselPosition_W != PutBackPosition_W) &&
  ((PutBackPosition_W != 0) && DoingM6_M) 
  THEN RequestedBinPosition_W = PutBackPosition_W, SET DoingPutback_M

IF true THEN RST DoingIndexMinus_M, RST DoingIndexPlus_M, JMP SetCarouselDirectionStage

;==============================================================================
                        SetCarouselDirectionStage
;==============================================================================

;CW 1-2-3
IF ((RequestedBinPosition_W > CarouselPosition_W) && 
 (RequestedBinPosition_W - CarouselPosition_W <= (MaxBinLocation_W / 2))) ||
 ((RequestedBinPosition_W < CarouselPosition_W) &&
 (CarouselPosition_W - RequestedBinPosition_W > (MaxBinLocation_W / 2)))
 THEN SET CarouselCCW

;CCW 3-2-1
IF M18 || (((RequestedBinPosition_W < CarouselPosition_W) && 
 (CarouselPosition_W - RequestedBinPosition_W <= (MaxBinLocation_W / 2))) ||
 ((RequestedBinPosition_W > CarouselPosition_W) &&
 (RequestedBinPosition_W - CarouselPosition_W > (MaxBinLocation_W / 2))))
 THEN RST CarouselCCW
 
IF true THEN JMP RotateCarouselStage 
 
;==============================================================================
                             RotateCarouselStage
;==============================================================================
IF (DoingM6_M || DoingIndex_M) && (RequestedBinPosition_W != CarouselPosition_W) &&
  !WaitingForPutbackComplete_M
  THEN SET CarouselEnable
  
IF DoingPutback_M && CarouselEnable THEN SET WaitingForPutbackComplete_M
IF PutbackComplete || !SV_PROGRAM_RUNNING THEN RST DoingPutback_M, RST WaitingForPutbackComplete_M  
  
IF (RequestedBinPosition_W == CarouselPosition_W)
  THEN RST CarouselEnable

IF (RequestedBinPosition_W == CarouselPosition_W) && DoingM6_M && 
  !CarouselEnable && !AtPutbackLocation_M
  THEN JMP SetRequestedBinPositionStage
  
IF (RequestedBinPosition_W == CarouselPosition_W) && DoingM6_M &&  
  AtPutbackLocation_M && !AtRequestedToolLocation_M && PutbackComplete
  THEN SET AtRequestedToolLocation_M, SET ToolChangeComplete_M  
  
IF ((RequestedBinPosition_W == CarouselPosition_W) && DoingM6_M && AtPutbackLocation_M &&
  AtRequestedToolLocation_M && ToolChangeComplete_M && !M6) || SV_STOP
  THEN RST RotateCarouselStage, RST CarouselEnable, RST SetCarouselDirectionStage,
  RST RotateCarouselStage, RST SetRequestedBinPositionStage, RST DoingM6_M, 
  RST M6, RST AtPutbackLocation_M, RST AtRequestedToolLocation_M, 
  RST ToolChangeComplete_M, PutBackPosition_W = CarouselPosition_W
  
IF (RequestedBinPosition_W == CarouselPosition_W) && DoingIndex_M
  THEN RST DoingIndex_M  
  

  


;==============================================================================
                            ResetCarouselStage
;==============================================================================
IF SV_STOP || (!SV_PROGRAM_RUNNING && M6) 
  THEN RST DoingIndexMinus_M, RST DoingIndexPlus_M, RST DoingIndex_M,
  RST CarouselEnable, RST SetCarouselDirectionStage, RST RotateCarouselStage,
  RST SetRequestedBinPositionStage, RST DoingM6_M, RST M6, RST AtPutbackLocation_M,
  RST AtRequestedToolLocation_M, RST ToolChangeComplete_M, RST DoingPutback_M 

IF !SV_PROGRAM_RUNNING THEN RST CarouselHomeComplete_M, RST DoingM18_M, 
  RST WaitingForPutbackComplete_M, RST PutbackComplete 

  

 
;================================================================
   MessageStage
;================================================================
IF FaultMsg_W != 0 THEN SET ShowFaultStage
IF FaultMsg_W == 0 && ErrorMsg_W != 0 THEN SET ShowErrorStage, RST ShowInfoStage
IF FaultMsg_W == 0 && !ShowErrorStage && InfoMsg_W != 0 THEN SET ShowInfoStage

;================================================================
   ShowFaultStage
;================================================================
IF !((FaultMsg_W % 256 == 1) || (FaultMsg_W % 256 == 2))
  THEN BadMsg_W = FaultMsg_W, JMP BadMsgStage
IF !EStopOk THEN FaultMsg_W = MSG_CLEARED_MSG,
                 SET MsgClear_T
IF True THEN MSG FaultMsg_W
IF MsgClear_T THEN FaultMsg_W = 0,
                   RST MsgClear_T,
                   RST ShowFaultStage

;================================================================
   ShowErrorStage
;================================================================
IF !((ErrorMsg_W % 256 == 1) || (ErrorMsg_W % 256 == 2))
  THEN BadMsg_W = ErrorMsg_W, JMP BadMsgStage
IF True THEN MSG ErrorMsg_W, SET MsgClear_T
IF MsgClear_T THEN ErrorMsg_W = ASYNC_MSG_CLEAR,
                   MSG ErrorMsg_W,
                   ErrorMsg_W = 0,
                   RST MsgClear_T,
                   RST ShowErrorStage

;================================================================
   ShowInfoStage
;================================================================
IF !((InfoMsg_W % 256 == 1) || (InfoMsg_W % 256 == 2))
  THEN BadMsg_W = InfoMsg_W, JMP BadMsgStage
IF True THEN MSG InfoMsg_W, SET MsgClear_T
IF MsgClear_T THEN InfoMsg_W = ASYNC_MSG_CLEAR,
                   MSG InfoMsg_W,
                   InfoMsg_W = 0,
                   RST MsgClear_T,
                   RST ShowInfoStage

;=============================================================================
   BadMsgStage
;=============================================================================
IF True THEN FaultMsg_W = 0,
             ErrorMsg_W = 0,
             InfoMsg_W = BAD_MESSAGE_MSG,
             RST BadMsgStage
