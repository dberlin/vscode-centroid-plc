;  File:           rtk4-atc-articulated-head-slide-r6.src
;  Programmer:     Lee Johnston
;  Date:           June 14 2012
;  Revision Date:  22 Oct 2012
;  Purpose:        Swingarm ATC Program for MPU11/GPIO4D w/optic direct
;  Requires:       CNC11 v3.06+
;
;       Modified - Latest Modification goesn on TOP!
;       RSP - 22 OCT 2012 Added MPG disable if probe is tripped while mpg is 
; enabled. MPG can be re-enabled by pressing the ATCOverride key or clearing
; the probe.  Message requires custom M40 and parm 190 set to 4011. Probe must 
; be tripped for > 500 milli sec timer before message and operator 
; intervention is required.  This is used to prevent probe trips caused by 
; machine vibration from forcing the operator to us the override key 
; to continue.  While mpg motion IS disabled when probe is actually tripped, if
; the probe clears within 500 milli seconds the message is not issued and the 
; override key is not required to continue
          
;       RSP   9 OCT 2012  Removed stale debug code which was preventing spindle fault
;                         from being reported
;       LDJ - 1 OCT 2012  Added SV_SCALE_INHIBIT_AXIS_4 support for 4th axis. 
;                         It is programmed into the M10 functionality
;       RSP   1 OCT 2012  Changed Lube fault to allow jogging after Estop is cycled  
;       LDJ - Sep 10 2012: Added Skimmer functionality
;                          Fixed Auger functionality
;                          Removed RedLight and added Worklight2
;       LDJ - JUN 12 2012: Base program based on rtk4-atc-a-optic-direct-rs.src for 
;                          new version of sliding articulated head machine.
;       RSP - 4 JUNE 2012 Added debounce timer (40 milli) to try to isolate
;                         spurious spindle faults  
;       RSP - 30 May 2012 Added Spindle restart from feedhold if spindle was 
;                         stopped during feedhold and M3 is active when 
;                         CycleStartKey is pressed to resume job.
;       RSP - 30 May 2012 Fixed Mist functionality which was broked when Optic
;                         Direct was added (MEM451 assigned twice)  
;       LDJ - May 3 2012: New program based on gpio4d-atc-a
;       LDJ - May 8 2012: moved m19 to main section so orient works with no atc enabled



;Function:
;1. ATC Swing Arm
;   a. P6 = 1 to activate ATC stages and restart control+MPU11
;   b.
;2. Door interlock 
;   If door is open or not set correctly, control will be limited to slow jog only.
;   If door is open and MDI or program running, control will display WAIT FOR DOOR CLOSE message
;   and feedhold condition. End-user will have to close the door and press cycle start to resume. 
;   After 10 seconds () control will fault with DOOR NOT LOCKED message (E-Stop condition)
;   a. P85 must be set to the door closed input number 
;   b. P85 = 0 to disable doorinterlock stage and function. 
;   c. DoorInterlock_Override_M (M136) can be set when probe is connected and Aux13 + Aux14 
;      pressed at same time.
;3. Dual Chip Auger
;   a. forward - Aux 5 and M31, M33 to Stop
;   b. reverse - Aux 6 and M32, M33 to stop
;   c. P171 = 1 to enable the chip auger 1 or 2 selection, Aux4Key is the selection key
;4. Tool Thru Coolant
;   a. M88 - to turn it on. M89 - to turn it off
;
; Mpu11 based systems have the ability to invert, force and/or select a custom
; debounce time on PLC inputs 1-240 using SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64.
; Jog Panel inputs are modified in the same manner using SV_JOG_LINK_DEBOUNCE_1
; -SV_JOG_LINK_DEBOUNCE_64. See system variable section for more information.

; The Mpu11 board includes connections for several types of auxillary I/O.
; 4 digital "high speed" inputs (INP769-772) typically used for probe/TT1
; related functions,, 3 auxillary digital inputs (INP784-786), 11 Digital inputs
; used for MPG increment and axis selection and 2 auxillary digital outputs
; (Out770-771).

; GP4IOD Physical I/O: While each GPIO4D that is installed reserves (maps) 32
; inputs and 32 Outputs, only 20 inputs and 24 outputs are accessible through
; hardware.

; Inputs: The GPIO4D provides 20 inputs, 16 of which (1-16) are available for
; general purpose use.  Inputs 1-16 can be configured for 5, 12 or 24VDC
; operation in either a sourcing or sinking configuration.  Inputs 17-20 are a
; contact closure type input (input must be closed to the input common) which
; are generally reserved for drive fault inputs.  One of these inputs are found
; on each of the axis control headers (H11-H14) and are labeled as "Fault In"
; Outputs: The GPIO4D has 16 relay contact closure outputs.  Outputs 1-7, 10-16
; are SPST type relays while Outputs 8 & 9 are SPDT type relays.  Each
; mapped PLC output from 17-20 actually controls 2 Open Collector type outputs.
; The purpose of each of these paired outputs are to control an enable
; and brake output for each axis.  One pair of these outputs are found on each 
; of the axis control headers (H11-H14) and are labeled as "Drive Enable" &
; "Brake Out"
; Analog outputs: The 12 bit 0-10VDC analog output on the GPIO4D is mapped to
; outputs 305-316.  NOTE: The spindle speed command that comes down from the PC
; (SV_PC_DAC_SPINDLE_SPEED) is a 16 bit integer value from 0-65535 that must be
; converted to a 12 bit value from 0-4095 by the PLC.  The PLC handles gear ranges
; by looking at the state of inputs and reading parameters (or hard coded values)
; to determine the ratio needed for adjusting the spindle speed display system
; variable
;
;=============================================================================
;                   CONSTANT DEFINITIONS
;=============================================================================
PLC_EXECUTOR_FLT_MSG    IS 1+256
AXIS1_INFLT             IS 1282;(2+256*5) Fiber to MPU11 from axis drive has a problem
AXIS2_INFLT             IS 1538;(2+256*6)
AXIS3_INFLT             IS 1794;(2+256*7)
AXIS4_INFLT             IS 2050;(2+256*8)
AXIS5_INFLT             IS 2306;(2+256*9)
AXIS6_INFLT             IS 2562;(2+256*10)
AXIS7_INFLT             IS 2818;(2+256*11)
AXIS8_INFLT             IS 3074;(2+256*12)

AXIS1_OUTFLT            IS 3330;(2+256*13) Fiber to axis drive from MPU11 has a problem
AXIS2_OUTFLT            IS 3586;(2+256*14)
AXIS3_OUTFLT            IS 3842;(2+256*15)
AXIS4_OUTFLT            IS 4098;(2+256*16)
AXIS5_OUTFLT            IS 4354;(2+256*17)
AXIS6_OUTFLT            IS 4610;(2+256*18)
AXIS7_OUTFLT            IS 4866;(2+256*19)
AXIS8_OUTFLT            IS 5122;(2+256*20)

AXIS_FLT_CLR            IS 5378;(2+256*21)

PLC_INFLT               IS 5634;(2+256*22)
PLC_OUTFLT              IS 5890;(2+256*23)
PLC_FLT_CLR             IS 6146;(2+256*24)

AXIS1_DRIVE_FAULT       IS 6401;(1+256*25)
AXIS2_DRIVE_FAULT       IS 6657;(1+256*26)
AXIS3_DRIVE_FAULT       IS 6913;(1+256*27)
AXIS4_DRIVE_FAULT       IS 7169;(1+256*28)
AXIS5_DRIVE_FAULT       IS 7425;(1+256*29)

SPINDLE_FAULT           IS 7681;(1+256*30)
SPINDLE_CHILLER_FAULT   IS 1 + 256*31
PROBE_FAULT_MSG         IS 8705;(1+256*34)

KB_JOG_MSG              IS 8962;(2+256*35)

LUBE_FAULT_MSG          IS 9217;(1+256*36)
LUBE_WARNING_MSG        IS LUBE_FAULT_MSG+1
PROBE_JOG_FAULT_MSG     IS 9473;(1+256*37)

MIN_SPEED_MSG           IS 9730;(2+256*38)
SOFTWARE_EXIT_MSG       IS 1+256*39
MSG_CLEARED_MSG         IS 25345;(1+256*99)

;// ATC FAULT Message Definitions:

ATC_NR_ARM_HOME                      IS 1 + 256*101
ATC_NR_ARM_AT_CLAMP                  IS 1 + 256*102
ATC_NR_ARM_AT_STOP                   IS 1 + 256*103
ATC_NR_TOOL_UNCLMP                   IS 1 + 256*104
ATC_NR_TOOL_CLMP                     IS 1 + 256*105
ATC_NR_POT_DOWN                      IS 1 + 256*106
ATC_NR_POT_UP                        IS 1 + 256*107
ATC_NR_TOOL_COUNTER                  IS 1 + 256*108
ATC_BIN_OUT_OF_RANGE                 IS 1 + 256*109
ATC_NR_MZ_ACK                        IS 1 + 256*110
ATC_TIMEOUT_MOVE_Z_STAGE             IS 1 + 256*111
ATC_TIMEOUT_ORIENT_STAGE             IS 1 + 256*112
ATC_TIMEOUT_POT_DOWN_STAGE           IS 1 + 256*113
ATC_ORIENT_LOST_POT_DOWN_STAGE       IS 1 + 256*114
ATC_CLAMP_WO_STOP_AHTC_STAGE         IS 1 + 256*115
ATC_TIMEOUT_ARM_TO_CLAMP             IS 1 + 256*116
ATC_TIMEOUT_WAIT_STOP_AHTC_STAGE     IS 1 + 256*117
ATC_HOME_CLAMP_WO_STOP_AHTC_STAGE    IS 1 + 256*118
ATC_TIMEOUT_UNCLAMP_STAGE            IS 1 + 256*119
ATC_TIMEOUT_ARM_D180UP_STAGE         IS 1 + 256*120
ATC_TIMEOUT_ARM_D1UWS_STAGE          IS 1 + 256*121
ATC_HOME_CLAMP_WO_STOP               IS 1 + 256*122
ATC_TIMEOUT_CLAMP_STAGE              IS 1 + 256*123
ATC_TIMEOUT_ARM_CTH                  IS 1 + 256*124
ATC_WO_STOP_ACTH_HOME_STAGE          IS 1 + 256*125
ATC_TIMEOUT_ARM_HTCWS_STAGE          IS 1 + 256*126
ATC_WO_STOP_ARM_HOME_CLAMP           IS 1 + 256*127
ATC_TIMEOUT_POT_UP_STAGE             IS 1 + 256*128
ATC_TIMEOUT_END_STAGE                IS 1 + 256*129
ATC_CLAMP_FAULT_ARM_D180UP_STAGE     IS 1 + 256*131
ATC_CLAMP_FAULT_ARM_D1UWS_STAGE      IS 1 + 256*132
ATC_TOOL_COUNTER_NOISE               IS 1 + 256*133
ATC_TIMEOUT_TOOL_COUNTER             IS 1 + 256*134
ATC_POT_FAULT_ROTATE_STAGE           IS 1 + 256*135
ATC_TOOL_COUNTER_NOISE_COUNT_STAGE   IS 1 + 256*136
ATC_TIMEOUT_TOOL_COUNTER_COUNT_STAGE IS 1 + 256*137
ATC_POT_FAULT_COUNT_STAGE            IS 1 + 256*138
ATC_INITIALIZED                      IS 2 + 256*139
ATC_TOOL_COUNTER_FAULT_CLEARED       IS 2 + 256*140
LOW_AIR_FAULT                        IS 1 + 256*142
M19_FAULT_TOOL_CLAMPED               IS 1 + 256*143
M19_STOPPED_M19_STAGE                IS 1 + 256*144
M19_ORIENT_LOST_M19_MON_STAGE        IS 1 + 256*145
ATC_TIMEOUT                          IS 1 + 256*146
SPINDLE_EMPTY                        IS 38402; (2 + 256*150)

DOOR_NOT_CLOSED                      IS 2 + 256*195
WAITING_FOR_DOOR_CLOSED               IS 2 + 256*196
DOOR_NOT_LOCKED                      IS 1 + 256*197
DOOR_OPEN_MESSAGE                    IS 1 + 256*198

;----------------------------------------
;        PLC Input Definitions
;----------------------------------------
; Logic 1 = CLOSED SWITCH, 0 = Open

;// INP1 - INP768 Physical PLC inputs
Ax1_MinusLimitOk        IS INP1
Ax1_PlusLimitOk         IS INP2
Ax2_MinusLimitOk        IS INP3
Ax2_PlusLimitOk         IS INP4
Ax3_MinusLimitOk        IS INP5
Ax3_PlusLimitOk         IS INP6
Ax5_MinusLimitOk        IS INP21
ArmCarrriageHome        IS INP8
LubeOk                  IS INP9
SpindleInverterOk       IS INP10
EStopOk                 IS INP11   ; 1 = ok
NoTool                  IS INP12
RotaryHome              IS INP13
DoorClosed              IS INP14
DoorLocked              IS INP15
RotaryClamped           IS INP16 
;Axis1DriveOk            IS INP17 ;Labeled "Fault In" on drive output header H14
;Axis2DriveOk            IS INP18 ;Labeled "Fault In" on drive output header H13
;Axis3DriveOk            IS INP19 ;Labeled "Fault In" on drive output header H12
;Axis4DriveOk            IS INP20 ;Labeled "Fault In" on drive output header H11
SpinOk2                 IS INP25

ZeroSpeed               IS INP33   ; Was 0 Speed
OrientComplete          IS INP34   ; 1 = Oriented
ToolClamped             IS INP35   ;
ToolUnclamped           IS INP36   ;
ToolRelease             IS INP37   ;
ChillerOk               IS INP38
; Spare                 IS INP39
; Spare                 IS INP40
ToolCounter             IS INP41   ;
PotUp                   IS INP42   ;
PotDown                 IS INP43   ;
ThruCoolantOk           IS INP44
AirPressureOk           IS INP45   ;
ArmAtClampInput         IS INP46
ArmAtStopInput          IS INP47
ArmAtHomeInput          IS INP48

;----------------------------------------------------
; M-Function bits are no longer mapped as PLC inputs
; 33-48.  M-Function bits are now mapped as system
; variables.  See system variables section
;----------------------------------------------------
;                       INP33-INP48
;----------------------------------------------------
; Jog panel inputs are no longer mapped as PLC inputs
; 49-??.  All jJog panel inputs are now mapped as
; INP833-INP1088 and can be referenced as such.
; Alternatively, jog panel inputs can also be
; referenced using JPI1 through JPI256 (INP833-JPI256)
;-----------------------------------------------------
;                       INP49-58, INP63 ->....
; INP 59-62 moved to 34-37

;-------------------------------------------------------------------------------
;// INP769 - INP784 Reserved for MPU11 onboard connections, only 4 present now
;// The names given below are not "official" standard wiring yet.
;-------------------------------------------------------------------------------
MechanicalProbe       IS INP769
DSPProbe              IS INP770
ProbeDetect           IS INP771
ProbeAux              IS INP772
MPG_Inc_X_1           IS INP773
MPG_Inc_X_10          IS INP774
MPG_Inc_X_100         IS INP775
MPG_AXIS_1            IS INP776
MPG_AXIS_2            IS INP777
MPG_AXIS_3            IS INP778
MPG_AXIS_4            IS INP779
MPG_AXIS_5            IS INP780
MPG_AXIS_6            IS INP781
MPG_AXIS_7            IS INP782
MPG_AXIS_8            IS INP783

;----------------------------------------
;       PLC Output Definitions
;----------------------------------------
;// OUT1 - OUT768 Physical PLC inputs
NoFaultOut              IS OUT1     ;
LubeOut                 IS OUT2     ;
FloodOut                IS OUT3     ;
spindleairout           IS OUT4     ;
InverterResetOut        IS OUT5     ;
FifthClampOut           IS OUT6     ; This is for the 4th axis rotary clamp on Block Machine 
SpindleEnableOut        IS OUT7     ;
SpindleDirectionOut     IS OUT8     ; NO/NC contact 1 = CCW
TailstockClampOut       IS OUT9     ; SPDT
CoolingFanOut           IS OUT10
WorkLightOut            IS OUT11    ;
OrientRequestOut        IS OUT12    ;
SpindleChillerOut       IS OUT13    ;
ToolUnclampOut          IS OUT14    ;
AirBlowOut              IS OUT15    ;
DriveResetOut           IS OUT16    ; SPST

;  NOTE: The GPIO4D features an internally controlled SPDT relay which is
;        physically located next to OUT16 on H2.  This output is not OUT17
;        nor is it accessible via the PLC.  In the GPIO4D manual it is simply
;        referred to as "fault" and is described as follows - 
;        "The fault output will remain closed as long as the GPIO4D does
;        not detect any serious errors, such as a loss of communication."
;
;        It is suggested that, when considering your Estop loop, you wire
;        this relay in series with a PLC controllable output such as OUT1
;        NoFaultOut.  Wiring in this manner will ensure that the Estop loop
;        will be disconnected when:;
;        1. The operator presses the Estop switch.
;        2. The PLC detects a stop fault condition.
;        3. Communications are lost to the GPIO4D/PLC.
;        nor is it accessible via the PLC.  In the GPIO4D manual it is simply
;        referred to as "fault" and is described as follows:
;        "The fault output will remain closed as long as the GPIO4D does
;        not detect any serious errors, such as a loss of communication."
;
;        It is suggested that, when considering your Estop loop, you wire
;        this relay in series with a PLC controllable output such as OUT1,
;        NoFaultOut.  Wiring in this manner will ensure that the Estop loop
;        will be disconnected when:
;
;        1. The operator presses the Estop switch.
;        2. The PLC detects a stop fault condition.
;        3. Communications are lost to the GPIO4D/PLC.

; The open collector outputs will pull the signal they are connected to 0VDC
; when turned on.  The common (0V) of the signal your device accepts should
; be connected to the OUT COM of the respective enable/brake output listed
; below.

;Axis_1_Enable         IS OUT17 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H14
;Axis_2_Enable         IS OUT18 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H13
;Axis_3_Enable         IS OUT19 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H12
;Axis_4_Enable         IS OUT20 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H11



ChipPumpOut             IS OUT24  ; SPST
WorkLightOut2           IS OUT33  ; SPST
AmberLightOut           IS OUT34  ; SPST
GreenLightOut           IS OUT35  ; SPST
PotUpOut                IS OUT36  ; SPST
PotDownOut              IS OUT37  ; SPST

MagMotorCWOut       IS OUT39  ; SPST
MagMotorCCWOut        IS OUT40  ; SPDT Tool Magazine NC/NO relay 1 = Minus Dir
ArmMotorOut             IS OUT41  ; SPDT Type
; Spare                 IS OUT42  ; SPST
DoorUnLockOut           IS OUT43  ; SPST
ThruCoolantOut          IS OUT44  ; SPST
Auger1FwdOut            IS OUT45  ; SPST
Auger1RevOut            IS OUT46  ; SPST
SkimmerOut              IS OUT47  ; SPST

;----------------------------------------
; For legacy PLC/Drivesthe DAC output
; for spindle spindle control continue
; to be mapped through PLC "Outputs"
; 17-28
;----------------------------------------
; These bits control the actual analog hardware output on the GPIO4D.
; Output = 16bit (0-65536) 0-10VDC.
SpinAnalogOutBit0   	IS OUT321
SpinAnalogOutBit1   	IS OUT322
SpinAnalogOutBit2   	IS OUT323
SpinAnalogOutBit3   	IS OUT324
SpinAnalogOutBit4   	IS OUT325
SpinAnalogOutBit5   	IS OUT326
SpinAnalogOutBit6   	IS OUT327
SpinAnalogOutBit7   	IS OUT328
SpinAnalogOutBit8   	IS OUT329
SpinAnalogOutBit9   	IS OUT330
SpinAnalogOutBit10  	IS OUT331
SpinAnalogOutBit11  	IS OUT332
SpinAnalogOutBit12  	IS OUT333
SpinAnalogOutBit13  	IS OUT334
SpinAnalogOutBit14  	IS OUT335
SpinAnalogOutBit15  	IS OUT336

;---End Spindle DAC mapping---------------

MPG_LED_OUT             IS OUT769

;---------------------------------------------------
;             MEMory Definitions
;---------------------------------------------------

PLCExecutorFault_M      IS MEM1
SoftwareReady_M         IS MEM2
MPGManOffFlag_M         IS MEM3
MasterEnable_M          IS MEM5
DoingM6_M               IS MEM6
DoingIndex_M            IS MEM7
PLCBus_Oe_M             IS MEM8
ErrClr_M                IS MEM9
PLCBus_Online_M         IS MEM10
Ax1PlusJogDisabled_M    IS MEM11
Ax1MinusJogDisabled_M   IS MEM12
Ax2PlusJogDisabled_M    IS MEM13
Ax2MinusJogDisabled_M   IS MEM14
MechanicalProbeEcho_M   IS MEM15
DSPProbeEcho_M          IS MEM16
ProbeDetectEcho_M       IS MEM17
ProbeAuxEcho_M          IS MEM18
LubeFaultCleared_M      IS MEM19
MZ_REQ_M                IS MEM20  ;
END_REQ_M               IS MEM21  ;
HU_REQ_M                IS MEM22  ;
HD_REQ_M                IS MEM23  ;
DoingRotate_M           IS MEM24  ;
Calc_B1_M               IS MEM25
Calc_B2_M               IS MEM26
Tool_NoISe_Fault_M      IS MEM27
ManClampFlag_M          IS MEM28    ;
ClampOutOfProgFlag_M    IS MEM29
FeedHoldFromOverFlag_M  IS MEM30
ATCCount_M              IS MEM31
ATCRotate_M             IS MEM32
ArmAtClampMEM           IS MEM33
ArmAtStopMEM            IS MEM34
ArmAtHoMEMem            IS MEM35
Echo_Stall_M            IS MEM36
Echo_Stop_M             IS MEM37
FeedHoldFromKeyFlag_M   IS MEM38
ProbeTrippedByMPG_M     IS MEM39 
ProbeTrippedOverride_M  IS MEM40
 

LubeFault_M             IS MEM49
PLCFault_M              IS MEM50
AxisFault_M             IS MEM51
PLCBusExtDevEn_M        IS MEM52
ProbeFault_M            IS MEM53
JogProbeFault_M         IS MEM54
Spindle_Fault_M         IS MEM55
KbJpActive_M            IS MEM60 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
Axis1Fault_M            IS MEM61
Axis2Fault_M            IS MEM62
Axis3Fault_M            IS MEM63
Axis4Fault_M            IS MEM64
Axis5Fault_M            IS MEM65
Axis5DriveFault_M       IS MEM66

tempbit                 IS MEM72
ProbeMsgSent_M          IS MEM78
SpinLowRange_M          IS MEM82
SpinHighRange_M         IS MEM83
PreToolChangeOrientMem  IS MEM85
SpindlePause_M          IS MEM86
SpindleOutRequest_M     IS MEM87

Axis1DriveOk			IS MEM91
Axis2DriveOk       		IS MEM92	
Axis3DriveOk       		IS MEM93	
Axis4DriveOk       		IS MEM94
Axis5DriveOk       		IS MEM95
Axis6DriveOk       		IS MEM96
LightBlinkOff_M         IS MEM100
;
DisableKbInput_M        IS MEM102 ;If 1, disable kb jogging
AllowKbInput_M          IS MEM103 ;If 1, allow kb jogging
JogOverOnly_M           IS MEM105
KbOverOnly_M            IS MEM106
UsingFeedrateKnob_M     IS MEM117
WaitingForSleepTimer_M  IS MEM118
X1_M                    IS MEM119
X10_M                   IS MEM120
X100_M                  IS MEM121
;
CAREV_M                 IS MEM129
AugerKeyStart_M         IS MEM130
;                       IS MEM131
;                       IS MEM132
;                       IS MEM133
DoorInterlockMode_M     IS MEM134 ; If 1, set slow jog if door open
DoorOpenSlowJog_M       IS MEM135 ; If DoorInterlockMode_M and door open then this is set
DoorInterlock_Override_M IS MEM136 ; Allows user to override the door interlock system, for probing with door open for instance
DoorLockDelay_M         IS MEM137
;
ArmHasStopped_M         IS MEM140
ArmHasMoved_M           IS MEM141
;
TiltTableTrue           IS MEM145
;
OnAtPowerUp             IS MEM200
true                    IS MEM201
LimitTripped            IS MEM208
LastProbeMode_M         IS MEM210
ManualTailControl_M     IS MEM211
MachineHomed_M          IS MEM221
;-----------------------------------
; *** P178 Aux parameter mapping ***
; The following MEMory bits are still mapped to Parameter 178
;-----------------------------------
InvLubeOk_M             IS MEM300  ; P178 Bit 0  (1)
InvSpinInverterOk_M     IS MEM301  ; P178 Bit 1  (2)
AirSignalNONC           IS MEM302  ; P178 Bit 2  (4)
ToolCounterNONC         IS MEM303  ; P178 Bit 3  (8)
ServoFaultNONC          IS MEM304  ; P178 Bit 4  (16)
ZeroSpeedNONC           IS MEM305  ; P178 Bit 5  (32)
OrientCompleteNONC      IS MEM306  ; P178 Bit 6  (64)
ArmInputsToggle         IS MEM307  ; P178 Bit 7  (128)
ReverseClamp            IS MEM308  ; P178 Bit 8  (256)
SpinRangeNONC           IS MEM309  ; P178 Bit 9  (512)
ChillerFaultNONC        IS MEM310  ; P178 Bit 10 (1024)
DoorSWNONC              IS MEM311  ; P178 Bit 11 (2048)
ToolThruNONC            IS MEM312  ; P178 Bit 12 (4096)
;uP178Bit13             IS MEM313  ; P178 Bit 13 (8192)
;uP178Bit14             IS MEM314  ; P178 Bit 14 (16384)
;uP178Bit15             IS MEM315  ; P178 Bit 15 (32768)

KbCycleStart_M          IS MEM400 ; "alt" + "s"
KbCycleCancel_M         IS MEM401 ; escape
KbToolCheck_M           IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M      IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M      IS MEM404 ; "Insert"
KbDecreaseJogInc_M      IS MEM405 ; "Delete"
KbIncFeedOver_M         IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M         IS MEM407 ; "ctrl" + "keyboard "-"
KbFeedOver100_M         IS MEM450 ; "ctrl" + "\"
KbTogIncContJog_M       IS MEM408 ; "ctrl" + "i"
KbTogFastSlowJog_M      IS MEM409 ; "ctrl" + "f"
KbJogAx1Plus_M          IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M         IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M          IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M         IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M          IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M         IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M          IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M         IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M             IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M             IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M             IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M             IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M             IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M             IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M             IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M             IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M             IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M            IS MEM428 ; "ctrl" + "F10"
KbAux13Key_M            IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M            IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M        IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M      IS MEM432 ; "ctrl" + "a"
KbSpinCW_M              IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M             IS MEM434 ; "ctrl" + "w"
KbSpinStart_M           IS MEM435 ; "ctrl" + "s"
KbSpinStop_M            IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M          IS MEM437 ; "ctrl" + "n"
KbMistOnOff_M           IS MEM600 ; "ctrl" + "k"
KbTogCoolAutoMan_M      IS MEM438 ; "ctrl" + "m"
KbFeedHold_M            IS MEM439 ; space bar
KbIncSpinOver_M         IS MEM440 ; "ctrl" + ">" (.)
KbDecSpinOver_M         IS MEM441 ; "ctrl" + "<" (,)
KbSpinOver100_M         IS MEM442 ; "ctrl" + "?" (/)

Axis1StatusBit0   		IS MEM443
Axis1StatusBit1   		IS MEM444
Axis1StatusBit2   		IS MEM445
Axis1StatusBit3   		IS MEM446
Axis1StatusTP   		IS MEM447
Axis1StatusALM3   		IS MEM448
Axis1StatusALM2   		IS MEM449
Axis1StatusALM1   		IS MEM450
Axis1StatusTGON   		IS MEM451
Axis1StatusBRAKE   		IS MEM452
Axis1StatusSRDY   		IS MEM453
Axis1StatusQUADERR  	IS MEM454
Axis1StatusDIR   		IS MEM455
Axis1StatusZ   			IS MEM456
Axis1StatusDIFF_ERR 	IS MEM457
Axis1DriveALM			IS MEM458
Axis2StatusBit0   		IS MEM459
Axis2StatusBit1   		IS MEM460
Axis2StatusBit2   		IS MEM461
Axis2StatusBit3   		IS MEM462
Axis2StatusTP   		IS MEM463
Axis2StatusALM3   		IS MEM464
Axis2StatusALM2   		IS MEM465
Axis2StatusALM1   		IS MEM466
Axis2StatusTGON   		IS MEM467
Axis2StatusBRAKE   		IS MEM468
Axis2StatusSRDY   		IS MEM469
Axis2StatusQUADERR  	IS MEM470
Axis2StatusDIR   		IS MEM471
Axis2StatusZ   			IS MEM472
Axis2StatusDIFF_ERR 	IS MEM473
Axis2DriveALM			IS MEM474
Axis3StatusBit0   		IS MEM475
Axis3StatusBit1   		IS MEM476
Axis3StatusBit2   		IS MEM477
Axis3StatusBit3   		IS MEM478
Axis3StatusTP   		IS MEM479
Axis3StatusALM3   		IS MEM480
Axis3StatusALM2   		IS MEM481
Axis3StatusALM1   		IS MEM482
Axis3StatusTGON   		IS MEM483
Axis3StatusBRAKE   		IS MEM484
Axis3StatusSRDY   		IS MEM485
Axis3StatusQUADERR  	IS MEM486
Axis3StatusDIR   		IS MEM487
Axis3StatusZ   			IS MEM488
Axis3StatusDIFF_ERR 	IS MEM489
Axis3DriveALM			IS MEM490
Axis4StatusBit0   		IS MEM491
Axis4StatusBit1   		IS MEM492
Axis4StatusBit2   		IS MEM493
Axis4StatusBit3   		IS MEM494
Axis4StatusTP   		IS MEM495
Axis4StatusALM3   		IS MEM496
Axis4StatusALM2   		IS MEM497
Axis4StatusALM1   		IS MEM498
Axis4StatusTGON   		IS MEM499
Axis4StatusBRAKE   		IS MEM500
Axis4StatusSRDY   		IS MEM501
Axis4StatusQUADERR  	IS MEM502
Axis4StatusDIR   		IS MEM503
Axis4StatusZ   			IS MEM504
Axis4StatusDIFF_ERR 	IS MEM505
Axis4DriveALM			IS MEM506
Axis5StatusBit0   		IS MEM507
Axis5StatusBit1   		IS MEM508
Axis5StatusBit2   		IS MEM509
Axis5StatusBit3   		IS MEM510
Axis5StatusTP   		IS MEM511
Axis5StatusALM3   		IS MEM512
Axis5StatusALM2   		IS MEM513
Axis5StatusALM1   		IS MEM514
Axis5StatusTGON   		IS MEM515
Axis5StatusBRAKE   		IS MEM516
Axis5StatusSRDY   		IS MEM517
Axis5StatusQUADERR  	IS MEM518
Axis5StatusDIR   		IS MEM519
Axis5StatusZ   			IS MEM520
Axis5StatusDIFF_ERR 	IS MEM521
Axis5DriveALM			IS MEM522
Axis6StatusBit0   		IS MEM523
Axis6StatusBit1   		IS MEM524
Axis6StatusBit2   		IS MEM525
Axis6StatusBit3   		IS MEM526
Axis6StatusTP   		IS MEM527
Axis6StatusALM3   		IS MEM528
Axis6StatusALM2   		IS MEM529
Axis6StatusALM1   		IS MEM530
Axis6StatusTGON   		IS MEM531
Axis6StatusBRAKE   		IS MEM532
Axis6StatusSRDY   		IS MEM534
Axis6StatusQUADERR  	IS MEM535
Axis6StatusDIR   		IS MEM536
Axis6StatusZ   			IS MEM537
Axis6StatusDIFF_ERR 	IS MEM538
Axis6DriveALM			IS MEM539

;----------------------------------------------------------------
; Jog panel keys are referenced as JPI1 through JPI256. Alternatively,
; jog panel inputs can also be referenced as INP1057-INP1312.
;----------------------------------------------------------------

; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey         IS JPI1  ; Row  1 Column 1
SpinAutoManKey          IS JPI2  ; Row  1 Column 2
Aux1Key                 IS JPI3  ; Row  1 Column 3
Aux2Key                 IS JPI4  ; Row  1 Column 4
Aux3Key                 IS JPI5  ; Row  1 Column 5

SpinOver100Key          IS JPI6  ; Row  2 Column 1
SpinCWKey               IS JPI7  ; Row  2 Column 2
Aux4Key                 IS JPI8  ; Row  2 Column 3
Aux5Key                 IS JPI9  ; Row  2 Column 4
Aux6Key                 IS JPI10 ; Row  2 Column 5

SpinOverMinusKey        IS JPI11 ; Row  3 Column 1
SpinCCWKey              IS JPI12 ; Row  3 Column 2
WorkLightKey            IS JPI13 ; Row  3 Column 3
ToolIndexDnKey          IS JPI14 ; Row  3 Column 4
ToolIndexUpKey          IS JPI15 ; Row  3 Column 5

SpinStopKey             IS JPI16 ; Row  4 Column 1
SpinStartKey            IS JPI17 ; Row  4 Column 2
Aux10Key                IS JPI18 ; Row  4 Column 3
Aux11Key                IS JPI19 ; Row  4 Column 4
Aux12Key                IS JPI20 ; Row  4 Column 5

CoolAutoManKey          IS JPI21 ; Row  5 Column 1
CoolFloodKey            IS JPI22 ; Row  5 Column 2
CoolMIStKey             IS JPI23 ; Row  5 Column 3
Aux13Key                IS JPI24 ; Row  5 Column 4
ATCOverrideKey          IS JPI25 ; Row  5 Column 5

IncrContKey             IS JPI26  ; Row  6 Column 1
x1JogKey                IS JPI27  ; Row  6 Column 2
x10JogKey               IS JPI28  ; Row  6 Column 3
x100JogKey              IS JPI29  ; Row  6 Column 4
MPGKey                  IS JPI30  ; Row  6 Column 5

Ax4PlusJogKey           IS JPI31  ; Row  7 Column 1
UnusedR7C2Key           IS JPI32  ; Row  7 Column 2
Ax2PlusJogKey           IS JPI33  ; Row  7 Column 3
UnusedR7C4Key           IS JPI34  ; Row  7 Column 4
Ax3PlusJogKey           IS JPI35  ; Row  7 Column 5

UnusedR8C1Key           IS JPI36  ; Row  8 Column 1
Ax1MinusJogKey          IS JPI37  ; Row  8 Column 2
FastSlowKey             IS JPI38  ; Row  8 Column 3
Ax1PlusJogKey           IS JPI39  ; Row  8 Column 4
UnusedR8C5Key           IS JPI40  ; Row  8 Column 5

Ax4MinusJogKey          IS JPI41  ; Row  9 Column 1
UnusedR9C2Key           IS JPI42  ; Row  9 Column 2
Ax2MinusJogKey          IS JPI43  ; Row  9 Column 3
UnusedR9C4Key           IS JPI44  ; Row  9 Column 4
Ax3MinusJogKey          IS JPI45  ; Row  9 Column 5

CycleCancelKey          IS JPI46  ; Row 10 Column 1
SingleBlockKey          IS JPI47  ; Row 10 Column 2
ToolCheckKey            IS JPI48  ; Row 10 Column 3
FeedHoldKey             IS JPI49  ; Row 10 Column 4
CycleStartKey           IS JPI50  ; Row 10 Column 5

;----------------------------------------------------------------
;                    Feedrate Override Knob
;----------------------------------------------------------------
JpFeedOrKnobBit0        IS JPI193
JpFeedOrKnobBit1        IS JPI194
JpFeedOrKnobBit2        IS JPI195
JpFeedOrKnobBit3        IS JPI196
JpFeedOrKnobBit4        IS JPI197
JpFeedOrKnobBit5        IS JPI198
JpFeedOrKnobBit6        IS JPI199
JpFeedOrKnobBit7        IS JPI200
JpFeedOrKnobBit8        IS JPI201
JpFeedOrKnobBit9        IS JPI202
JpFeedOrKnobBit10       IS JPI203
JpFeedOrKnobBit11       IS JPI204
JpFeedOrKnobBit12       IS JPI205
JpFeedOrKnobBit13       IS JPI206
JpFeedOrKnobBit14       IS JPI207
JpFeedOrKnobBit15       IS JPI208

;----------------------------------------------------------------
;                 Jog Panel Output Definitions
;       Jog Panel LED's can be addressed as JPO1 - JPO256
;                              OR
;                       OUT833 - OUT1088
;----------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusLED         IS JPO1  ; Row  1 Column 1
SpinAutoModeLED         IS JPO2  ; Row  1 Column 2
Aux1LED                 IS JPO3  ; Row  1 Column 3
Aux2LED                 IS JPO4  ; Row  1 Column 4
Aux3LED                 IS JPO5  ; Row  1 Column 5

SpinOver100LED          IS JPO6  ; Row  2 Column 1
SpindleCWLED            IS JPO7  ; Row  2 Column 2
Aux4LED                 IS JPO8  ; Row  2 Column 3
Aux5LED                 IS JPO9  ; Row  2 Column 4
Aux6LED                 IS JPO10 ; Row  2 Column 5

SpinOverMinusLED        IS JPO11 ; Row  3 Column 1
SpindleCCWLED           IS JPO12 ; Row  3 Column 2
WorklightLED            IS JPO13 ; Row  3 Column 3
Aux8LED                 IS JPO14 ; Row  3 Column 4
Aux9LED                 IS JPO15 ; Row  3 Column 5

SpinStopLED             IS JPO16 ; Row  4 Column 1
SpinStartLED            IS JPO17 ; Row  4 Column 2
Aux10LED                IS JPO18 ; Row  4 Column 3
Aux11LED                IS JPO19 ; Row  4 Column 4
Aux12LED                IS JPO20 ; Row  4 Column 5

CoolAutoManLED          IS JPO21 ; Row  5 Column 1
CoolFloodLED            IS JPO22 ; Row  5 Column 2
CoolMIStLED             IS JPO23 ; Row  5 Column 3
Aux13LED                IS JPO24 ; Row  5 Column 4
Aux14LED                IS JPO25 ; Row  5 Column 5

IncrContLED             IS JPO26  ; Row  6 Column 1
x1JogLED                IS JPO27  ; Row  6 Column 2
x10JogLED               IS JPO28  ; Row  6 Column 3
x100JogLED              IS JPO29  ; Row  6 Column 4
MPGLED                  IS JPO30  ; Row  6 Column 5

Ax4PlusJogLED           IS JPO31  ; Row  7 Column 1
UnusedR7C2LED           IS JPO32  ; Row  7 Column 2
Ax2PlusJogLED           IS JPO33  ; Row  7 Column 3
UnusedR7C4LED           IS JPO34  ; Row  7 Column 4
Ax3PlusJogLED           IS JPO35  ; Row  7 Column 5

UnusedR8C1LED           IS JPO36  ; Row  8 Column 1
Ax1MinusJogLED          IS JPO37  ; Row  8 Column 2
FastSlowLED             IS JPO38  ; Row  8 Column 3
Ax1PlusJogLED           IS JPO39  ; Row  8 Column 4
UnusedR8C5LED           IS JPO40  ; Row  8 Column 5

Ax4MinusJogLED          IS JPO41  ; Row  9 Column 1
UnusedR9C2LED           IS JPO42  ; Row  9 Column 2
Ax2MinusJogLED          IS JPO43  ; Row  9 Column 3
UnusedR9C4LED           IS JPO44  ; Row  9 Column 4
Ax3MinusJogLED          IS JPO45  ; Row  9 Column 5

CycleCancelLED          IS JPO46  ; Row 10 Column 1
SingleBlockLED          IS JPO47  ; Row 10 Column 2

; FOR JOGBRD REV??????, the LED outputs do not match Key inputs
; The PLC program should activate all three of these when
; it wants to turn on FeedHoldLED so that future hardware changes
; to put them in the same order as their corresponding inputs will work.
ToolCheckLED            IS JPO50  ; Row 10 Column 3
FeedHoldLED             IS JPO48  ; Row 10 Column 4
CycleStartLED           IS JPO49  ; Row 10 Column 5

;-------------------------------------------------------------------------------
;                     ---------SYSTEM VARIABLES--------
;
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;-------------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional reponsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibilty of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel keypress to a specific function.  Pressing a jog key or Aux key
; won't DO anything unless the PLC assigns an action to the keypress.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                                 ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape keypress event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the keypress is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "set" KbCycleCancel_M anytime the escape key is pressed.
;    if Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancle key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_1 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_1 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Keypress: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times------------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 32-17 (Selection 0)
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                    Debounce Time Selection #1
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                      Debounce Time Selection #3
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the charactersitics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 & INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is set as follows:

; Five new operators have been introduced to simplify bit operations:
; BitSet, BitRst, BitTst, LShift & Rshift.  Below we will use bitset to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; bitset and bitrst can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use bitset and
; bitrst to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; Inputs_9_12_W IS W1
; use bitst or bitrst
; if 1 == 1 THEN bitset Inputs_9_12_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; if 1 == 1 THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp1 = bits 31-24        Inp2 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp3 = bits 15-8       Inp4 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Ivert (bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, set the both invert AND force bits
;   for the input.

;-------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/set in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.
;-------------------------------------------------------------------------------

;----------------------------------------------------------------------------------------
;            *** Direct Accessed System Variables
; The following System Variables are directly accessed in thIS PLC program.
; They are lISted here to enable you to easilly search and find them
;----------------------------------------------------------------------------------------
;
; SV_STOP_REASON             - ThIS IS used to get any stop reasons from CNC11/MPU11
; SV_TOOL_NUMBER             - Requested Tool Number during Tool Change, M107 sets thIS
; SV_ATC_CAROUSEL_POSITION    - Startup carousel bin position, sent on CNC software startup
; SV_ATC_TOOL_IN_SPINDLE    - Tool in spindle during machine startup
; SV_PLC_CAROUSEL_POSITION     - Reported carousel bin number, reported by the PLC program
;
;----------------------------------------------------------------------------------------

;-------------------------------------------------------------
;      System Variable Definions - Jog panel functions
;-------------------------------------------------------------
;Invalid              IS SV_PLC_FUNCTION_0
DoCycleCancel         IS SV_PLC_FUNCTION_1
DoCycleStart          IS SV_PLC_FUNCTION_2
DoToolCheck           IS SV_PLC_FUNCTION_3
SelectSingleBlock     IS SV_PLC_FUNCTION_4
SelectX1JogInc        IS SV_PLC_FUNCTION_5
SelectX10JogInc       IS SV_PLC_FUNCTION_6
SelectX100JogInc      IS SV_PLC_FUNCTION_7
SelectUserJogInc      IS SV_PLC_FUNCTION_8
SelectIncContJog      IS SV_PLC_FUNCTION_9
SelectFastSlowJog     IS SV_PLC_FUNCTION_10
SelectMpgMode         IS SV_PLC_FUNCTION_11
DoAx1PlusJog          IS SV_PLC_FUNCTION_12
DoAx1MinusJog         IS SV_PLC_FUNCTION_13
DoAx2PlusJog          IS SV_PLC_FUNCTION_14
DoAx2MinusJog         IS SV_PLC_FUNCTION_15
DoAx3PlusJog          IS SV_PLC_FUNCTION_16
DoAx3MinusJog         IS SV_PLC_FUNCTION_17
DoAx4PlusJog          IS SV_PLC_FUNCTION_18
DoAx4MinusJog         IS SV_PLC_FUNCTION_19
DoAx5PlusJog          IS SV_PLC_FUNCTION_20
DoAx5MinusJog         IS SV_PLC_FUNCTION_21
DoAx6PlusJog          IS SV_PLC_FUNCTION_22
DoAx6MinusJog         IS SV_PLC_FUNCTION_23
DoAux1Key             IS SV_PLC_FUNCTION_24
DoAux2Key             IS SV_PLC_FUNCTION_25
DoAux3Key             IS SV_PLC_FUNCTION_26
DoAux4Key             IS SV_PLC_FUNCTION_27
DoAux5Key             IS SV_PLC_FUNCTION_28
DoAux6Key             IS SV_PLC_FUNCTION_29
DoAux7Key             IS SV_PLC_FUNCTION_30
DoAux8Key             IS SV_PLC_FUNCTION_31
DoAux9Key             IS SV_PLC_FUNCTION_32
DoAux10Key            IS SV_PLC_FUNCTION_33
SelectRapidOverride   IS SV_PLC_FUNCTION_34
SelectManAutoSpindle  IS SV_PLC_FUNCTION_35
DoSpindleStart        IS SV_PLC_FUNCTION_37
DoSpindleStop         IS SV_PLC_FUNCTION_38
DoAux13Key            IS SV_PLC_FUNCTION_39
DoAux12Key            IS SV_PLC_FUNCTION_40
;SelectCoolantMan     IS SV_PLC_FUNCTION_41 ;deprecated
;SelectCoolantAuto    IS SV_PLC_FUNCTION_42 ;deprecated
SelectCoolantFlood    IS SV_PLC_FUNCTION_43
SelectCoolantMist     IS SV_PLC_FUNCTION_44
DoFeedHold            IS SV_PLC_FUNCTION_45
SelectSpindleCCW      IS SV_PLC_FUNCTION_98
SelectSpindleCW       IS SV_PLC_FUNCTION_99
SelectCoolAutoMan     is SV_PLC_FUNCTION_104
DoIncreaseSpindleOr   IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOr   IS SV_PLC_FUNCTION_107
SelectSpinOr100       IS SV_PLC_FUNCTION_108
;-------------------------------------------------------------
;                System Variable Definions -mISc
;-------------------------------------------------------------
SpindlePos            IS SV_MPU11_ABS_POS_4
MDIMode               IS SV_MDI_MODE
Stop                  IS SV_STOP

;-------------------------------------------------------------
;                System Variable Definions - M functions
;-------------------------------------------------------------
; Start: SV_M94_M95_1 
; End: SV_M94_M95_128
;
M3                      IS SV_M94_M95_1 ;(Spindle CW)
M4                      IS SV_M94_M95_2 ;(Spindle CCW)
M8                      IS SV_M94_M95_3 ;(Flood On)
M10                     IS SV_M94_M95_4 ;(Rotary Clamp)
M7                      IS SV_M94_M95_5 ;(MISt)
M6                      IS SV_M94_M95_6 ;(ToolChange)
M80                     IS SV_M94_M95_7 ;(Tool Tru Tool Coolant)
MZ_ACK                  IS SV_M94_M95_8 ;(Move Z Ack)
M21                     IS SV_M94_M95_9 ;(Chip Pump)
M18                     IS SV_M94_M95_10;(Set ATC Home)
M19                     IS SV_M94_M95_11;(Spindle Orient)
Pre_M6                  IS SV_M94_M95_12;(Pre M6)
M13                     IS SV_M94_M95_13;(ArmCycle)
M14                     IS SV_M94_M95_14;(Pot Down)
M15                     IS SV_M94_M95_15;(Pot Up)
M16 			        IS SV_M94_M95_16;(Tool Unclamp)
M31 			        IS SV_M94_M95_17;(Auger Forward)
M32 			        IS SV_M94_M95_18;(Auger Reverse)
M33 			        IS SV_M94_M95_19;(Auger Stop)
M88                     IS SV_M94_M95_20;(Spindle thru tool coolant)
M11 			        IS SV_M94_M95_30;(Rotary Unclamp)
ScaleInhibit            IS SV_M94_M95_40;(Disable SCale)
M6EndAck                IS SV_M94_M95_106; (End of M6 signal from M6)
DoingM15                IS SV_M94_M95_115; (Doing M15 in M6)
DoingM19                IS SV_M94_M95_119; (In the M19 process so allow spindle)
;----------------------------------------------------------------
;  System variables:  Keyboard jogging functions
;----------------------------------------------------------------
;-------------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard keypress has occured.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Keypresses are sent down as individual keys.  It is the resposibility of
; the PLC programmer to insure that a keypress is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a keypress form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......
;-------------------------------------------------------------------------------
Kb_a                    IS SV_PC_KEYBOARD_KEY_60
Kb_b                    IS SV_PC_KEYBOARD_KEY_79
Kb_c                    IS SV_PC_KEYBOARD_KEY_77
Kb_d                    IS SV_PC_KEYBOARD_KEY_62
Kb_e                    IS SV_PC_KEYBOARD_KEY_41
Kb_f                    IS SV_PC_KEYBOARD_KEY_63
Kb_g                    IS SV_PC_KEYBOARD_KEY_64
Kb_h                    IS SV_PC_KEYBOARD_KEY_65
Kb_i                    IS SV_PC_KEYBOARD_KEY_46
Kb_j                    IS SV_PC_KEYBOARD_KEY_66
Kb_k                    IS SV_PC_KEYBOARD_KEY_67
Kb_l                    IS SV_PC_KEYBOARD_KEY_68
Kb_m                    IS SV_PC_KEYBOARD_KEY_81
Kb_n                    IS SV_PC_KEYBOARD_KEY_80
Kb_o                    IS SV_PC_KEYBOARD_KEY_47
Kb_p                    IS SV_PC_KEYBOARD_KEY_48
Kb_q                    IS SV_PC_KEYBOARD_KEY_39
Kb_r                    IS SV_PC_KEYBOARD_KEY_42
Kb_s                    IS SV_PC_KEYBOARD_KEY_61
Kb_t                    IS SV_PC_KEYBOARD_KEY_43
Kb_u                    IS SV_PC_KEYBOARD_KEY_45
Kb_v                    IS SV_PC_KEYBOARD_KEY_78
Kb_w                    IS SV_PC_KEYBOARD_KEY_40
Kb_x                    IS SV_PC_KEYBOARD_KEY_76
Kb_y                    IS SV_PC_KEYBOARD_KEY_44
Kb_z                    IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar             IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift              IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift              IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt                IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt                IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl               IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl               IS SV_PC_KEYBOARD_KEY_99
Kb_Ins                  IS SV_PC_KEYBOARD_KEY_31
Kb_Home                 IS SV_PC_KEYBOARD_KEY_32
Kb_End                  IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown               IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp                 IS SV_PC_KEYBOARD_KEY_33
Kb_Del                  IS SV_PC_KEYBOARD_KEY_52
Kb_Back                 IS SV_PC_KEYBOARD_KEY_30
Kb_Tab                  IS SV_PC_KEYBOARD_KEY_38
Kb_Up                   IS SV_PC_KEYBOARD_KEY_87
Kb_Down                 IS SV_PC_KEYBOARD_KEY_101
Kb_Left                 IS SV_PC_KEYBOARD_KEY_100
Kb_Right                IS SV_PC_KEYBOARD_KEY_102
Kb_Escape               IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1                   IS SV_PC_KEYBOARD_KEY_2
Kb_F2                   IS SV_PC_KEYBOARD_KEY_3
Kb_F3                   IS SV_PC_KEYBOARD_KEY_4
Kb_F4                   IS SV_PC_KEYBOARD_KEY_5
Kb_F5                   IS SV_PC_KEYBOARD_KEY_6
Kb_F6                   IS SV_PC_KEYBOARD_KEY_7
Kb_F7                   IS SV_PC_KEYBOARD_KEY_8
Kb_F8                   IS SV_PC_KEYBOARD_KEY_9
Kb_F9                   IS SV_PC_KEYBOARD_KEY_10
Kb_F10                  IS SV_PC_KEYBOARD_KEY_11
Kb_F11                  IS SV_PC_KEYBOARD_KEY_12
Kb_F12                  IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn             IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck             IS SV_PC_KEYBOARD_KEY_15
Kb_Break                IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock             IS SV_PC_KEYBOARD_KEY_34
Kb_1                    IS SV_PC_KEYBOARD_KEY_18
Kb_2                    IS SV_PC_KEYBOARD_KEY_19
Kb_3                    IS SV_PC_KEYBOARD_KEY_20
Kb_4                    IS SV_PC_KEYBOARD_KEY_21
Kb_5                    IS SV_PC_KEYBOARD_KEY_22
Kb_6                    IS SV_PC_KEYBOARD_KEY_23
Kb_7                    IS SV_PC_KEYBOARD_KEY_24
Kb_8                    IS SV_PC_KEYBOARD_KEY_25
Kb_9                    IS SV_PC_KEYBOARD_KEY_26
Kb_0                    IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div           IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt           IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub           IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0             IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1             IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2             IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3             IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4             IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5             IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6             IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7             IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8             IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9             IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt        IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus          IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter            IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket         IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket         IS SV_PC_KEYBOARD_KEY_50
Kb_Hypen                IS SV_PC_KEYBOARD_KEY_28
Kb_Equals               IS SV_PC_KEYBOARD_KEY_29
Kb_Comma                IS SV_PC_KEYBOARD_KEY_82
Kb_Period               IS SV_PC_KEYBOARD_KEY_83
Kb_Slash                IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash            IS SV_PC_KEYBOARD_KEY_86

;----------------------------------------------------
;           Word Definitions (int32)
;----------------------------------------------------
Bin_Position_W          IS W1      ;
Wanted_Bin_W            IS W2
Max_Bins_W              IS W3      ;
Distance_W              IS W4      ;
AsyncMsg_W              IS W5
;               
ErrorCode_W             IS W6
LastErrorCode_W         IS W7
MotorDir_W              IS W8       ; 1 = CW, -1 = CCW
OldM107Binr_W           IS W10      ;
NewM107Bin_W            IS W11      ;
SixteenBitSpeed_W        IS W12
LubeAccumTime_W         IS W13
KbOverride_W            IS W14
FeedrateKnob_W          IS W15
CycloneStatus_W         IS W16
FinalFeedOverride_W     IS W17
PLC_Fault_W             IS W18
PLCFaultAddr_W          IS W19
Last_FeedrateKnob_W     IS W20
Lube_W                  IS W21
LubeM_W                 IS W22
LubeS_W                 IS W23
SpinSpeedCommand_W      IS W24
P6Value_W               IS W25
P85Value_W              IS W26
Inputs_9_12_W           IS W28
P148Value_W             IS W29
P170Value_W             IS W30
P171Value_W             IS W31
P172Value_W             IS W32
P173Value_W             IS W33
P174Value_W             IS W34
P175Value_W             IS W35
P176Value_W             IS W36
P177Value_W             IS W37
P178Value_W             IS W38
P179Value_W             IS W39
P166Value_W             IS W40
MPG_1_Multiplier_W		IS W41
P146Value_W             IS W42

Sv_Control_1_Shadow  	IS W47
Sv_Control_2_Shadow  	IS W48
Sv_Control_3_Shadow  	IS W49
Sv_Control_4_Shadow  	IS W50
Sv_Control_5_Shadow  	IS W51
Sv_Control_6_Shadow  	IS W52
;-----------------------------------------------------
;           Word Definitions cont. (int64)
;-----------------------------------------------------


;-----------------------------------------------------
;           Word Definitions cont. (f32)
;-----------------------------------------------------
SpinRangeAdjust         IS FW1
RPMPerBit_FW            IS FW2
CfgMinSpeed_FW          IS FW3
CfgMaxSpeed_FW          IS FW4
SicteenBitSpeed_FW       IS FW5

;-----------------------------------------------------
;            One Shot Definitions
;-----------------------------------------------------
IncrContPD              IS PD1
SlowFastPD              IS PD2
MpgPD                   IS PD3
SingleBlockPD           IS PD4
FeedHoldPD              IS PD5
SpinAutoManPD           IS PD6
SpindlePlusPD           IS PD7
SpinOverMinusPD         IS PD8
SpinOver100PD           IS PD9
SpinStartPD             IS PD10
SpinStopPD              IS PD11
SpinCWPD                IS PD12
SpinCCWPD               IS PD13
F9PD                    IS PD14
x1JogPD                 IS PD15
x10JogPD                IS PD16
x100JogPD               IS PD17
test_pd					IS PD18
RapidOverPD             IS PD19
CoolantAutoManualPD     IS PD21
CoolantFloodPD          IS PD22
CoolantMistPD           IS PD23
ToolCheckPD             IS PD24
JogProbeFaultPD         IS PD25
RigidTapPD              IS PD26
WorklightPD             IS PD27
PCSpindleStartStopPD    IS PD30
PCSpindleManualPD       IS PD31
PCSpindleCWPD           IS PD32
PCSpindleCCWPD          IS PD33
StopRunning_PD          IS PD35
SoftwareReadyPD         IS PD36
M88_PD                  IS PD40
M19_1Shot               IS PD41     ; M19
M18_1Shot               IS PD42
M13_1Shot               IS PD43
StopReason_1Shot        IS PD44
M21PD                   IS PD45
M22PD                   IS PD46

CAFWD_PD                IS PD47     
CAREV_PD                IS PD48
CA1_PD                  IS PD49
CA2_PD                  IS PD50
CA3_PD                  IS PD51
CAFWD_OFF_PD	        IS PD52
CAFWD_ON_PD	            IS PD53
CAREV_OFF_PD	        IS PD54
CAREV_ON_PD	            IS PD55
AugerSelectPD           IS PD56
Aux1_PD        		    IS PD61
Aux2_PD        		    IS PD62
Aux3_PD        		    IS PD63
Aux4_PD        		    IS PD64
Aux5_PD        		    IS PD65
Aux6_PD        		    IS PD66
Aux7_PD        		    IS PD67
Aux8_PD        		    IS PD68
Aux9_PD        		    IS PD69
Aux10_PD        	    IS PD70
Aux11_PD                IS PD71
Aux1Tail_PD             IS PD72
;------------------------------------------------------
;             Timer Definitions
;------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T              	IS T1
SleepTimer              	IS T2
CycloneStatusTimer      	IS T3
InitializeTimer         	IS T4
LubeM_T                 	IS T5
LubeS_T                 	IS T6
ATC_OrientLost_T        	IS T7
StopReason_T            	IS T8
P176_T                  	IS T9
Car_Enable_T            	IS T10
ATC_Orient_T1           	IS T11

ProbeTrippedByMPG_T       IS T12
ATC_Timeout_T             IS T13
ATC_Unclamp_T1          	IS T14
ATC_Rotate_T1           	IS T16
ATC_Rotate_T2           	IS T17
ATC_Count_T1            	IS T18
ATC_Count_T2            	IS T19
ATC_Clamp_T1            	IS T20
ATC_PotDown_T1          	IS T22
ATC_End_T1              	IS T25
ATC_MoveZAxis_T1			IS T26
ATC_ARM_HTC_T1          	IS T28
ATC_AHTCWS_T1           	IS T29
ATC_PotUp_T1            	IS T30
ATC_ARM_D180U_T1        	IS T31
ATC_AD1UWS_T1           	IS T32
ATC_ARM_CTH_T1          	IS T33
ATC_ACTHWS_T1           	IS T34
ChillerOff_T            	IS T35
Tool_Thru_Coolant_T     	IS T36
AirTimer_T              	IS T37
SpindleChillerFault_T   	IS T38
LightBlinkOn_T          	IS T42
LightBlinkOff_T         	IS T43
DoorLockDelay_T         	IS T44
test_t						IS T45
SpindleFault_T          	IS T47
;--------------------------------------------------
;             Stage Definitions
;--------------------------------------------------
WatchDogStage               IS STG1
InitialStage                IS STG2
LoadCNC11ParametersStage    IS STG3
LubeMonitorStage            IS STG4
AxesEnableStage             IS STG5
JogPanelStage               IS STG6
MainStage                   IS STG7
;                           IS STG8
MPG_Stage                   IS STG9
CheckCycloneStatusStage     IS STG10
KeyboardEvents              IS STG11
LubeUsePumpTimers           IS STG12
LubeUsePLCTimers            IS STG13
SetErrorStage               IS STG14
BadErrorStage               IS STG15
ATCMainStage                IS STG16
;
ATC_InitialStage            IS STG20
ATC_CheckStageRotateStage   IS STG21
ATC_ReadyStage              IS STG22
ATC_MoveZAxisStage          IS STG23
ATC_OrientStage             IS STG24
ATC_PotDownStage            IS STG25
ATC_ArmAtHomeToClampStage   IS STG26
ATC_AHTCWaitStopStage       IS STG27
ATC_UnclampStage            IS STG28
ATC_ArmDown180UpStage       IS STG29
ATC_AD1UWaitStopStage       IS STG30
ATC_ClampStage              IS STG31
ATC_ArmAtClampToHomeStage   IS STG32
ATC_ACTHWaitStopStage       IS STG33
ATC_PotUpStage              IS STG34
ATC_EndStage                IS STG35
ATC_AcceptStage             IS STG36
ATC_CheckStage              IS STG37
ATC_DoM19Stage              IS STG38
ATC_MonitorM19Stage         IS STG39
ATC_DoToolIndexUpStage      IS STG40
ATC_DoToolIndexDnStage      IS STG41
ATC_RotateStage             IS STG42
ATC_CountStage              IS STG43
ATC_DoneRotateStage         IS STG44
ATC_SetDirectionStage       IS STG45
ATC_M13ArmRotateStage       IS STG46
M13_ArmWaitStopStage        IS STG47
;
ToolThruOffStage            IS STG50
ToolThruOnStage             IS STG51
AugerOffStage               IS STG52
AugerFwdStage               IS STG53
AugerRevStage               IS STG54
AugerSelectStage            IS STG55
DoorInterlockStage          IS STG56

FourthClampStage            IS STG64
FifthClampStage             IS STG65

;*****************************************************************************
;                  PLC Program Start - Definitions done, start program loop
;*****************************************************************************

;----------------------------------------------------------------
                          WatchDogStage
;----------------------------------------------------------------
; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
;
if SV_PLC_FAULT_STATUS != 0 THEN
  PLC_Fault_W    = SV_PLC_FAULT_STATUS,
  PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
  ErrorCode_W    = PLC_EXECUTOR_FLT_MSG, MSG ErrorCode_W,
  SET PLCExecutorFault_M, RST SetErrorStage, SET SV_STOP

; Handle software exit.
if !SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN
  SET SoftwareReady_M,
  SET SV_STOP,
  ErrorCode_W = SOFTWARE_EXIT_MSG

if SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN (SoftwareReadyPD)
if SoftwareReadyPD && !SoftwareReady_M || !true THEN SET InitialStage

if SoftwareReadyPD && SoftwareReady_M THEN RST SoftwareReady_M

;---------------------------------------
            InitialStage
;---------------------------------------
IF 1==1 THEN SET true,
        SET OnAtPowerUp,
        SET AxesEnableStage,
        SET JogPanelStage,
        SET MainStage,
        SET LoadCNC11ParametersStage,
        SET MPG_Stage,
        SET PLCBus_Oe_M,
        SET ErrClr_M,
        RST PLCFault_M,
        CycloneStatusTimer = 300,
        ErrorCode_W = MSG_CLEARED_MSG,
        RST BadErrorStage,
        SET SetErrorStage,
        RST ATC_RotateStage,
		SET AugerOffStage,
		SET AugerSelectStage,
		SET DoorInterlockMode_M,
        SET ToolThruOffStage,
        Bin_Position_W         	= SV_ATC_CAROUSEL_POSITION,
        Wanted_Bin_W           	= Bin_Position_W,
        OldM107Binr_W           = Bin_Position_W,
        NewM107Bin_W            = Bin_Position_W,
        InitializeTimer     	= 1000, set InitializeTimer,
        Tool_Thru_Coolant_T 	= 5000,  	; Timer for PLC to check Tool_thru_coolant pressure.
        AirTimer_T          	= 500,    	; time that low air input must be on to cause fault
        ATC_OrientLost_T    	= 1000,    	; time that orient complete must be lost before fault
        StopReason_T        	= 50,    	; mISc timer used to load stop reason form CPU
        Car_Enable_T           	= 100,    	; time to keep carousel motor off before rotating
        ATC_Orient_T1          	= 60000,  	; max to orient spindle
        ATC_Unclamp_T1         	= 6000,   	; max to unclamp tool
        ATC_Rotate_T1          	= 2000,   	; max to see first tool counter input change
        ATC_Rotate_T2          	= 50,     	; min to see first tool counter input change
        ATC_Count_T1           	= 2000,   	; max to see second tool counter input change
        ATC_Count_T2           	= 50,     	; min to see second tool counter input change
        ATC_Clamp_T1           	= 5000,   	; max to clamp tool
        ATC_PotDown_T1        	= 5000,   	; max to extend tool pot
        ATC_End_T1             	= 5000,   	; max to finISh handshaking with M6 macro
        ATC_MoveZAxis_T1     	= 10000,  	; max to move Z axIS to tool change height
         ATC_ARM_HTC_T1         = 2000,   	; max to move arm from home to clamp (for ArmAtStopMEM to go off)
        ATC_AHTCWS_T1          	= 2000,   	; max to move arm from home to clamp (for ArmAtStopMEM and ArmAtClampMEM to be on)
        ATC_PotUp_T1          	= 5000,   	; max to retract tool pot
        ATC_ARM_D180U_T1       	= 2000,   	; max to move arm down, rotate 180, up (for ArmAtStopMEM to go off)
        ATC_AD1UWS_T1          	= 2000,   	; max to move arm down, rotate 180, up (for ArmAtStopMEM and ArmAtClampMEM to be on)
        ATC_ARM_CTH_T1         	= 2000,   	; max to move arm from clamp to home (for ArmAtStopMEM to go off)
        ATC_ACTHWS_T1          	= 2000,   	; max to move arm from clamp to home (for ArmAtStopMEM and ArmAtHoMEMem to be on)
        P176_T              	= 500,    	; Unclamp / AirBlow Timer
		ChillerOff_T          	= 10,    	; Spindle Chiller Off time delay, default 0 
		SpindleChillerFault_T 	= 10000, 	; Spindle Chiller Fault Timer
		LightBlinkOn_T          = 20000,  	; Light Blink On Time
	    LightBlinkOff_T         = 500,  	; Light Blink Off Time
        DoorLockDelay_T         = 10000, 	; Door lock delay 
		SpindleFault_T 			= 2000,		; delay after release of estop before sending spindle fault message
		ATC_Timeout_T           = 30000,    ; ATC Timeout
		SET LightBlinkOn_T

IF 1==1 THEN MSG ErrorCode_W
IF 1==1 THEN RST InitialStage
;
; ATC enable section
; IF Paramemter6 is set to 1 THEN SET ATC_InitialStage
;
IF 1==1 THEN P6Value_W = SV_MACHINE_PARAMETER_6
IF (P6Value_W == 1) THEN SET ATCMainStage,
        SET ATC_InitialStage
		
IF (P6Value_W == 0) THEN RST ATCMainStage,
        RST ATC_InitialStage
;----------------------------------------------------------------
                      LoadCNC11ParametersStage
;----------------------------------------------------------------
; The LoadCNC11Paramaters section loads the contents into the PLC program.
; Loading the Parameter values in CNC 11 to words in PLC. 
;
if true THEN P85Value_W = SV_MACHINE_PARAMETER_85,   ; Door Interlock - If non zero then obey Door Closed Input
             P146Value_W = SV_MACHINE_PARAMETER_146, ; Feedrate Override Feedhold value
			 P148Value_W = SV_MACHINE_PARAMETER_148, ; Misc Jogging Options
			 P166Value_W = SV_MACHINE_PARAMETER_166, ; Fifth Axis
             P170Value_W = SV_MACHINE_PARAMETER_170, ; Enable Keyboard Jogging
			 P171Value_W = SV_MACHINE_PARAMETER_171, ; Auger Mode - 0 means Both Augers, 1 means selectable Augers by Aux4
			 P172Value_W = SV_MACHINE_PARAMETER_172, ;
			 P173Value_W = SV_MACHINE_PARAMETER_173, ; 
			 P174Value_W = SV_MACHINE_PARAMETER_174, ; 
			 P175Value_W = SV_MACHINE_PARAMETER_175, ; Chiller Off Delay Time
			 P176Value_W = SV_MACHINE_PARAMETER_176, ; 
			 P177Value_W = SV_MACHINE_PARAMETER_177, ; 
             P178Value_W = SV_MACHINE_PARAMETER_178, ; PLC IO NO / NC Settings
			 Max_Bins_W  = SV_MACHINE_PARAMETER_161  ; Max tool numbers
			 
IF TRUE THEN P176_T = P176Value_W * 1000 
			 
;
; There are two methods of control for the lube pump and they are set by CNC11
; Machine Parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;-
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled soley by PLC).
;
; Load lube pump times from P179 and convert to milliseconds.
IF true THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000
;
; Set the apprpriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimers, RST LubeUsePLCTimers
IF LubeS_W != 0 THEN SET LubeUsePLCTimers, RST LubeUsePumpTimers

If true THEN BitTst P148Value_W 1 DisableKbInput_M
if true && !DisableKbInput_M THEN BitTst P170Value_W 0 AllowKbInput_M
If true THEN BitTst P170Value_W 1 JogOverOnly_M
If true THEN BitTst P170Value_W 2 KbOverOnly_M
if JogOverOnly_M && KbOverOnly_M THEN rst KbOverOnly_M

; Load Spindle Chilelr Off Timer:
IF TRUE THEN ChillerOff_T = (P175Value_W * 60000)

; Load ATC settings from CNC11 Parameter 178:
If true THEN BitTst P178Value_W 0 InvLubeOk_M
If true THEN BitTst P178Value_W 1 InvSpinInverterOk_M
IF true THEN BitTst P178Value_W 2 AirSignalNONC
IF true THEN BitTst P178Value_W 3 ToolCounterNONC
IF true THEN BitTst P178Value_W 5 ZeroSpeedNONC
IF true THEN BitTst P178Value_W 6 OrientCompleteNONC
IF true THEN BitTst P178Value_W 7 ArmInputsToggle
IF true THEN BitTst P178Value_W 8 ReverseClamp
IF true THEN BitTst P178Value_W 9 SpinRangeNONC
IF true THEN BitTst P178Value_W 10 ChillerFaultNONC
IF true THEN BitTst P178Value_W 11 DoorSWNONC
IF true THEN BitTst P178Value_W 12 ToolThruNONC

; Check Door Interlock Settings:
IF (P85Value_W != 0) THEN SET DoorInterlockMode_M, 
	SET DoorInterlockStage
IF (P85Value_W == 0) THEN RST DoorInterlockMode_M, 
	RST DoorInterlockStage, RST DoorOpenSlowJog_M,
	SET DoorUnLockOut
		
;------------------------------------------------------------------------------
                        LubeUsePumpTimers
;------------------------------------------------------------------------------

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be set such that MMM is a
; value that is greater than the cycle time set on the internal timers and
; SS should be set to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is set to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually set with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time set by the inteval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems accoding to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) THEN SET LubeOut, RST LubeM_T
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN LubeM_T = LubeM_W, SET LubeM_T
IF LubeM_T || !EStopOk THEN RST LubeOut

;------------------------------------------------------------------------------
                        LubeUsePLCTimers
;------------------------------------------------------------------------------
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be set so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To set the lube pump power to come on for 5 seconds
;    every 10 minutes, set P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To set the lube pump power to come on for 30 seconds
;    every 2 hours, set P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;

IF (SV_PROGRAM_RUNNING || SV_MDI_MODE)  THEN LubeM_T = LubeM_W, SET LubeM_T
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN (StopRunning_PD)
IF StopRunning_PD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T, RST LubeM_T
IF LubeM_T || (LubeAccumTime_W + LubeM_T > LubeM_W) THEN
  SET LubeOut, LubeS_T = LubeS_W, SET LubeS_T, RST LubeM_T, LubeAccumTime_W = 0
IF LubeS_T || !EStopOk THEN RST LubeOut, RST LubeS_T

;----------------------------------------------------------------
                        KeyboardEvents
;----------------------------------------------------------------
; This stage handles functions that are required for menu navigation
; by CNC11, require multiple keypresses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must set parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC11 to aid in menu
; navigation.  NOTE: For backward comaptibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked------------------------
; The for cycle cancel has been moved to the main stage.
; It is commented out below but remains for referrence
;Cycle Cancel
;if Kb_Escape THEN (KbCycleCancel_M)

;Rapidoverride: Ctrl-r
if Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M-------------------
;KbCycle Start: alt-s
if  Kb_s && (Kb_R_Alt || Kb_L_Alt) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
if Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbFeedHold_M: spacebar
if Kb_spacebar && AllowKbInput_M THEN (KbFeedHold_M)

;KbTogSingleBlock_M: ctrl-b
if Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
if Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
if Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then set KbSpinCW_M, rst KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
if Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then set KbSpinCCW_M, rst KbSpinCW_M

;KbSpinStart_M:  ctrl-s
if Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
if Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
if Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  then (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
if Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M
  then (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
if Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
if Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
if Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
if Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbMistOnOff_M)

;KbTogIncContJog_M: "ctrl" +  "i"
if Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
if Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbTogFastSlowJog_M)

;KbAux1Key_M: "ctrl" + "F1"
if Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
if Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
if Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
if Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
if Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
if Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
if Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
if Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
if Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
if Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux13Key_M: "ctrl" + "F11"
if Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux13Key_M)

;KbAux12Key_M: "ctrl" + "F12"
if Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
if Kb_Equals && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
if Kb_Hypen && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
if Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M then (KbFeedOver100_M)


;--------Interlocked with AllowKbInput_M && KbJpActive_M-----------

;KbIncreaseJogInc_M: "insert"
if Kb_Ins && AllowKbInput_M && KbJpActive_M
  then (KbIncreaseJogInc_M)
if KbIncreaseJogInc_M && x1JogLED && !X1_M && !X10_M && !X100_M
  then set X10_M
if KbIncreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  then set X100_M

;KbDecreaseJogInc_M: "delete"
if Kb_Del && AllowKbInput_M && KbJpActive_M
  then (KbDecreaseJogInc_M)
if KbDecreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  then set X1_M
if KbDecreaseJogInc_M && x100JogLED && !X1_M && !X10_M && !X100_M
  then set X10_M


;KbJogAx1Plus_M: Right arrow
if Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Right arrow
if Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
if Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
if Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
if Kb_PgUp && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
if Kb_PgDown && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
if Kb_Home && AllowKbInput_M && KbJpActive_M
  then (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
if Kb_End && AllowKbInput_M && KbJpActive_M
  then (KbJogAx4Minus_M)

if true THEN rst KeyboardEvents

;----------------------------------------------------------------
                           MPG_Stage
;----------------------------------------------------------------
;                        MPG Functions
;       Turn on/off Jog Panel MPG LED & on the MPG
IF MPGKey then (MpgPD)
IF MpgPD && MPGLED then set MPGManOffFlag_M
IF !SV_MPG_1_ENABLED || (MpgPD && !MPGLED) then RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) || (SV_MPG_1_ENABLED && !MPGManOffFlag_M)
  THEN SET MPG_LED_OUT, SET MPGLED

IF (!SV_MPG_1_ENABLED || (MpgPD && MPGLED))
  THEN RST MPG_LED_OUT, RST MPGLED



;x1, x10, x100 functions
;--------------------------X1-----------------------------------
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp || X1_M || (MPG_Inc_X_1 && MPGLED)
  THEN SET x1JogLED, RST x10JogLED, RST x100JogLED

;--------------------------X10----------------------------------
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || X10_M || (MPG_Inc_X_10 && MPGLED)
  THEN RST x1JogLED, SET x10JogLED, RST x100JogLED

;--------------------------X100---------------------------------
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || X100_M || (MPG_Inc_X_100 && MPGLED)
  THEN RST x1JogLED, RST x10JogLED, SET x100JogLED

if !KbIncreaseJogInc_M && !KbDecreaseJogInc_M then rst X1_M, rst X10_M,
  rst X100_M
;                          MPG 1 Enable
IF (!ProbeTrippedByMPG_M || ProbeTrippedOverride_M) && (MPG_AXIS_1 || 
  MPG_AXIS_2 || MPG_AXIS_3 || MPG_AXIS_4 || MPG_AXIS_5 || MPG_AXIS_6 || 
  MPG_AXIS_7 || MPG_AXIS_8) THEN (SV_MPG_1_ENABLED)

;                     Select axis to move
IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
IF MPG_AXIS_2 THEN SV_MPG_1_AXIS_SELECT = 2
IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4
IF MPG_AXIS_5 THEN SV_MPG_1_AXIS_SELECT = 5
IF MPG_AXIS_6 THEN SV_MPG_1_AXIS_SELECT = 6

;                   Select MPG 1 Multiplier
IF (MPG_Inc_X_100) THEN MPG_1_Multiplier_W = 100
IF (MPG_Inc_X_10) THEN  MPG_1_Multiplier_W = 10
IF (MPG_Inc_X_1) THEN   MPG_1_Multiplier_W = 1

IF true then SV_MPG_1_MULTIPLIER = MPG_1_Multiplier_W

;            Disable "Windup" mode IF x100 selected
IF (!MPG_Inc_X_100) THEN (SV_MPG_1_WINDUP_MODE)


;----------------------------------------------------------------
                           JogPanelStage
;----------------------------------------------------------------
;         Select Incremental or Continuous Jog Mode
IF IncrContKey || KbTogIncContJog_M THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;              Select Fast or Slow Jog Mode
IF FastSlowKey || KbTogFastSlowJog_M THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || OnAtPowerUp || DoorOpenSlowJog_M THEN SET FastSlowLED
IF (SlowFastPD && FastSlowLED) || OnAtPowerUp THEN RST FastSlowLED

;---------------------------------------
;       Single Block Mode
;---------------------------------------
IF SingleBlockKey || KbTogSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING
  THEN SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;---------------------------------------
;           Toolcheck
;---------------------------------------
IF (ToolCheckKey || KbToolCheck_M) && EstopOk THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;---------------------------------------
;          Feed Hold Mode
;---------------------------------------
IF (FeedHoldKey || KbFeedHold_M) && SV_PROGRAM_RUNNING THEN (FeedHoldPD), SET FeedHoldFromKeyFlag_M
IF FeedHoldPD && !FeedHoldLED THEN SET FeedHoldLED
IF FeedHoldPD && FeedHoldLED && !SV_PROGRAM_RUNNING && !SV_MDI_MODE
  THEN RST FeedHoldLED, RST FeedHoldFromKeyFlag_M
IF FeedHoldLED && (DoCycleStart || DoCycleCancel || ToolCheckPD || SV_STOP)
  THEN RST FeedHoldLED, RST FeedHoldFromKeyFlag_M
IF FeedHoldLED THEN SET DoFeedHold
IF !FeedHoldLED THEN RST DoFeedHold

;---------------------------------------
;   Feedrate Override Section
;---------------------------------------
;-------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and then multiplying the result by 100
; 3. If keyboard joggin is not disabled (it is enabled by default), the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" scrren in CNC11 software) stores
;    a value which allows which the PLC program can use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC11 software by setting
;    SV_PLC_FeedrateKnob_W = FinalFeedOverride_W
; 7. CNC11 reads SV_PLC_FEEDRATE_KNOB, factors in it's on own override based
;    on parameter 78 (see operators manual for more info on parm 78) and then
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;-----------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;-----------------------------------------------------------------------
IF true THEN FeedrateKnob_W = 0
if true THEN BTW FeedrateKnob_W JpFeedOrKnobBit0 8

;-----------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;-----------------------------------------------------------------------
IF true THEN FeedrateKnob_W = (FeedrateKnob_W/127.5)*100

;-----------------------------------------------------------------------
; 3.  Determine whether to us FeedrateKnob_W or KbOverride_W
;-----------------------------------------------------------------------
; This section determines when to use the feedrate override value sent down
; by the jogpanel (FeedrateKnob_W) or the feedrate override as determined
; by the PLC monitoring the keyboard override keys (KbOverride_W).

;-------------------------------------------------------------------------------
;     At powerup, default feedrate override is jog panel (FeedrateKnob_W)
;       To use both keyboard or jogpanel overrides set p170 to 0 (default)
;       To use jogpanel override only set p170 to 2
;       To use keyboard only set p170 to 4
;-------------------------------------------------------------------------------
IF OnAtPowerUp && KbOverOnly_M || KbFeedOver100_M THEN KbOverride_W = 100
IF OnAtPowerUp && !KbOverOnly_M THEN set UsingFeedrateKnob_M,
  KbOverride_W = FeedrateKnob_W, Last_FeedrateKnob_W = FeedrateKnob_W

;----------------Calculate keyboard feedrate override---------------------------
; SleepTimer is used to limit the KbOverride_W update rate to 20% per sec
;-------------------------------------------------------------------------------
if AllowKbInput_M && KbIncFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W + 1, rst UsingFeedrateKnob_M,
  set WaitingForSleepTimer_M, SleepTimer = 50, set SleepTimer

if AllowKbInput_M && KbDecFeedOver_M && !WaitingForSleepTimer_M
  THEN KbOverride_W = KbOverride_W - 1, rst UsingFeedrateKnob_M,
  set WaitingForSleepTimer_M, SleepTimer = 50, set SleepTimer

if SleepTimer THEN rst WaitingForSleepTimer_M, rst SleepTimer

;------------Switch to FeedrateKnob_W if it changes more 3%----------------------
; Once it has changed by more than 3%, it will update as normal (1% increments)
; until it sees another KbOverride_W command at which point it will take
; another 3% change to re-activate the FeedrateKnob_W

if (abs(Last_FeedrateKnob_W - FeedrateKnob_W) >= 3) || UsingFeedrateKnob_M
  THEN FinalFeedOverride_W = FeedrateKnob_W, KbOverride_W = FeedrateKnob_W,
  Last_FeedrateKnob_W = FeedrateKnob_W, set UsingFeedrateKnob_M

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W & the FeedrateKnob_W
if KbOverride_W > SV_MACHINE_PARAMETER_39
  THEN KbOverride_W = SV_MACHINE_PARAMETER_39

if !UsingFeedrateKnob_M && !JogOverOnly_M
  THEN FinalFeedOverride_W = KbOverride_W


;-----------------------------------------------------------------------
; 4 & 5. Limit override percentage to value set in Parameter 39
;-----------------------------------------------------------------------
;------------------Limit final override percentage to parm 39-------------------
if FinalFeedOverride_W > SV_MACHINE_PARAMETER_39
  THEN FinalFeedOverride_W = SV_MACHINE_PARAMETER_39
  
IF (FinalFeedOverride_W >= 99 && FinalFeedOverride_W <= 101) THEN FinalFeedOverride_W = 100

if FinalFeedOverride_W <= P146Value_W THEN FinalFeedOverride_W = P146Value_W
if FinalFeedOverride_W < 2 THEN FinalFeedOverride_W = 2;

;----------------------------------------------
;  Override Controls
;----------------------------------------------
; Override control bit for the feedrate override
; 1 == feedrate override knob will effect feedrate
; 0 == override knob has NO effect on feedrate
IF  !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN FinalFeedOverride_W = 100

;-----------------------------------------------------------------------
; 6. Send override percentage to CNC11
;-----------------------------------------------------------------------
;----------------Send override to PC for modification if needed-----------------
if true THEN SV_PLC_Feedrate_Knob = FinalFeedOverride_W

;-----------------------------------------------------------------------
; 7. Copy the feedrate override sent from the PC to the MPU11.
;-----------------------------------------------------------------------
;--------------------------------------------------------------------------
; Normally a number from 0.0-2.0, no limitations although V will not exceed
; Vmax. A negative number in here would be extremely bad.
;--------------------------------------------------------------------------
IF true THEN SV_PLC_FEEDRATE_OVERRIDE = SV_PC_FEEDRATE_PERCENTAGE/100.0

;---------------------------------------------------------
;  MPU11 Jog Panel Functions
;---------------------------------------------------------
IF KB_F9 then (F9PD)
IF KbTogRapidOver_M || (F9PD && SV_PROGRAM_RUNNING) THEN (RapidOverPD)
IF RapidOverPD^ SelectRapidOverride THEN (SelectRapidOverride)

IF OnAtPowerUp THEN SET SelectRapidOverride

IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN
  (DoCycleCancel)
IF (CycleStartKey  || KbCycleStart_M) THEN (DoCycleStart)

IF (Ax1PlusJogKey  || KbJogAx1Plus_M)  && !Ax1PlusJogDisabled_M &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M) && !Ax1MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx1MinusJog)
IF (Ax2PlusJogKey  || KbJogAx2Plus_M)  && !Ax2PlusJogDisabled_M  &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M) && !Ax2MinusJogDisabled_M &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx2MinusJog)

IF (Ax3PlusJogKey  || KbJogAx3Plus_M) &&
   !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)
IF (Aux2Key  || KbAux2Key_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx5MinusJog)
IF (Aux3Key || KbAux3Key_M) &&
  !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx5PlusJog)

IF (Aux1Key || KbAux1Key_M) THEN (DoAux1Key)
IF (Aux2Key || KbAux2Key_M) THEN (DoAux2Key)
IF (Aux3Key || KbAux3Key_M) THEN (DoAux3Key)
IF (Aux4Key || KbAux4Key_M) THEN (DoAux4Key)
IF (Aux5Key || KbAux5Key_M) THEN (DoAux5Key)
IF (Aux6Key || KbAux6Key_M) THEN (DoAux6Key)
;IF (Aux7Key || KbAux7Key_M) THEN (DoAux7Key)
;IF (Aux8Key || KbAux8Key_M) THEN (DoAux8Key)
;IF (Aux9Key || KbAux9Key_M) THEN (DoAux9Key)
;IF (Aux10Key || KbAux10Key_M) THEN (DoAux10Key)
IF Aux11LED                 THEN (DoAux13Key)
IF x1JogLED                 THEN (SelectX1JogInc)
IF x10JogLED                THEN (SelectX10JogInc)
IF x100JogLED               THEN (SelectX100JogInc)
IF IncrContLED              THEN (SelectIncContJog)
IF FastSlowLED              THEN (SelectFastSlowJog)
IF MPGLED                   THEN (SelectMpgMode)
IF FeedHoldLED              THEN (DoFeedHold)

;-----------------------------------------------------
;               Coolant Functions
;-----------------------------------------------------

;--------------Toggle auto coolant mode---------------
IF CoolAutoManKey || KbTogCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoManLED && CoolantAutoManualPD) || OnAtPowerUp
  THEN SET CoolAutoManLED

IF (CoolAutoManLED && CoolantAutoManualPD)
  THEN RST CoolAutoManLED

;------------Report coolant mode to CNC11-------------
IF CoolAutoManLED THEN (SelectCoolAutoMan)

;-----------Display coolant mode message--------------
;changing to auto coolant mode ;9050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoManLED && CoolantAutoManualPD)
  THEN AsyncMsg_W = 12802, MSG AsyncMsg_W;, AsyncMsg_W = 0

;changing to manual coolant mode ;9051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoManLED && CoolantAutoManualPD)
  THEN  AsyncMsg_W = 13058, MSG AsyncMsg_W;, AsyncMsg_W = 0

;--------------------------------------------------------------
;                Flood coolant on/off
;--------------------------------------------------------------
IF ((CoolFloodKey || KbFloodOnOff_M) && !CoolAutoManLED) ||
  (M8 && CoolAutoManLED) || (DoCycleStart && M8 && CoolAutoManLED)
  THEN (CoolantFloodPD)

IF CoolantFloodPD && !CoolFloodLED Then SET CoolFloodLED, Set FloodOut

IF SV_STOP || (CoolantFloodPD && CoolFloodLED) || (!M8 && CoolAutoManLED)
 || (M8 && !CoolAutoManLED) ||DoToolCheck THEN Rst FloodOut, Rst CoolFloodLED

IF CoolFloodLED THEN (SelectCoolantFlood)
;--------------------------------------------------------------
;                  Mist coolant on/off
;--------------------------------------------------------------
;IF ((CoolMistKey || KbMistOnOff_M)&& !CoolAutoManLED) || (M7 && CoolAutoManLED)
;  || (DoCycleStart && M7 && CoolAutoManLED) THEN (CoolantMistPD)

;IF (CoolantMistPD && !CoolMistLED) THEN SET MistOut, SET CoolMistLED

;IF SV_STOP || (CoolantMistPD && CoolMistLED) || (!M7 && CoolAutoManLED)
; || (M7 && !CoolAutoManLED) || DoToolCheck THEN Rst MistOut, Rst CoolMistLED

;IF CoolMistLED THEN (SelectCoolantMist)
;-------------------------------------------------------------
;                       Spindle Control
;-------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;-------------------------------------------------------------
;-------------------------------------------------------------
;      Select Auto or Manual Spindle Operation Mode
;-------------------------------------------------------------
;-----Triggers to Toggle Auto/Manual Spindle Mode-------------
IF SpinAutoManKey || KbTogSpinAutoMan_M THEN (SpinAutoManPD)

;----------Set spindle to auto mode on startup-----------------
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp
  THEN SET SpinAutoModeLED

;---------------Set spindle to manual mode---------------------
if SpinAutoManPD && SpinAutoModeLED THEN rst SpinAutoModeLED

;----------------------Report the Spindle mode to CNC11-------------------------
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;--------------------------------------------------------------
;         Set triggers to start and stop the spindle
;--------------------------------------------------------------
; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

IF !SV_MDI_MODE && !SV_PROGRAM_RUNNING THEN rst m3,rst m4
IF ((SpinStartKey || KbSpinStart_M) && !SpinAutoModeLED) ||
  (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M) ||
  ((SpinStartKey || KbSpinStart_M || CycleStartKey)
	&& ((M3 || M4) && SpinAutoModeLED))
  THEN (SpinStartPD), Rst SpindlePause_M
	
If (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M))
  THEN set SpindlePause_M

If (SpinStopKey || KbSpinStop_M) || (SpinAutoModeLED && !M3 && !M4) ||
  (SpinAutoManPD && SpindleEnableOut) || (SV_PC_RIGID_TAP_SPINDLE_OFF &&
  SpinAutoModeLED) THEN (SpinStopPD)

;--------------------------------------------------------------
;Adjust spindle override when entering manual or auto spin mode
;--------------------------------------------------------------
;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 100,
  SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED
  THEN SV_PLC_SPINDLE_KNOB = 10, Rst SpinAutoModeLED

;--------------------------------------------------------------
;                     Set spindle direction
;--------------------------------------------------------------
;------------------Set Clockwise direction---------------------
IF ((KbSpinCW_M || SpinCWKey) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
  || (M3 && DoCycleStart) then (SpinCWPD)
IF SpinCWPD THEN RST SpindleDirectionOut
IF !SpindleDirectionOut THEN (SpindleCWLED), (SelectSpindleCW)


;---------------Set Counterclockwise direction-----------------
IF ((KbSpinCCW_M || SpinCCWKey) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
  || (M4 && DoCycleStart) then (SpinCCWPD)
IF SpinCCWPD THEN SET SpindleDirectionOut
IF SpindleDirectionOut THEN (SpindleCCWLED), (SelectSpindleCCW)


;-------------------------------------------------------------------------------
;                                Turn spindle on/off
;-------------------------------------------------------------------------------
IF ProbeDetect && SpinStartPD THEN SET ProbeFault_M

IF (SpindleEnableOut || SpinStartPD ) && !SpinStopPD && !SV_STOP && !ProbeDetect
  && SpindleInverterOk THEN SET SpindleOutRequest_M

IF SpinStopPD || SV_STOP || ProbeDetect || !SpindleInverterOK THEN RST SpindleOutRequest_M	
	
IF ((SpindleOutRequest_M && !NoTool && !ToolUnclamped) || 
  ((M19 || DoingM19) && SpindleOutRequest_M && (NoTool || ToolClamped))) &&
  ((DoorClosed && DoorInterlockMode_M) || (!DoorInterlockMode_M)) 	
  THEN (SpindleEnableOut)
  
IF SpindleEnableOut && !M19 THEN (SpindleAirOut)

IF SV_STOP THEN RST DoingM19  
	
IF ((SpindleOutRequest_M || SpinStartPD ) && (NoTool) && (!M19) && (!DoingM19)) 
    THEN ErrorCode_W = SPINDLE_EMPTY, SET SV_STOP
  
IF SpindleEnableOut THEN SET OrientRequestOut
IF !SpindleEnableOut  THEN (DoSpindleStop)
IF !SpindleEnableOut && !M19 && ZeroSpeed THEN RST OrientRequestOut

;-------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "shift" + "<", "shift" + ">", "shift" + "<" & ">"
;-------------------------------------------------------
IF SpinOverPlusKey || KbIncSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1
IF SpinOverMinusKey || KbDecSpinOver_M
  THEN SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1
IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp
  THEN SV_PLC_SPINDLE_KNOB = 100

IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN
  (SpinOver100LED),
  (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN
  (SpinOverMinusLED),
  (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN
  (SpinOverPlusLED),
  (DoIncreaseSpindleOr)

;--------------------------------------------------------------------------------
;                  Output 12-bit DAC value for spindle control
;--------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
;             Read spindle range inputs and/or range M codes
;
; NOTE: SV_SPINDLE_LOW_RANGE & SV_SPINDLE_MID_RANGE M are used to report the
; selected spindle range to CNC11
;--------------------------------------------------------------------------------
;    hi      med-high  med-low  low
;    0          1        1      0 SV_SPINDLE_MID_RANGE M
;    0          0        1      1 SV_SPINDLE_LOW_RANGE

;If SpinLowRange then set SpinLowRange_M
;If !SpinLowRange then rst SpinLowRange_M

If TRUE then (SpinHighRange_M), rst SV_SPINDLE_LOW_RANGE,
  rst SV_SPINDLE_MID_RANGE

if SpinLowRange_M && (SV_MACHINE_PARAMETER_65 > .01)
  then SpinRangeAdjust = SV_MACHINE_PARAMETER_65, set SV_SPINDLE_LOW_RANGE,
  rst SV_SPINDLE_MID_RANGE

if SpinHighRange_M then SpinRangeAdjust = 1
if SpinRangeAdjust == 0 then SpinRangeAdjust = 1

;----------------------------------------------------------------
;              Read commanded spindle speed, max & min
;
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
;----------------------------------------------------------------
if true then SpinSpeedCommand_W =  SV_PC_COMMANDED_SPINDLE_SPEED,
             CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED

;----------------------------------------------------------------
; If commanded spindle speed is < Min Spin Speed * SpinRangeAdjust
; & commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust.
;----------------------------------------------------------------
IF (SpinSpeedCommand_W > 0) &&
  (SpinSpeedCommand_W < (CfgMinSpeed_FW * SpinRangeAdjust))
  then SpinSpeedCommand_W = (CfgMinSpeed_FW * SpinRangeAdjust),
  ErrorCode_W = MIN_SPEED_MSG

;---------------------------------------------------------------------------
; If SpinSpeedCommand_W > Max Spin Speed * SpinRangeAdjust, force
; SpinSpeedCommand_W = max spin speed value * SpinRangeAdjust.
;---------------------------------------------------------------------------
IF SpinSpeedCommand_W > (CfgMaxSpeed_FW * SpinRangeAdjust)
  THEN SpinSpeedCommand_W = (CfgMaxSpeed_FW * SpinRangeAdjust)
;----------------------------------------------------------------
; Convert Spindle "S" command to 12 bit value for output to DAC
;----------------------------------------------------------------
; Commanded Spindle speed (includes override factor) is sent down from CNC11
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a
; 16 bit value (0-65535) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED.

; Calculate #RPM's per bit of resolution
if CfgMaxSpeed_FW > 0 then RPMPerBit_FW = CfgMaxSpeed_FW/65535
if CfgMaxSpeed_FW <= 0 then RPMPerBit_FW = 1

;Convert RPM to 12 bit value
if true then SicteenBitSpeed_FW = SpinSpeedCommand_W/RPMPerBit_FW

; Bound min to 0, max to 65535
if SicteenBitSpeed_FW < 0 then SixteenBitSpeed_W = 0
if SicteenBitSpeed_FW > 65535 then SixteenBitSpeed_W = 65535

; Factor in gear range
IF true THEN SicteenBitSpeed_FW = (SicteenBitSpeed_FW/SpinRangeAdjust)

;Convert to integer word for DAC & I/O display
if true then SixteenBitSpeed_W = SicteenBitSpeed_FW

; Output to DAC
If true then WTB SixteenBitSpeed_W SpinAnalogOutBit0 16

;Display calculated RPM value on PC
IF true
  then SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_W

;-----------------------
  CheckCycloneStatusStage
;-----------------------
; Due to amount of time it takes to retrieve data from the cyclone, this stage
; is only called few times per second to help reduce scan time of the main PLC
; program.

; The logic below is the equivalent to the following:

;check PLC status bit
IF TRUE THEN BitTst SV_PC_CYCLONE_STATUS_1 21 PLCBusExtDevEn_M

;check input fiber
IF !SV_PLC_BUS_ONLINE THEN ErrorCode_W = PLC_INFLT, set SetErrorStage,
  rst PLCBus_Oe_M, set PLCFault_M

;check output fiber
IF SV_PLC_BUS_ONLINE && PLCBus_Oe_M && !PLCBusExtDevEn_M
  THEN ErrorCode_W = PLC_OUTFLT, set SetErrorStage, set PLCFault_M

;clear PLC errors
IF PLCFault_M && SV_PLC_BUS_ONLINE && PLCBusExtDevEn_M && !EstopOk
  THEN rst PLCFault_M, ErrorCode_W = PLC_FLT_CLR, set SetErrorStage, set PLCBus_Oe_M

if true THEN rst CheckCycloneStatusStage

;----------------------------------------------------------------
                     AxesEnableStage
;----------------------------------------------------------------

;Report external drive faults
IF SV_AXIS_VALID_1 && SV_PC_POWER_AXIS_1 && !Axis1DriveOk THEN
    ErrorCode_W = AXIS1_DRIVE_FAULT, ; 6401(1+256*25)
    SET AxisFault_M,
    SET Axis1Fault_M
IF SV_AXIS_VALID_2 && SV_PC_POWER_AXIS_2 && !Axis2DriveOk THEN
    ErrorCode_W = AXIS2_DRIVE_FAULT, ; 6655(1+256*26)
    SET AxisFault_M,
    SET Axis2Fault_M
IF SV_AXIS_VALID_3 && SV_PC_POWER_AXIS_3 && !Axis3DriveOk THEN
    ErrorCode_W = AXIS3_DRIVE_FAULT, ; 6913(1+256*27)
    SET AxisFault_M,
    SET Axis3Fault_M
IF SV_AXIS_VALID_4 && SV_PC_POWER_AXIS_4 && Axis5DriveFault_M THEN
    ErrorCode_W = AXIS4_DRIVE_FAULT, ; 7169(1+256*28)
    SET AxisFault_M,
    SET Axis4Fault_M
;IF SV_AXIS_VALID_5 && SV_PC_POWER_AXIS_5 && Axis5DriveFault_M
;  THEN ErrorCode_W = AXIS5_DRIVE_FAULT, ; 7425(1+256*29)
;    SET AxisFault_M,
;    SET Axis5Fault_M

IF !EstopOk THEN RST AxisFault_M, RST Axis1Fault_M, RST Axis2Fault_M, 
	RST Axis3Fault_M, RST Axis4Fault_M, RST Axis5Fault_M
;read the status bits
IF true THEN SET CycloneStatusTimer
IF CycloneStatusTimer THEN SET CheckCycloneStatusStage, RST CycloneStatusTimer

;YASINTF bits 
;SV_DRIVE_STATUS_1
;5 = alarm bit 3, 6 = alarm bit 2, 7 = alarm bit 1, 8 = /TGON, 9 = brake state, 10 = /S_RDY
;11 = quadrature Error, 12 = direction, 13 = Index pulse, 14 = diff. error, 15 = drive fault
;SV_DRIVE_CONTROL_1
;7 = POS_CLR 8 = P-OT, 9 = N-OT 10 = /P-CON, 11 = /P-CL, 12 = /N-CL,
;13 = ABS. send, 14 = Alarm reset, 15 = enable
IF !EstopOk THEN BITSET Sv_Control_1_Shadow 14
IF EstopOk THEN BITRST Sv_Control_1_Shadow 14
IF !EstopOk THEN BITSET Sv_Control_2_Shadow 14
IF EstopOk THEN BITRST Sv_Control_2_Shadow 14
IF !EstopOk THEN BITSET Sv_Control_3_Shadow 14
IF EstopOk THEN BITRST Sv_Control_3_Shadow 14
IF !EstopOk THEN BITSET Sv_Control_4_Shadow 14
IF EstopOk THEN BITRST Sv_Control_4_Shadow 14
IF !EstopOk THEN BITSET Sv_Control_5_Shadow 14
IF EstopOk THEN BITRST Sv_Control_5_Shadow 14
IF !EstopOk THEN BITSET Sv_Control_6_Shadow 14
IF EstopOk THEN BITRST Sv_Control_6_Shadow 14

IF EstopOk THEN BITSET Sv_Control_1_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_1_Shadow 7
IF EstopOk THEN BITSET Sv_Control_2_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_2_Shadow 7
IF EstopOk THEN BITSET Sv_Control_3_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_3_Shadow 7
IF EstopOk THEN BITSET Sv_Control_4_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_4_Shadow 7
IF EstopOk THEN BITSET Sv_Control_5_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_5_Shadow 7
IF EstopOk THEN BITSET Sv_Control_6_Shadow 7
IF !EstopOk THEN BITRST Sv_Control_6_Shadow 7

IF True THEN SV_DRIVE_CONTROL_1 = Sv_Control_1_Shadow
IF True THEN SV_DRIVE_CONTROL_2 = Sv_Control_2_Shadow
IF True THEN SV_DRIVE_CONTROL_3 = Sv_Control_3_Shadow
IF True THEN SV_DRIVE_CONTROL_4 = Sv_Control_4_Shadow
IF True THEN SV_DRIVE_CONTROL_5 = Sv_Control_5_Shadow
IF True THEN SV_DRIVE_CONTROL_6 = Sv_Control_6_Shadow

IF True THEN WTB SV_DRIVE_STATUS_1 Axis1StatusBit0 16
IF True THEN WTB SV_DRIVE_STATUS_2 Axis2StatusBit0 16
IF True THEN WTB SV_DRIVE_STATUS_3 Axis3StatusBit0 16
IF True THEN WTB SV_DRIVE_STATUS_4 Axis4StatusBit0 16
IF True THEN WTB SV_DRIVE_STATUS_5 Axis5StatusBit0 16
IF True THEN WTB SV_DRIVE_STATUS_6 Axis5StatusBit0 16

IF Axis1DriveALM THEN RST Axis1DriveOk
IF !Axis1DriveALM THEN SET Axis1DriveOk

IF Axis2DriveALM THEN RST Axis2DriveOk
IF !Axis2DriveALM THEN SET Axis2DriveOk

IF Axis3DriveALM THEN RST Axis3DriveOk
IF !Axis3DriveALM THEN SET Axis3DriveOk

IF Axis4DriveALM THEN RST Axis4DriveOk
IF !Axis4DriveALM THEN SET Axis4DriveOk

IF Axis5DriveALM THEN RST Axis5DriveOk
IF !Axis5DriveALM THEN SET Axis5DriveOk

IF Axis5DriveALM THEN RST Axis6DriveOk
IF !Axis5DriveALM THEN SET Axis6DriveOk

;turn on drives IF no errors
IF !PLCFault_M && !SV_STALL_ERROR THEN SET SV_MASTER_ENABLE

IF PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE, SET SV_STOP

;****************************************
            MainStage
;****************************************
IF SV_PC_HOME_SET THEN (MachineHomed_M)
;Do gather if commanded (umcomment and recompile for debugging purposes)
;IF ChipPumpKey THEN (ChipPumpKeyPD)
;If Kb_F12 THEN (SV_TRIGGER_PLOT_DUMP)

IF MechanicalProbe THEN (MechanicalProbeEcho_M)
IF DSPProbe THEN (DSPProbeEcho_M)
IF ProbeDetect THEN (ProbeDetectEcho_M)
IF ProbeAux THEN (ProbeAuxEcho_M)

;read parameter 178 and check the Lube NO/NC state
; Invert input 9
IF  InvLubeOk_M THEN BITSET Inputs_9_12_W 6
IF !InvLubeOk_M THEN BITRST Inputs_9_12_W 6

 ; Invert input 10
IF  InvSpinInverterOk_M THEN BITSET Inputs_9_12_W 14
IF !InvSpinInverterOk_M THEN BITRST Inputs_9_12_W 14
IF true THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;----------------------------------------------------------------
;           Spindle Chiller Control
;
; The Chiller is enabled with the SpindleEnableOut and then
; if the SpindleEnableOut is shut off the chiller stays on 
; until the Chiller Off Timer expires or Estop is depressed
;
; IF your system does not have a Spindle Chiller, or does not have a Chiller OK
; input then you will need to add 1024 to Parameter 178 (bit 10)
; this will stop any chiller fault error messages
;----------------------------------------------------------------
IF !SpindleEnableOut THEN SET ChillerOff_T, RST SpindleChillerFault_T
IF SpindleEnableOut THEN SET SpindleChillerOut, 
	RST ChillerOff_T
IF SpindleChillerOut && (!EstopOk || ChillerOff_T) THEN RST SpindleChillerOut
IF SpindleChillerOut THEN (CoolingFanOut)

IF (SpindleChillerOut && (!ChillerOk ^ ChillerFaultNONC)) THEN SET SpindleChillerFault_T
IF SpindleChillerFault_T && (!ChillerOk ^ ChillerFaultNONC)
   THEN ErrorCode_W = SPINDLE_CHILLER_FAULT,
   SET SetErrorStage, 
   RST SpindleChillerOut, 
   RST SpindleChillerFault_T,
   SET SV_STOP
   
IF SpindleChillerFault_T && (ChillerOk ^ ChillerFaultNONC) THEN RST SpindleChillerFault_T  
   
IF !SpindleChillerOut THEN RST SpindleChillerFault_T

;----------------------------------------------------------------
;           Probe protection while jogging & mpg motion
;----------------------------------------------------------------
IF MechanicalProbe && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
    DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
    DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog) THEN
    (JogProbeFaultPD)
IF MechanicalProbe && SV_MPG_1_ENABLED && !(JogProbeFaultPD || JogProbeFault_M)
  THEN SET ProbeTrippedByMPG_M

IF !MechanicalProbe THEN RST ProbeTrippedOverride_M, RST ProbeTrippedByMPG_M
  
IF ATCOverrideKey THEN SET ProbeTrippedOverride_M 

; Probe must be tripped for > 500 milli sec timer before message and
; operator intervention is required.  This is used to prevent probe trips
; caused by machine vibration from forcing the operator to us the override key 
; to continue.  While mpg motion IS disabled when probe is actually tripped, if
; the probe clears within 500 milli seconds the message is not issued and the 
; override key is not required to continue

IF true THEN ProbeTrippedByMPG_T = 500
IF ProbeTrippedByMPG_M THEN SET ProbeTrippedByMPG_T
IF !ProbeTrippedByMPG_M THEN RST ProbeTrippedByMPG_T

IF ProbeTrippedByMPG_T THEN (DoAux12Key)  

IF MechanicalProbe && !JogProbeFault_M && FastSlowLED THEN SET LastProbeMode_M
IF MechanicalProbe && !JogProbeFault_M && !FastSlowLED THEN RST LastProbeMode_M
	
IF JogProbeFaultPD && !JogProbeFault_M THEN SET JogProbeFault_M, SET DoCycleCancel

IF JogProbeFault_M THEN ErrorCode_W = (PROBE_JOG_FAULT_MSG + 1), 
	SET FastSlowLED
	
IF !MechanicalProbe && JogProbeFault_M && !LastProbeMode_M THEN RST FastSlowLED

IF !MechanicalProbe THEN RST JogProbeFault_M,
                        RST Ax1PlusJogDisabled_M,
                        RST Ax1MinusJogDisabled_M,
                        RST Ax2PlusJogDisabled_M,
                        RST Ax2MinusJogDisabled_M

; Set the sv_plc_carousel position to the current internal plc bin number,
; the CNC software will then read thIS to update it's internal bin position
; (reported by Alt-K)
IF true THEN SV_PLC_CAROUSEL_POSITION = Bin_Position_W

; -------------------------------------
; Reset Tool Change sequence:

IF !EstopOk THEN RST DoingM6_M, RST M6

IF P6Value_W == 1 && EStopOK && !SV_STOP && !DoingM6_M && !M6 THEN SET ATC_InitialStage

IF (EstopOk &&!SV_STOP) && Pre_M6 THEN SET PreToolChangeOrientMem
IF !EstopOk || SV_STOP THEN RST PreToolChangeOrientMem

; -------------------------------------
; Reset Tool Change Timers if EStop condition or SV_STOP set:
IF !EstopOk || SV_STOP THEN RST AirTimer_T,
        RST ATC_OrientLost_T,
        RST StopReason_T,
        RST Car_Enable_T,
        RST ATC_Orient_T1,
        RST ATC_Unclamp_T1,
        RST ATC_Rotate_T1,
        RST ATC_Rotate_T2,
        RST ATC_Count_T1,
        RST ATC_Count_T2,
        RST ATC_Clamp_T1,
        RST ATC_PotDown_T1,
        RST ATC_End_T1,
        RST ATC_MoveZAxis_T1,
        RST ATC_ARM_HTC_T1,
        RST ATC_AHTCWS_T1,
        RST ATC_PotUp_T1,
        RST ATC_ARM_D180U_T1,
        RST ATC_AD1UWS_T1,
        RST ATC_ARM_CTH_T1,
        RST ATC_ACTHWS_T1,
        RST P176_T,
        RST M14,
        RST M15,
		RST M16,
	RST AugerKeyStart_M,
	RST SpindleChillerFault_T

;-----------------------------Keyboard--------------------------------
;Cycle Cancel
if Kb_Escape THEN (KbCycleCancel_M)
;KbFeedHold_M: spacebar
if Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING then (KbFeedHold_M)

;Just a shorter name for SV_PC_VIRTUAL_JOGPANEL_ACTIVE
if SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEvents stage if needed
if Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt ||
  KbJpActive_M THEN set KeyboardEvents

if (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
  && (Kb_j || Kb_f || kb_a || kb_s) && !AllowKbInput_M
  THEN ErrorCode_W = KB_JOG_MSG


;----------------------------------------------------------------
;    Reset these M-codes IF not in CNC Program Running mode
;----------------------------------------------------------------
IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE THEN
        RST M3,
        RST M4,
        RST M8,
        RST M7

;--------------------------------------------------------------
;                Chip Flood Pump Control
;--------------------------------------------------------------

IF Aux10Key THEN (Aux10_PD)

IF (M21) THEN (M21PD)

IF ((Aux10_PD && !Aux10LED)) THEN SET ChipPumpOut, SET Aux10LED
IF ((Aux10_PD && Aux10LED)) THEN RST ChipPumpOut, RST Aux10LED

IF (!M21) THEN (M22PD)

IF M21PD THEN SET ChipPumpOut, SET Aux10LED
IF M22PD THEN RST ChipPumpOut, RST Aux10LED

IF (OnAtPowerUp && P171Value_W == 1) THEN SET Aux4LED

;-----------------------------------------------
; Faults
;-----------------------------------------------
if !EStopOk || PLCFault_M || SV_STALL_ERROR || Spindle_Fault_M ||
  LubeFault_M || AxisFault_M ||  ProbeFault_M THEN set SV_STOP
if !EstopOk && SV_STALL_ERROR THEN rst SV_STALL_ERROR
IF SV_Stop || PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE
IF InitializeTimer && !LubeOk && (!SV_PROGRAM_RUNNING && !LubeFaultCleared_M)
  && EStopOk THEN SET LubeFault_M, ErrorCode_W = LUBE_FAULT_MSG

IF !LubeOk && SV_PROGRAM_RUNNING THEN ErrorCode_W = LUBE_WARNING_MSG

IF SV_PROGRAM_RUNNING THEN RST LubeFaultCleared_M
IF !EstopOK && !SV_PROGRAM_RUNNING 
  THEN RST LubeFault_M, SET LubeFaultCleared_M    ;clear lube fault to allow jogging

IF !EstopOK && ProbeFault_M THEN rst ProbeFault_M, rst ProbeMsgSent_M
IF InitializeTimer && SpindleFault_T && !SpindleInverterOk
  THEN ErrorCode_W = SPINDLE_FAULT, SET SV_STOP, SET Spindle_Fault_M
IF !EstopOK && Spindle_Fault_M 
  THEN (InverterResetOut), RST Spindle_Fault_M, RST SpindleFault_T

if EStopOk && !PLCFault_M && !SV_STALL_ERROR && !Spindle_Fault_M &&
  !LubeFault_M && SV_PLC_BUS_ONLINE && !PLCFault_M && !SoftwareReady_M &&
  !PLCExecutorFault_M && !AxisFault_M THEN RST SV_STOP

IF ProbeFault_M && !ProbeMsgSent_M
  THEN ErrorCode_W = PROBE_FAULT_MSG, set SetErrorStage, set ProbeMsgSent_M

;----------------------------------------------
; Status Lights:
;   - Red Light for all stop / error conditions
;   - Amber Light when not running a job, doing a tool change,
;     or waiting for operator input
;   - Green Light when running a job normally
;----------------------------------------------
; Red Light:
;IF (SV_Stop && !LightBlinkOff_M) then (RedLightOut)
; Amber Light:
;IF ((M6 || !SV_PROGRAM_RUNNING) && !RedLightOut && !LightBlinkOff_M) THEN (AmberLightOut)
; Green Light:
;IF (SV_PROGRAM_RUNNING && !RedLightOut && !AmberLightOut && !LightBlinkOff_M) then (GreenLightOut)

; Use a time to make the lights blink:
;IF LightBlinkOn_T THEN SET LightBlinkOff_M,
;	RST LightBlinkOn_T,
;	SET LightBlinkOff_T

;IF LightBlinkOff_T THEN RST LightBlinkOff_M,
;	SET LightBlinkOn_T,
;	RST LightBlinkOff_T

IF ToolRelease && (ZeroSpeed ^ ZeroSpeedNONC ) && !SV_PROGRAM_RUNNING
   && !DoingM6_M && EStopOk THEN SET ToolUnclampOut, SET AirBlowOut
IF !ToolRelease && !DoingM6_M THEN RST ToolUnclampOut, RST AirBlowOut
	
;----------------------------------------------
; Worklight
;----------------------------------------------
if WorkLightKey then (WorklightPD)
if (WorkLightPD && !WorkLightOut) || OnAtPowerUp then set WorkLightOut
if WorkLightPD && WorkLightOut then rst WorkLightOut
if WorkLightOut then (WorklightLED), (WorkLightOut2)    ;added by AWG for Blair

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   M19 Orient Spindle
;
;IF M19 THEN (M19_1Shot)
;IF M19_1Shot THEN SET ATC_DoM19Stage
;IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN RST M19

;Skimmer Toggle
IF Aux4Key THEN (Aux4_PD)
IF Aux4_PD && !SkimmerOut THEN SET SkimmerOut
IF Aux4_PD && SkimmerOut THEN RST SkimmerOut
IF SV_STOP THEN RST SkimmerOut
IF SkimmerOut THEN (Aux4LED)

IF true THEN RST OnAtPowerUp


; *********** RESET INITIAL STAGE ********
; *********** TESTING ONLY!!!!!!! ********

;IF (Aux4Key && Aux5Key && Aux6Key) THEN SET InitialStage
IF !EstopOk THEN RST ATCCount_M, RST ATCRotate_M

;==========================================================
;   FifthClampStage
;==========================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rotary Clamp Section
; Must require both mfunc10.mac and mfunc11.mac. 
; FifthClampOut - Out6 
; + To Clamp - Turn off FifthClampOut 
;   if aux key is pressed and program not running
;   or if M10 and program is running
; + To Unclamp - Turn on FifthClampOut 
;   If it was turned on manually and a job is started
;   or if 4th axis jog key is pressed and program isn't running
;   or if program is running but M10 is not active
;
IF FifthClampOut && (!SV_PROGRAM_RUNNING && !SV_MDI_MODE) THEN SET ClampOutOfProgFlag_M
IF Aux1Key && !SV_PROGRAM_RUNNING && EStopOk THEN (Aux1_PD), (Aux1Tail_PD), SET ManClampFlag_M
IF (Aux1_PD || Ax4MinusJogKey || Ax4PlusJogKey || M11 
	|| (SV_PROGRAM_RUNNING && ManClampFlag_M)) && FifthClampOut 
    THEN RST FifthClampOut, SET SV_SCALE_INHIBIT_AXIS_4, SET ScaleInhibit
IF (Aux1_PD || M10) && !FifthClampOut 
    THEN SET FifthClampOut, RST ManClampFlag_M
IF (FifthClampOut && ClampOutOfProgFlag_M && (SV_PROGRAM_RUNNING || SV_MDI_MODE))
    THEN RST FifthClampOut, RST ClampOutOfProgFlag_M
IF FifthClampOut THEN (Aux1LED)

IF (Aux1Tail_PD || Ax4MinusJogKey || Ax4PlusJogKey || M11 
	|| (SV_PROGRAM_RUNNING && ManClampFlag_M)) && TailstockClampOut && !ManualTailControl_M 
    THEN RST TailstockClampOut
IF (Aux1Tail_PD || M10) && !TailstockClampOut && !ManualTailControl_M 
    THEN SET TailstockClampOut
IF (TailstockClampOut && ClampOutOfProgFlag_M && (SV_PROGRAM_RUNNING || SV_MDI_MODE) && !ManualTailControl_M)
    THEN RST TailstockClampOut

;----------------------------------------------
; Tailstock Clamp
;----------------------------------------------
IF (Aux11Key  && EStopOk) then (Aux11_PD)
IF (Aux11_PD && !TailstockClampOut) THEN SET TailstockClampOut, SET ManualTailControl_M
IF Aux11_PD && TailstockClampOut THEN RST TailstockClampOut, RST ManualTailControl_M
IF TailstockClampOut THEN (Aux11LED)    ;added by AWG for Blair

;IF (!FifthClampOut) THEN SET SV_SCALE_INHIBIT_AXIS_4
IF !ScaleInhibit THEN RST SV_SCALE_INHIBIT_AXIS_4
;IF ScaleInhibit THEN SET SV_SCALE_INHIBIT_AXIS_4

;------------------------------------------------------------------------------
;                               M16 tool unclamp
;------------------------------------------------------------------------------
IF ((M16 && SV_PROGRAM_RUNNING && ZeroSpeed) || (M16 && DoingM6_M)) THEN SET ToolUnclampOut, SET AirBlowOut
IF ((!M16 && SV_PROGRAM_RUNNING) || (!ToolRelease && SV_MDI_MODE && !M16) && (!M6)) || (!M16 && DoingM6_M) || SV_STOP  
  THEN RST ToolUnclampOut, RST AirBlowOut


;-----------------------------------------------
; XOR (Invert) Arm Inputs According to P178 bit7
;--------------------------------------------------

IF (ArmAtClampInput ^ ArmInputsToggle) THEN (ArmAtClampMEM)
IF (ArmAtStopInput ^ ArmInputsToggle) THEN (ArmAtStopMEM)
IF (ArmAtHomeInput ^ ArmInputsToggle) THEN (ArmAtHomeMEM)

  
;-------------------------
     ATCMainStage
;-------------------------

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Understanding the tool change sequence
;
;  State of arm sensors through one cycle
;
;  The clamp positions are when the arm IS grabbing both
;  the tool in the spindle and the tool in the extended carousel pot.
;
;  Between Clamp1 and Clamp2 the arm moves down, rotates ~180 degrees
;  and then moves up, thus exchanging the tool in the spindle with the
;  one in the extended tool pot holder.
;
;  To move the arm from one position to another:
;    - Turn ArmMotorOut ON and wait for ArmAtStopMEM OFF  (see A below)
;    - Wait for ArmAtStopMEM ON and turn ArmMotorOut OFF  (see B below)
;    - VerIFy arm sensors for intended position, i.e.,
;        ArmAtStopMEM and ArmAtHoMEMem  (IF home position)  (see H below)
;        ArmAtStopMEM and ArmAtClampMEM (IF clamp position) (see C1 and C2 below)
;
;   Note that there IS no definitive way to dIStinguISh between Clamp1 and
;   Clamp2 states.
;
;              Home        Clamp1        Clamp2          Home
;
;               H     A  B   C1     A  B   C2     A  B   H
;  Arm_Home   ----+                                   +----
;                 |                                   |
;                 +-----------------------------------+
;
;  Arm_Stop   ------+   +---------+   +---------+   +------
;                   |   |         |   |         |   |
;                   +---+         +---+         +---+
;
;                         +-----+       +-----+
;  Arm_Clamp              |     |       |     |
;             ------------+     +-------+     +-------------
;               H     A  B   C1     A  B   C2     A  B   H
;
;  The entire tool change sequence:
;  Starting from the Arm Home position with tool clamped
;  and pot retracted:
;
;    - Move Z axIS to tool change height
;    - Orient spindle
;    - Extend tool pot
;    - Move arm to clamp1 position
;    - Unclamp tool
;    - Move arm to clamp2 position (exchange the tool in spindle and tool in pot)
;    - Clamp tool
;    - Move arm to home
;    - Retract tool pot
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IF true THEN SV_PLC_CAROUSEL_POSITION = Bin_Position_W

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Pot Down
;
IF ((M14 && ATCOverrideKey) || (M14 && DoingM6_M)) then (PotDownOut)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Pot Up
;
IF ((M15 && ATCOverrideKey) || (M15 && DoingM6_M) || (M15 && DoingM15)) then (PotUpOut)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Low Air
;
IF !(AirPressureOk ^ AirSignalNONC)  THEN SET AirTimer_T
IF (AirPressureOk ^ AirSignalNONC) THEN RST AirTimer_T
IF AirTimer_T && DoingM6_M
   then ErrorCode_W = LOW_AIR_FAULT, ;1 + 256*142, ; LOW AIR FAULT
    SET SetErrorStage, SET SV_STOP

IF M18 THEN (M18_1Shot)
IF M18_1Shot THEN Bin_Position_W = 1,
    Wanted_Bin_W = Bin_Position_W,
    ErrorCode_W = ATC_INITIALIZED ;2 + 256*139, ; --- ATC Initialized ---

;IF M19 && !ToolUnclamped
;   then ErrorCode_W = M19_FAULT_TOOL_CLAMPED, ;1 + 256*143, ; M19 FAULT TOOL CLAMPED
;        set SetErrorStage

IF M13 THEN (M13_1Shot)
IF ((M13_1Shot && ATCOverrideKey) || (M13_1Shot && DoingM6_M))
  THEN SET ATC_M13ArmRotateStage

;IF 1==1 && SV_PC_SOFTWARE_READY THEN (StopReason_1Shot)
;IF StopReason_1Shot THEN SET StopReason_T

;; Handle tool pre-fetch being sent down from CNC11
;; txxx M107

;IF StopReason_1Shot THEN NewM107Bin_W = SV_TOOL_NUMBER
IF SV_PC_SOFTWARE_READY THEN NewM107Bin_W = SV_TOOL_NUMBER

IF NewM107Bin_W != OldM107Binr_W && !DoingRotate_M && !DoingM6_M
   && NewM107Bin_W >= 1 && NewM107Bin_W <= Max_Bins_W
   THEN
     Wanted_Bin_W = NewM107Bin_W, OldM107Binr_W = NewM107Bin_W,
     SET DoingRotate_M, SET ATC_SetDirectionStage

IF ToolIndexUpKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  && StopReason_1Shot
   && SV_PC_SOFTWARE_READY
  THEN SET DoingIndex_M,
       SET ATC_DoToolIndexUpStage

IF ToolIndexDnKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  && StopReason_1Shot
   && SV_PC_SOFTWARE_READY
  THEN SET DoingIndex_M,
       SET ATC_DoToolIndexDnStage

;IF ToolIndexUpKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  THEN SET DoingIndex_M,
;       SET ATC_DoToolIndexUpStage

;IF ToolIndexDnKey && !SV_PROGRAM_RUNNING && !DoingIndex_M
;  THEN SET DoingIndex_M,
;       SET ATC_DoToolIndexDnStage

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check for running a job and
; not doing an M6 tool change
; and ATC signals not in correct state.
;
; Note that since the carousel must rotate
; to the next tool while a job IS running
; that the ToolCounter sensor IS only
; checked when not doing the rotation.
;
IF SV_PROGRAM_RUNNING && !DoingM6_M && !ATCOverrideKey && !DoingIndex_M &&
   (
     !ArmAtHoMEMem || ArmAtClampMEM || !ArmAtStopMEM ||
     ToolUnclamped ||
     PotDown || !PotUp ||
     (!DoingRotate_M && (!ToolCounter ^ ToolCounterNONC))
   )
  then (tempbit) 

IF tempbit && !ArmAtHoMEMem
   then ErrorCode_W = ATC_NR_ARM_HOME   ;1 + 256*101 ; ATC NOT READY: ArmAtHoMEMem INP

IF tempbit && ArmAtClampMEM
   then ErrorCode_W = ATC_NR_ARM_AT_CLAMP   ;1 + 256*102 ; ATC NOT READY: ArmAtClampMEM INP

IF tempbit && !ArmAtStopMEM
   then ErrorCode_W = ATC_NR_ARM_AT_STOP   ;1 + 256*103 ; ATC NOT READY: ArmAtStopMEM INP

IF tempbit && ToolUnclamped
   then ErrorCode_W = ATC_NR_TOOL_UNCLMP  ;1 + 256*104 ; ATC NOT READY: ToolUnclamped INP

;IF tempbit &&  !ToolClamped
;   then ErrorCode_W = ATC_NR_TOOL_CLMP  ;1 + 256*105 ; ATC NOT READY: ToolClamped INP

IF tempbit && PotDown
   then ErrorCode_W = ATC_NR_POT_DOWN  ;1 + 256*106 ; ATC NOT READY: PotDown INP

IF tempbit && !PotUp
   then ErrorCode_W = ATC_NR_POT_UP  ;1 + 256*107 ; ATC NOT READY: PotUp INP

IF tempbit && (!ToolCounter ^ ToolCounterNONC)
   then ErrorCode_W = ATC_NR_TOOL_COUNTER  ;1 + 256*108 ; ATC NOT READY: ToolCounter INP

IF tempbit then RST tempbit,
   SET SetErrorStage, SET SV_STOP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Stop condition - reset
;   all solenoids and ATC stages
;
IF SV_STOP THEN
;
;  Reset Stages Involved in DoingToolChange
;
   RST OrientRequestOut,
   RST ATC_DoToolIndexUpStage,
   RST ATC_DoToolIndexDnStage,
   RST ATC_M13ArmRotateStage,
   RST M13_ArmWaitStopStage,
   RST ATC_CheckStageRotateStage,
   RST ATC_ReadyStage,
   RST ATC_MoveZAxisStage,
   RST ATC_PotDownStage,
   RST ATC_OrientStage,
   RST ATC_ArmAtHomeToClampStage,
   RST ATC_AHTCWaitStopStage,
   RST ATC_UnclampStage,
   RST ATC_ArmDown180UpStage,
   RST ATC_AD1UWaitStopStage,
   RST ATC_ClampStage,
   RST ATC_ArmAtClampToHomeStage,
   RST ATC_ACTHWaitStopStage,
   RST ATC_PotUpStage,
   RST ATC_EndStage,
   RST ATC_AcceptStage,
   RST ATC_SetDirectionStage,
   RST ATC_RotateStage,
   RST ATC_DoneRotateStage,
   RST ATC_CountStage,
   RST ATC_CheckStage,
;
;  Turn Off Solenoids and Motors
;
   RST PotUpOut,
   RST PotDownOut,
   RST ArmMotorOut,
   RST ToolUnclampOut,
   RST AirBlowOut,
   RST MagMotorCWOut,
   RST MagMotorCCWOut,
;
;  Reset Tool Change Status Flags
;
   RST DoingM6_M,
   RST DoingRotate_M,
   RST DoingIndex_M,
   RST ArmHasMoved_M,
   RST ArmHasStopped_M,
   RST ChipPumpOut,
   RST SpindleFault_T,
   RST ATC_Timeout_T,
   RST M6EndAck,
   RST M6,
   RST DoingM6_M,
   ;RST FifthClampOut,
   ;RST TailstockClampOut,
   RST DoingM15
   
;--------------------
     ATC_InitialStage
;--------------------
IF true then
   RST END_REQ_M,
   RST MZ_REQ_M,
   RST DoingM6_M

IF M6 then JMP ATC_CheckStageRotateStage

;--------------------
     ATC_CheckStageRotateStage
;--------------------
IF true THEN Wanted_Bin_W = SV_TOOL_NUMBER

IF Wanted_Bin_W < 1 || Wanted_Bin_W > Max_Bins_W
   THEN ErrorCode_W = ATC_BIN_OUT_OF_RANGE, ;1 + 256*109 ;, ; "ATC Bin Out of Range"
      JMP SetErrorStage, SET SV_STOP

IF Wanted_Bin_W != Bin_Position_W && !DoingRotate_M
   then SET DoingRotate_M, SET ATC_SetDirectionStage

IF !DoingRotate_M && !MagMotorCWOut && !MagMotorCCWOut then JMP ATC_ReadyStage

;--------------------
     ATC_ReadyStage
;--------------------

IF M6
   then JMP ATC_MoveZAxisStage,
    SET DoingM6_M,
    (tempbit)

;IF MZ_ACK
;  then ErrorCode_W = ATC_NR_MZ_ACK  ;1 + 256*110 ; ATC NOT READY: MZ_ACK

IF !tempbit then jmp SetErrorStage, SET SV_STOP


;--------------------
     ATC_MoveZAxisStage
;--------------------
IF true then set MZ_REQ_M,
         SET ATC_Timeout_T

IF M6EndAck && M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   !PotDown && PotUp  &&
   (ToolCounter ^ ToolCounterNONC)
   then JMP ATC_EndStage, RST ATC_Timeout_T

IF ATC_Timeout_T
   then ErrorCode_W = ATC_TIMEOUT, ;1 + 256*146 ; ATC TIMEOUT
    jmp SetErrorStage, RST ATC_Timeout_T, SET SV_STOP


;--------------------------
     ATC_OrientStage
;--------------------------
IF true then RST MZ_REQ_M,
         ;SET OrientRequestOut,
         SET ATC_Orient_T1
;IF !M19 then RST OrientRequestOut

IF !MZ_ACK && M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   !PotDown && PotUp  &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_PotDownStage, RST ATC_Orient_T1

IF ATC_Orient_T1
   then ErrorCode_W = ATC_TIMEOUT_ORIENT_STAGE, ;1 + 256*112, ; ATC_OrientStage TIMEOUT
    jmp SetErrorStage, RST ATC_Orient_T1, SET SV_STOP


;--------------------------
     ATC_PotDownStage
;--------------------------
IF true then SET PotDownOut,
         SET ATC_PotDown_T1

IF !MZ_ACK && M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_ArmAtHomeToClampStage, RST ATC_PotDown_T1

IF ATC_PotDown_T1
   then ErrorCode_W = ATC_TIMEOUT_POT_DOWN_STAGE, ;1 + 256*113 ; ATC_PotDownStage TIMEOUT
    jmp SetErrorStage, RST ATC_PotDown_T1, SET SV_STOP

IF !OrientComplete ^ OrientCompleteNONC
   then ErrorCode_W = ATC_ORIENT_LOST_POT_DOWN_STAGE, ;1 + 256*114 ; ATC_PotDownStage ORIENT LOST
    jmp SetErrorStage, RST ATC_PotDown_T1, SET SV_STOP


;--------------------------
     ATC_ArmAtHomeToClampStage
;--------------------------
;IF true then RST PotDownOut,
;         SET ArmMotorOut,
;         SET ATC_ARM_HTC_T1

;IF !MZ_ACK && M6 &&
;   !ArmAtHoMEMem && !ArmAtClampMEM && !ArmAtStopMEM &&
;   !ToolUnclamped && ToolClamped &&
;   PotDown && !PotUp &&
;   (ToolCounter ^ ToolCounterNONC) &&
;   (OrientComplete ^ OrientCompleteNONC)
;   then JMP ATC_AHTCWaitStopStage, RST ATC_ARM_HTC_T1

;IF ArmAtClampMEM
;   then ErrorCode_W = ATC_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*115 ; ATC_AHTC CLAMP WITHOUT STOP
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_ARM_HTC_T1, SET SV_STOP

;IF ATC_ARM_HTC_T1
;   then ErrorCode_W = ATC_TIMEOUT_ARM_TO_CLAMP, ;1 + 256*116 ; ATC_ARM_TO_CLAMP TIMEOUT
;    jmp SetErrorStage, RST ATC_ARM_HTC_T1, SET SV_STOP

IF !ArmHasStopped_M then RST PotDownOut,
         SET ArmMotorOut,
         SET ATC_ARM_HTC_T1
		 
; make sure the arm moves before we wait for it to stop:
IF !ArmAtStopMEM && ArmMotorOut THEN SET ArmHasMoved_M

; if the arm was mov-ing before:
IF ArmAtStopMEM && ArmHasMoved_M then RST ArmMotorOut, SET ArmHasStopped_M

IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && !ArmAtClampMEM && !ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_AHTCWaitStopStage, RST ATC_ARM_HTC_T1, 
   RST ArmHasStopped_M, RST ArmHasMoved_M

;IF ArmAtClampMEM
;   then ErrorCode_W = ATC_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*115 ; ATC_AHTC CLAMP WITHOUT STOP
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_ARM_HTC_T1, SET SV_STOP

IF ATC_ARM_HTC_T1
   then ErrorCode_W = ATC_TIMEOUT_ARM_TO_CLAMP, ;1 + 256*116 ; ATC_ARM_TO_CLAMP TIMEOUT
    jmp SetErrorStage, RST ATC_ARM_HTC_T1, 
	RST ArmHasStopped_M, RST ArmHasMoved_M, 
	SET SV_STOP

;--------------------------
     ATC_AHTCWaitStopStage
;--------------------------
IF true then SET ATC_AHTCWS_T1

IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_UnclampStage

IF ArmAtStopMEM then RST ArmMotorOut, RST ATC_AHTCWS_T1

IF ATC_AHTCWS_T1
   then ErrorCode_W = ATC_TIMEOUT_WAIT_STOP_AHTC_STAGE, ;1 + 256*117 ; ATC_AHTCWaitStopStage TIMEOUT
    jmp SetErrorStage, RST ATC_AHTCWS_T1, SET SV_STOP

;IF (ArmAtHoMEMem || ArmAtClampMEM) && !ArmAtStopMEM
;   then ErrorCode_W = ATC_HOME_CLAMP_WO_STOP_AHTC_STAGE, ;1 + 256*118 ; ARM HOME/CLAMP NO STOP
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_AHTCWS_T1, SET SV_STOP

;--------------------------
     ATC_UnclampStage
;--------------------------
IF true then RST ArmMotorOut,
         SET ToolUnclampOut,
         SET AirBlowOut,
         SET ATC_Unclamp_T1


IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && ArmAtClampMEM && ArmAtStopMEM &&
   ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then SET P176_T

IF (P176_T && ToolUnclamped)then JMP ATC_ArmDown180UpStage, RST ATC_Unclamp_T1

IF ATC_Unclamp_T1
   then ErrorCode_W = ATC_TIMEOUT_UNCLAMP_STAGE, ;1 + 256*119 ; ATC_UnclampStage TIMEOUT
    JMP SetErrorStage, RST ATC_Unclamp_T1, SET SV_STOP

;--------------------------
     ATC_ArmDown180UpStage
;--------------------------
IF true then SET ArmMotorOut,
         SET ATC_ARM_D180U_T1

IF !MZ_ACK && M6 &&
   !ArmAtClampMEM && !ArmAtStopMEM &&
   ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_AD1UWaitStopStage, RST ATC_ARM_D180U_T1

;IF ArmAtStopMEM then RST ArmMotorOut, RST ATC_ARM_D180U_T1
   
;IF ATC_ARM_D180U_T1
;   then ErrorCode_W = ATC_TIMEOUT_ARM_D180UP_STAGE, ;1 + 256*120 ; ATC_ARM_D180U TIMEOUT
;    JMP SetErrorStage, RST ATC_ARM_D180U_T1, SET SV_STOP

;IF !ToolUnclamped || ToolClamped
;   then ErrorCode_W = ATC_CLAMP_FAULT_ARM_D180UP_STAGE, ;1 + 256*131 ; ATC_ARM_D180U CLAMP FAULT
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_ARM_D180U_T1, SET SV_STOP


;--------------------------
     ATC_AD1UWaitStopStage
;--------------------------
IF true then SET ATC_AD1UWS_T1

IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && ArmAtClampMEM && ArmAtStopMEM &&
   ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_ClampStage, RST ATC_AD1UWS_T1

IF ArmAtStopMEM then RST ArmMotorOut, RST ATC_AD1UWS_T1

IF ATC_AD1UWS_T1
   then ErrorCode_W = ATC_TIMEOUT_ARM_D1UWS_STAGE, ;1 + 256*121 ; ATC_ARM_D1UWS TIMEOUT
    JMP SetErrorStage, RST ATC_AD1UWS_T1, SET SV_STOP

;IF (ArmAtHoMEMem || ArmAtClampMEM) && !ArmAtStopMEM
;   then ErrorCode_W = ATC_HOME_CLAMP_WO_STOP, ;1 + 256*122 ; ARM HOME/CLAMP NO STOP
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_AD1UWS_T1, SET SV_STOP

;IF !ToolUnclamped || ToolClamped
;   then ErrorCode_W = ATC_CLAMP_FAULT_ARM_D1UWS_STAGE, ;1 + 256*132 ; ATC_ARM_D1UWS CLAMP FAULT
;    JMP SetErrorStage,
;    RST ArmMotorOut, RST ATC_AD1UWS_T1, SET SV_STOP

;--------------------------
     ATC_ClampStage
;--------------------------
IF true then RST ArmMotorOut,
         RST ToolUnclampOut, RST AirBlowOut,
         SET ATC_Clamp_T1


IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC) &&
   (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_ArmAtClampToHomeStage, RST ATC_Clamp_T1


IF ATC_Clamp_T1
   then ErrorCode_W = ATC_TIMEOUT_CLAMP_STAGE, ;1 + 256*123 ; ATC_ClampStage TIMEOUT
    JMP SetErrorStage, RST ATC_Clamp_T1, SET SV_STOP


;--------------------------
     ATC_ArmAtClampToHomeStage
;--------------------------
IF true then SET ArmMotorOut,
         SET ATC_ARM_CTH_T1

IF !MZ_ACK && M6 &&
   !ArmAtHoMEMem && !ArmAtClampMEM && !ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC)
   then JMP ATC_ACTHWaitStopStage, RST ATC_ARM_CTH_T1

IF ATC_ARM_CTH_T1
   then ErrorCode_W = ATC_TIMEOUT_ARM_CTH, ;1 + 256*124 ; ATC_ARM_CTH TIMEOUT
    JMP SetErrorStage, RST ATC_ARM_CTH_T1, SET SV_STOP

IF ArmAtHoMEMem
   then ErrorCode_W = ATC_WO_STOP_ACTH_HOME_STAGE, ;1 + 256*125 ; ATC_ACTH HOME NO STOP
    JMP SetErrorStage,
    RST ArmMotorOut, RST ATC_ARM_CTH_T1, SET SV_STOP

;--------------------------
     ATC_ACTHWaitStopStage
;--------------------------
IF true then SET ATC_ACTHWS_T1

IF !MZ_ACK && M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   PotDown && !PotUp &&
   (ToolCounter ^ ToolCounterNONC)
   then JMP ATC_PotUpStage, RST ATC_ACTHWS_T1

IF ATC_ACTHWS_T1
   then ErrorCode_W = ATC_TIMEOUT_ARM_HTCWS_STAGE, ;1 + 256*126 ; ATC_ARM_HTCWS TIMEOUT
    JMP SetErrorStage, RST ATC_ACTHWS_T1, SET SV_STOP

IF ArmAtStopMEM then RST ArmMotorOut, RST ATC_ACTHWS_T1

IF (ArmAtHoMEMem || ArmAtClampMEM) && !ArmAtStopMEM
   then ErrorCode_W = ATC_WO_STOP_ARM_HOME_CLAMP, ;1 + 256*127 ; ARM HOME/CLAMP NO STOP
    JMP SetErrorStage,
    RST ArmMotorOut, RST ATC_ACTHWS_T1, SET SV_STOP

;--------------------------
     ATC_PotUpStage
;--------------------------
IF true then RST ArmMotorOut,
         SET PotUpOut,
         SET ATC_PotUp_T1

IF !MZ_ACK && M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   !PotDown && PotUp &&
   (ToolCounter ^ ToolCounterNONC)
   then JMP ATC_EndStage, RST ATC_PotUp_T1

IF ATC_PotUp_T1
   then ErrorCode_W = ATC_TIMEOUT_POT_UP_STAGE, ;1 + 256*128 ; ATC_PotUpStage TIMEOUT
    JMP SetErrorStage, RST ATC_PotUp_T1, SET SV_STOP

;--------------------------
     ATC_EndStage
;--------------------------
IF true then RST PotUpOut,
             ;RST OrientRequestOut,
         ;RST SpindleEnableOut,
         SET END_REQ_M,
         RST DoingM6_M,
		 RST PreToolChangeOrientMem,
         SET ATC_End_T1

IF !M6 &&
   ArmAtHoMEMem && !ArmAtClampMEM && ArmAtStopMEM &&
   !ToolUnclamped &&
   !PotDown && PotUp &&
   (ToolCounter ^ ToolCounterNONC) 
   ;&& (OrientComplete ^ OrientCompleteNONC)
   then JMP ATC_AcceptStage, RST ATC_End_T1

IF ATC_End_T1
   then ErrorCode_W = ATC_TIMEOUT_END_STAGE, ;1 + 256*129 ; ATC_EndStage TIMEOUT
    JMP SetErrorStage, RST ATC_End_T1, SET SV_STOP


;--------------------------
     ATC_AcceptStage
;--------------------------
IF true then JMP ATC_InitialStage

;--------------------
   ATC_SetDirectionStage
;--------------------
IF true then SET Car_enable_T

IF Wanted_Bin_W >= Bin_Position_W
   then Distance_W = Wanted_Bin_W - Bin_Position_W,  (Calc_B1_M)

IF Bin_Position_W > Wanted_Bin_W
   then Distance_W = Bin_Position_W - Wanted_Bin_W,  (Calc_B2_M)

IF Calc_B1_M && Distance_W <= Max_Bins_W/2 then MotorDir_W = 1
IF Calc_B1_M && Distance_W >  Max_Bins_W/2
   then MotorDir_W = -1,
    Distance_W = Max_Bins_W - Distance_W

IF Calc_B2_M && Distance_W <= Max_Bins_W/2 then MotorDir_W = -1
IF Calc_B2_M && Distance_W >  Max_Bins_W/2
   then MotorDir_W = 1,
    Distance_W = Max_Bins_W - Distance_W



IF Distance_W != 0 && Car_Enable_T then jmp ATC_RotateStage, RST Car_enable_T
IF Distance_W == 0 then jmp ATC_DoneRotateStage, RST Car_enable_T

;--------------------
   ATC_RotateStage
;--------------------
IF true then SET ATC_Rotate_T1,
         SET ATCRotate_M
;         SET ATC_Rotate_T2
;
; Wait until the tool sensor changes state.
;
;IF (!ToolCounter ^ ToolCounterNONC) &&
;   (ATC_Rotate_T2 || (Tool_NoISe_Fault_M && DoingIndex_M))
;     then jmp ATC_CountStage

IF MotorDir_W < 0 THEN SET MagMotorCCWOut, RST MagMotorCWOut
IF MotorDir_W > 0 THEN SET MagMotorCWOut, RST MagMotorCCWOut

IF (!ToolCounter ^ ToolCounterNONC)
    then jmp ATC_CountStage, RST ATC_Rotate_T1, RST ATC_Rotate_T2


;IF (!ToolCounter ^ ToolCounterNONC) && !ATC_Rotate_T2 && !Tool_NoISe_Fault_M
;   then ErrorCode_W = ATC_TOOL_COUNTER_NOISE, ;1 + 256*133, ; ATC TOOL COUNTER NOISE
;    set Tool_NoISe_Fault_M,
;    jmp SetErrorStage, RST ATC_Rotate_T1, RST ATC_Rotate_T2

IF ATC_Rotate_T1
   then ErrorCode_W = ATC_TIMEOUT_TOOL_COUNTER, ;1 + 256*134, ; ATC TOOL COUNTER TIMEOUT
    jmp SetErrorStage, RST ATC_Rotate_T1, RST ATC_Rotate_T2, SET SV_STOP

IF PotDown || !PotUp
   then ErrorCode_W = ATC_POT_FAULT_ROTATE_STAGE, ;1 + 256*135, ; ATC_RotateStage POT FAULT
    jmp SetErrorStage,
    RST MagMotorCWOut, RST MagMotorCCWOut, RST ATC_Rotate_T1, RST ATC_Rotate_T2, SET SV_STOP

;--------------------
   ATC_CountStage
;--------------------
IF true then SET ATC_Count_T1,
        SET ATCCount_M,
         SET ATC_Count_T2
;
; We wait until the tool sensor changes state.
;
IF (ToolCounter ^ ToolCounterNONC)
   then jmp ATC_CheckStage, RST ATC_Count_T1, RST ATC_Count_T2

;IF (ToolCounter ^ ToolCounterNONC)
;   then jmp ATC_CheckStage, RST ATC_Count_T1, RST ATC_Count_T2


;IF (ToolCounter ^ ToolCounterNONC) && !ATC_Count_T2
;   then ErrorCode_W = ATC_TOOL_COUNTER_NOISE_COUNT_STAGE, ;1 + 256*136, ; ATC TOOL COUNTER NOISE
;    set Tool_NoISe_Fault_M,
;    jmp SetErrorStage, RST ATC_Count_T1, RST ATC_Count_T2

IF ATC_Count_T1
   then ErrorCode_W = ATC_TIMEOUT_TOOL_COUNTER_COUNT_STAGE, ;1 + 256*137, ; ATC TOOL COUNTER TIMEOUT
    jmp SetErrorStage, RST ATC_Count_T1, RST ATC_Count_T2 , SET SV_STOP

IF PotDown || !PotUp
   then ErrorCode_W = ATC_POT_FAULT_COUNT_STAGE, ;1 + 256*138, ; ATC_CountStage POT FAULT
    jmp SetErrorStage,
    RST MagMotorCWOut, RST MagMotorCCWOut, RST ATC_Count_T1, RST ATC_Count_T2 , SET SV_STOP

;--------------------
   ATC_CheckStage
;--------------------

IF MagMotorCCWOut then Bin_Position_W = Bin_Position_W - 1
IF MagMotorCWOut then Bin_Position_W = Bin_Position_W + 1
IF Bin_Position_W > Max_Bins_W then Bin_Position_W = 1
IF Bin_Position_W < 1        then Bin_Position_W = Max_Bins_W

IF Distance_W > 0 THEN Distance_W = Distance_W - 1

IF true then jmp ATC_DoneRotateStage

;--------------------
   ATC_DoneRotateStage
;--------------------

IF DoingIndex_M && Tool_NoISe_Fault_M
   then ErrorCode_W = ATC_TOOL_COUNTER_FAULT_CLEARED, ;2 + 256*140, ; Tool Counter Fault Cleared
    rst Tool_NoISe_Fault_M


IF Bin_Position_W == Wanted_Bin_W
   then RST MagMotorCWOut,
    RST MagMotorCCWOut,
    RST DoingIndex_M,
    RST DoingRotate_M,
    RST ATC_DoneRotateStage


IF Bin_Position_W != Wanted_Bin_W
   then jmp ATC_RotateStage

;----------------------
     ATC_DoToolIndexUpStage
;----------------------

IF true THEN Wanted_Bin_W = Bin_Position_W + 1,
         JMP ATC_SetDirectionStage

IF Wanted_Bin_W > Max_Bins_W THEN Wanted_Bin_W = 1

;----------------------
     ATC_DoToolIndexDnStage
;----------------------

IF true THEN Wanted_Bin_W = Bin_Position_W - 1,
         JMP ATC_SetDirectionStage

IF Wanted_Bin_W < 1 THEN Wanted_Bin_W = Max_Bins_W

;--------------------
     ATC_M13ArmRotateStage
;--------------------
IF true then SET ArmMotorOut
IF !ArmAtStopMEM then JMP M13_ArmWaitStopStage

;--------------------
     M13_ArmWaitStopStage
;--------------------
IF ArmAtStopMEM then RST ArmMotorOut,
         RST M13_ArmWaitStopStage


;-----------------------------
   ATC_DoM19Stage
;-----------------------------
;IF SV_PROGRAM_RUNNING || SV_MDI_MODE THEN SET OrientRequestOut

IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE && ATC_OrientLost_T
   then ErrorCode_W = M19_STOPPED_M19_STAGE, ;1 + 256*144, ; M19 STOPPED
   jmp SetErrorStage , SET SV_STOP

IF (OrientComplete ^ OrientCompleteNONC) THEN JMP ATC_MonitorM19Stage, RST ATC_OrientLost_T

;IF !M19  THEN RST ATC_DoM19Stage, RST ATC_OrientLost_T,
;             RST OrientRequestOut

;-----------------------------
   ATC_MonitorM19Stage
;-----------------------------

IF (!OrientComplete ^ OrientCompleteNONC) then SET ATC_OrientLost_T
IF (OrientComplete ^ OrientCompleteNONC) then RST ATC_OrientLost_T

IF ATC_OrientLost_T   then ErrorCode_W = M19_ORIENT_LOST_M19_MON_STAGE, ;1 + 256*145, ; M19 ORIENT LOST
    jmp SetErrorStage, RST ATC_OrientLost_T, SET SV_STOP

;IF !M19 THEN RST ATC_MonitorM19Stage,
;         RST OrientRequestOut, 
;		 RST ATC_OrientLost_T
		 
;==========================================================
      ToolThruOffStage
;==========================================================
; Tool thru Coolant Control
;   Toggle Tool thru hole coolant coolant on and off if coolant mode is manual
;   When switching from Auto to manual mode, turn off flood coolant
;
;   Tool Thru Coolant Hole Fault: Tripped when INP7 (ThruCoolantOk) if there are any
;
IF True THEN RST ThruCoolantOut
IF ( M88 && CoolAutoManLED) THEN (M88_PD)
IF !SV_Stop && !M6 && M88_PD 
    THEN JMP ToolthruONStage

;==========================================================
;==========================================================
     ToolThruOnStage
;==========================================================
IF True THEN SET ThruCoolantOut

IF (!M88 && CoolAutoManLED) || SV_STOP || !SV_PROGRAM_RUNNING
	THEN JMP ToolThruOFFStage
	
;==========================================================
     AugerOffStage
;==========================================================
IF true THEN RST Aux5LED,
	     RST Aux6LED,
	     RST Auger1FwdOut,
         RST Auger1RevOut

IF DoAux5Key THEN (CAFWD_PD), SET AugerKeyStart_M	     
IF DoAux6Key THEN (CAREV_PD), SET AugerKeyStart_M
IF M31 || M32 THEN (CA1_PD)
IF (M31 && CA1_PD) || (CAFWD_PD && EstopOk) THEN JMP AugerFwdStage
IF (M32 && CA1_PD) || (CAREV_PD && EstopOk) THEN JMP AugerRevStage

;==========================================================
    AugerFwdStage
;==========================================================
IF True THEN RST Aux6LED,
	     SET Aux5LED
;
; Set Pr. 171 to 1 to enable Auger 1 / 2 Selection Stage
;
IF P171Value_W == 0
	THEN SET Auger1FwdOut,
         RST Auger1RevOut
IF P171Value_W == 1 && Aux4LED  
	THEN SET Auger1FwdOut,
             RST Auger1RevOut
          
IF DoAux5Key THEN (CAFWD_OFF_PD), RST AugerKeyStart_M	     
IF DoAux6Key THEN (CAREV_ON_PD)
IF M32 || M33 THEN (CA2_PD)

IF (M32 && CA2_PD) || (CAREV_ON_PD)	THEN JMP AugerRevStage
IF (M33 && CA2_PD) || (CAFWD_OFF_PD) || !EstopOk THEN JMP AugerOffStage

;==========================================================
    AugerRevStage
;==========================================================
IF True THEN SET Aux6LED,
	     RST Aux5LED
;
; Set Pr. 171 to 1 to enable Auger 1 / 2 Selection Stage
;
IF P171Value_W == 0
	THEN RST Auger1FwdOut,
         SET Auger1RevOut
IF P171Value_W == 1 && Aux4LED 
	THEN RST Auger1FwdOut,
             SET Auger1RevOut
	     
IF DoAux5Key THEN (CAFWD_ON_PD)	     
;IF DoAux6Key THEN (CAREV_OFF_PD)
IF (M33 || M31) THEN (CA3_PD)

IF (M31 && CA3_PD) || (CAFWD_ON_PD) THEN JMP AugerFwdStage
IF (M33 && CA3_PD) || (!Aux6Key) || !EstopOk THEN JMP AugerOffStage
;
;==========================================================
     AugerSelectStage
;==========================================================
;
; Auger 1 / Auger 2 Selection
; Uses the Aux4LED to signify the state
;
IF DoAux4Key THEN (AugerSelectPD)
IF (Aux4LED && AugerSelectPD && P171Value_W == 1) THEN RST Aux4LED 
IF (!Aux4LED && AugerSelectPD && P171Value_W == 1) THEN SET Aux4LED 

;==========================================================
	DoorInterlockStage
;==========================================================
; Set and reset Door Interock Override
IF (!(DoorClosed ^ DoorSWNONC) && ProbeDetect && Aux13Key && ATCOverrideKey) 
    THEN SET DoorInterlock_Override_M
IF ((DoorClosed ^ DoorSWNONC) || !ProbeDetect || !EstopOK) 
    THEN RST DoorInterlock_Override_M

; If door open and not running a job, and not override then slow jog only:
IF (!SV_PROGRAM_RUNNING && !SV_MDI_MODE && DoorInterlockMode_M 
    && !(DoorClosed ^ DoorSWNONC) && !DoorInterlock_Override_M) 
    THEN (DoorOpenSlowJog_M)

; Control of door messages, and check for Door Closed:
IF ((SV_PROGRAM_RUNNING || SV_MDI_MODE)  
    && !(DoorClosed ^ DoorSWNONC) && !DoorInterlock_Override_M) 
    THEN SET DoorLockDelay_T,
        ErrorCode_W = WAITING_FOR_DOOR_CLOSED,
        SET FeedHoldLED

; Control the Door Lock Solenoid Output,
; when job running, door is locked
IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE && ZeroSpeed THEN SET DoorUnLockOut
IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorInterlockMode_M THEN RST DoorUnLockOut

; Reset the error timer if door is locked
IF (SV_PROGRAM_RUNNING || SV_MDI_MODE) && DoorLocked THEN RST DoorLockDelay_T
IF !SV_PROGRAM_RUNNING && !SV_MDI_MODE THEN RST DoorLockDelay_T

IF DoorLockDelay_T THEN ErrorCode_W = DOOR_NOT_LOCKED, SET SV_STOP, RST DoorLockDelay_T

;==========================================================
   SetErrorStage
;==========================================================
IF !((ErrorCode_W % 256 == 1) || (ErrorCode_W % 256 == 2)) THEN JMP BadErrorStage
IF true THEN MSG ErrorCode_W
If ErrorCode_W != MSG_CLEARED_MSG Then MsgClear_T = 1000, set MsgClear_T

IF (!EstopOk && !SoftwareReady_M) || ((ErrorCode_W != MSG_CLEARED_MSG) && (ErrorCode_W % 2 == 0) &&
  MsgClear_T) Then ErrorCode_W = MSG_CLEARED_MSG, rst MsgClear_T


IF SV_STALL_ERROR THEN (Echo_Stall_M)
IF SV_STOP THEN (Echo_Stop_M)

IF SV_MASTER_ENABLE THEN (MasterEnable_M)
IF !SV_STOP THEN (NoFaultOut)

IF !EstopOk Then (DriveResetOut)
IF EstopOk Then SET SpindleFault_T
;==========================================================
   BadErrorStage
;==========================================================
IF true THEN AsyncMsg_W = 2+256*100, MSG AsyncMsg_W, AsyncMsg_W = 0
IF true THEN rst BadErrorStage
