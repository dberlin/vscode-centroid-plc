;-------------------------------------------------------------------------------
; File:        K100066.src
; Programmer:  Drew Gear
; Date:        11 AUG 2010
; Purpose:     PLC for MPU11 and GPIO4D + keyboard jog
; Requires:    CNC11 v3.01 R12+
;
; $Id: K100066.src 835 2017-07-21 13:49:52Z milton $
;
; Mpu11 based systems have the ability to invert, force and/or select a custom
; debounce time on PLC inputs 1-240 using SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64.
; Jog Panel inputs are modified in the same manner using SV_JOG_LINK_DEBOUNCE_1
; -SV_JOG_LINK_DEBOUNCE_64. See system variable section for more information.

; The Mpu11 board includes connections for several types of auxillary I/O.
; 4 digital "high speed" inputs (INP769-772) typically used for probe/TT1
; related functions,, 3 auxillary digital inputs (INP784-786), 11 Digital inputs
; used for MPG increment and axis selection and 2 auxillary digital outputs
; (Out770-771).

; GP4IOD Physical I/O: While each GPIO4D that is installed reserves (maps) 32
; inputs and 32 Outputs, only 20 inputs and 24 outputs are accessible through
; hardware.

; Inputs: The GPIO4D provides 20 inputs, 16 of which (1-16) are available for
; general purpose use.  Inputs 1-16 can be configured for 5, 12 or 24VDC
; operation in either a sourcing or sinking configuration.  Inputs 17-20 are a
; contact closure type input (input must be closed to the input common) which
; are generally reserved for drive fault inputs.  One of these inputs are found
; on each of the axis control headers (H11-H14) and are labeled as "Fault In"

; Outputs: The GPIO4D has 16 relay contact closure outputs.  Outputs 1-7, 10-16
; are SPST type relays while Outputs 8 & 9 are SPDT type relays.  Each
; mapped PLC output from 17-20 actually controls 2 Open Collector type outputs.
; The purpose of each of these paired outputs are to control an enable
; and brake output for each axis.  One pair of these outputs are found on each
; of the axis control headers (H11-H14) and are labeled as "Drive Enable" &
; "Brake Out"

; Analog outputs: The 12 bit 0-10VDC analog output on the GPIO4D is mapped to
; outputs 305-316.  NOTE: The spindle speed command that comes down from the PC
; (SV_PC_DAC_SPINDLE_SPEED) is a 16 bit integer value from 0-65535 that must be
; converted to a 12 bit value from 0-4095 by the PLC.  The PLC handles gear ranges
; by looking at the state of inputs and reading parameters (or hard coded values)
; to determine the ratio needed for adjusting the spindle speed display system
; variable

;----------------------------------------------------------------
;--CONSTANT DEFINITIONS
;----------------------------------------------------------------

PLC_EXECUTOR_FLT_MSG   IS (1+256*1)  ;257

PLC_INFLT              IS (1+256*22) ;5633
PLC_OUTFLT             IS (1+256*23) ;5889
PLC_FLT_CLR            IS (2+256*24) ;6146
AXIS1_DRIVE_FAULT_MSG  IS (1+256*25) ;6401
AXIS2_DRIVE_FAULT_MSG  IS (1+256*26) ;6657
AXIS3_DRIVE_FAULT_MSG  IS (1+256*27) ;6913
AXIS4_DRIVE_FAULT_MSG  IS (1+256*28) ;7169
AXIS_DRIVE_FAULT_CLR   IS (1+256*29) ;7425
SPINDLE_FAULT_MSG      IS (1+256*30) ;7681
AIR_FAULT_MSG          IS (1+256*31) ;7937

PROBE_FAULT_MSG        IS (1+256*34) ;8705
KB_JOG_MSG             IS (2+256*35) ;8962
PROBE_JOG_FAULT_MSG    IS (1+256*37) ;9473
MIN_SPEED_MSG          IS (2+256*38) ;9730
SOFTWARE_EXIT_MSG      IS (1+256*39) ;9985

TURRET_NOT_AT_TOOL_FAULT_MSG IS (1+256*41) ;10497
TURRET_DOWN_FAULT_MSG  IS (1+256*42) ;10753
TOOL_CHANGE_FAULT_MSG  IS (1+256*43) ;11009
INVALID_TOOL_MSG       IS (2+256*44) ;11266
TOOL_CHANGE_DONE_MSG   IS (2+256*45) ;11522
SPINDLE_CHUCK_WARNING_MSG IS (2+256*46) ; 

MINI_PLC_1_FAULT_MSG   IS (1+256*60); 15361
MINI_PLC_2_FAULT_MSG   IS (1+256*61); 15617
MINI_PLC_3_FAULT_MSG   IS (1+256*62); 15873
MINI_PLC_4_FAULT_MSG   IS (1+256*63); 16129

MSG_CLEARED_MSG        IS (1+256*99) ;25345

;-----------------------------------------------------------------------------
;--INPUT DEFINITIONS
;Closed = 1 (green)  Open = 0 (red)
;-----------------------------------------------------------------------------
Ax1_MinusLimitOk   IS INP1
Ax1_PlusLimitOk    IS INP2
Ax2_MinusLimitOk   IS INP3
Ax2_PlusLimitOk    IS INP4
Ax1_HomeSwitchOk   IS INP5
Ax2_HomeSwitchOk   IS INP6
Ax1_TempSwitchOk   IS INP7
Ax2_TempSwitchOk   IS INP8
;                  IS INP9
SpindleInverterOk  IS INP10 ;Inverter is "ok" when input is closed
EStopOk            IS INP11
SpindleZeroSpeed   IS INP12
SpindleAtSpeed     IS INP13
AirOk              IS INP14
;                  IS INP15
;                  IS INP16
Axis1DriveOk       IS INP17 ;Labeled "Fault In" on drive header H14
Axis2DriveOk       IS INP18 ;Labeled "Fault In" on drive header H13
Axis3DriveOk       IS INP19 ;Labeled "Fault In" on drive header H12
Axis4DriveOk       IS INP20 ;Labeled "Fault In" on drive header H11

;Inputs 21-32 are unvailable

;PLCADD1616 Expansion I/O board 1
Tool1           IS INP33
Tool2           IS INP34
Tool3           IS INP35
Tool4           IS INP36
TurretAtTool    IS INP37;true when turret is at 90 deg. position
TurretLocked    IS INP38;true when the turret is locked down
;               IS INP39
;               IS INP40
;               IS INP41
;               IS INP42
;               IS INP43
;               IS INP44
;               IS INP45
;               IS INP46
;               IS INP47
;               IS INP48

;INP769 - INP784 encompass the MPU11 onboard input connections
;which are generally used for MPG and probing functions.
MechnicalProbe  IS INP769
DSPProbe        IS INP770
ProbeDetect     IS INP771
ProbeAux        IS INP772
MPG_Inc_X_1     IS INP773
MPG_Inc_X_10    IS INP774
MPG_Inc_X_100   IS INP775
MPG_AXIS_1      IS INP776
MPG_AXIS_2      IS INP777
MPG_AXIS_3      IS INP778
MPG_AXIS_4      IS INP779
MPG_AXIS_5      IS INP780
MPG_AXIS_6      IS INP781
MPG_AXIS_7      IS INP782
MPG_AXIS_8      IS INP783

;-----------------------------------------------------------------------------
;--JOG PANEL INPUT DEFINITIONS
;Jog Panel Inputs can be addressed as JPI1 - JPI256 or INP1057 - INP11312
;-----------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right

SpinOverPlusKey       IS JPI1  ; Row  1 Column 1
SpinAutoManKey        IS JPI2  ; Row  1 Column 2
Aux1Key               IS JPI3  ; Row  1 Column 3
Aux2Key               IS JPI4  ; Row  1 Column 4
TurretIndexKey        IS JPI5  ; Row  1 Column 5; Aux3

SpinOver100Key        IS JPI6  ; Row  2 Column 1
SpinCWKey             IS JPI7  ; Row  2 Column 2
Aux4Key               IS JPI8  ; Row  2 Column 3
Aux5Key               IS JPI9  ; Row  2 Column 4
Aux6Key               IS JPI10 ; Row  2 Column 5

SpinOverMinusKey      IS JPI11 ; Row  3 Column 1
SpinCCWKey            IS JPI12 ; Row  3 Column 2
WorklightKey          IS JPI13 ; Row  3 Column 3; Aux7
ChuckOpenKey          IS JPI14 ; Row  3 Column 4; Aux8
ChuckCloseKey         IS JPI15 ; Row  3 Column 5; Aux9

SpinStopKey           IS JPI16 ; Row  4 Column 1
SpinStartKey          IS JPI17 ; Row  4 Column 2
Aux10Key              IS JPI18 ; Row  4 Column 3
Aux11Key              IS JPI19 ; Row  4 Column 4
Aux12Key              IS JPI20 ; Row  4 Column 5

CoolAutoManKey        IS JPI21 ; Row  5 Column 1
CoolFloodKey          IS JPI22 ; Row  5 Column 2
CoolMistKey           IS JPI23 ; Row  5 Column 3
Aux13Key              IS JPI24 ; Row  5 Column 4
UnusedR5C5Key         IS JPI25 ; Row  5 Column 5

IncrContKey           IS JPI26  ; Row  6 Column 1
x1JogKey              IS JPI27  ; Row  6 Column 2
x10JogKey             IS JPI28  ; Row  6 Column 3
x100JogKey            IS JPI29  ; Row  6 Column 4
MPGKey                IS JPI30  ; Row  6 Column 5

Ax4PlusJogKey         IS JPI31  ; Row  7 Column 1
UnusedR7C2Key         IS JPI32  ; Row  7 Column 2
Ax2PlusJogKey         IS JPI33  ; Row  7 Column 3
UnusedR7C4Key         IS JPI34  ; Row  7 Column 4
Ax3PlusJogKey         IS JPI35  ; Row  7 Column 5

UnusedR8C1Key         IS JPI36  ; Row  8 Column 1
Ax1MinusJogKey        IS JPI37  ; Row  8 Column 2
FastSlowKey           IS JPI38  ; Row  8 Column 3
Ax1PlusJogKey         IS JPI39  ; Row  8 Column 4
UnusedR8C5Key         IS JPI40  ; Row  8 Column 5

Ax4MinusJogKey        IS JPI41  ; Row  9 Column 1
UnusedR9C2Key         IS JPI42  ; Row  9 Column 2
Ax2MinusJogKey        IS JPI43  ; Row  9 Column 3
UnusedR9C4Key         IS JPI44  ; Row  9 Column 4
Ax3MinusJogKey        IS JPI45  ; Row  9 Column 5

CycleCancelKey        IS JPI46  ; Row 10 Column 1
SingleBlockKey        IS JPI47  ; Row 10 Column 2
ToolCheckKey          IS JPI48  ; Row 10 Column 3
FeedHoldKey           IS JPI49  ; Row 10 Column 4
CycleStartKey         IS JPI50  ; Row 10 Column 5

;--Feedrate Override Knob
JpFeedOrKnobBit0      IS JPI193
JpFeedOrKnobBit1      IS JPI194
JpFeedOrKnobBit2      IS JPI195
JpFeedOrKnobBit3      IS JPI196
JpFeedOrKnobBit4      IS JPI197
JpFeedOrKnobBit5      IS JPI198
JpFeedOrKnobBit6      IS JPI199
JpFeedOrKnobBit7      IS JPI200
JpFeedOrKnobBit8      IS JPI201 ; Current jog panels send first 8 bits
JpFeedOrKnobBit9      IS JPI202 ; unused
JpFeedOrKnobBit10     IS JPI203 ; unused
JpFeedOrKnobBit11     IS JPI204 ; unused
JpFeedOrKnobBit12     IS JPI205 ; unused
JpFeedOrKnobBit13     IS JPI206 ; unused
JpFeedOrKnobBit14     IS JPI207 ; unused
JpFeedOrKnobBit15     IS JPI208 ; unused


;-----------------------------------------------------------------------------
;--GPIO4D PLC OUTPUT DEFINITIONS
;Logic 1 = OUTPUT ON (Green), 0 = OUTPUT OFF (Red)
;-----------------------------------------------------------------------------
NoFaultOut            IS OUT1  ;SPST Type
Lube                  IS OUT2  ;SPST Type
Flood                 IS OUT3  ;SPST Type
InverterEStop         IS OUT4  ;SPST Type; Tell Inverter Estop is out
InverterResetOut      IS OUT5  ;SPST Type
WorklightOut          IS OUT6  ;SPST Type
SpindleEnableOut      IS OUT7  ;SPST Type
SpindleDirectionOut   IS OUT8  ;SPDT Type
;                     IS OUT9  ;SPDT Type
ChuckOpenSol          IS OUT10 ;SPST Type; M11 || Aux7
ChuckCloseSol         IS OUT11 ;SPST Type; M10 || Aux8
TurretIndexSol        IS OUT12 ;SPST Type; M6 || Aux3
;                     IS OUT13 ;SPST Type
;                     IS OUT14 ;SPST Type
;                     IS OUT15 ;SPST Type
;                     IS OUT16 ;SPDT Type
;NOTE: The GPIO4D features an internally controlled SPDT relay which is
;      physically located next to OUT16 on H2.  This output is not OUT17
;      nor is it accessible via the PLC.  In the GPIO4D manual it is simply
;      referred to as "fault" and is described as follows:
;      "The fault output will remain closed as long as the GPIO4D does
;      not detect any serious errors, such as a loss of communication."
;      It is suggested that, when considering your Estop loop, you wire
;      this relay in series with a PLC controllable output such as OUT1,
;      NoFaultOut.  Wiring in this manner will ensure that the Estop loop
;      will be disconnected when:
;      1. The operator presses the Estop switch.
;      2. The PLC detects a stop fault condition.
;      3. Communications are lost to the GPIO4D/PLC.
;      nor is it accessible via the PLC.  In the GPIO4D manual it is simply
;      referred to as "fault" and is described as follows:
;      "The fault output will remain closed as long as the GPIO4D does
;      not detect any serious errors, such as a loss of communication."
;
;      It is suggested that, when considering your Estop loop, you wire
;      this relay in series with a PLC controllable output such as OUT1,
;      NoFaultOut.  Wiring in this manner will ensure that the Estop loop
;      will be disconnected when:
;
;      1. The operator presses the Estop switch.
;      2. The PLC detects a stop fault condition.
;      3. Communications are lost to the GPIO4D/PLC.

; The open collector outputs will pull the signal they are connected to 0VDC
; when turned on.  The common (0V) of the signal your device accepts should
; be connected to the OUT COM of the respective enable/brake output listed
; below.

Axis_1_Enable         IS OUT17 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H14
Axis_2_Enable         IS OUT18 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H13
Axis_3_Enable         IS OUT19 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H12
Axis_4_Enable         IS OUT20 ;Controls TWO Open collector type outputs
                               ;labeled "Enable Out" and "Brake Out" on H11

ReleaseAx1Estop       IS OUT33 ;Set this output to enable contactor on drive
ReleaseAx2Estop       IS OUT34 ;Set this output to enable contactor on drive

; These bits control the actual analog hardware output on the GPIO4D.
; Output = 12bit (0-4095) 0-10VDC.
SpinAnalogOutBit0     IS OUT305
SpinAnalogOutBit1     IS OUT306
SpinAnalogOutBit2     IS OUT307
SpinAnalogOutBit3     IS OUT308
SpinAnalogOutBit4     IS OUT309
SpinAnalogOutBit5     IS OUT310
SpinAnalogOutBit6     IS OUT311
SpinAnalogOutBit7     IS OUT312
SpinAnalogOutBit8     IS OUT313
SpinAnalogOutBit9     IS OUT314
SpinAnalogOutBit10    IS OUT315
SpinAnalogOutBit11    IS OUT316

MPG_LED_OUT           IS OUT769

;-----------------------------------------------------------------------------
;--JOG PANEL OUTPUT (LED) DEFINITIONS
;Jog Panel LED's can be addressed as JPO1 - JPO256 OR OUT1057 - OUT11312
;-----------------------------------------------------------------------------
; Definitions follow JOGBOARD layout top to bottom, left to right
;
SpinOverPlusLED       IS JPO1  ; Row  1 Column 1
SpinAutoModeLED       IS JPO2  ; Row  1 Column 2
Aux1LED               IS JPO3  ; Row  1 Column 3
Aux2LED               IS JPO4  ; Row  1 Column 4
TurretIndexLED        IS JPO5  ; Row  1 Column 5; Aux3
SpinOver100LED        IS JPO6  ; Row  2 Column 1
SpindleCWLED          IS JPO7  ; Row  2 Column 2
Aux4LED               IS JPO8  ; Row  2 Column 3
Aux5LED               IS JPO9  ; Row  2 Column 4
Aux6LED               IS JPO10 ; Row  2 Column 5
SpinOverMinusLED      IS JPO11 ; Row  3 Column 1
SpindleCCWLED         IS JPO12 ; Row  3 Column 2
WorkLightLED          IS JPO13 ; Row  3 Column 3; Aux7
ChuckOpenLED          IS JPO14 ; Row  3 Column 4; Aux8; On when Chucks are open
ChuckCloseLED         IS JPO15 ; Row  3 Column 5; Aux9; On when Chucks are closed
SpinStopLED           IS JPO16 ; Row  4 Column 1
SpinStartLED          IS JPO17 ; Row  4 Column 2
UnusedR4C3LED         IS JPO18 ; Row  4 Column 3
UnusedR4C4LED         IS JPO19 ; Row  4 Column 4
UnusedR4C5LED         IS JPO20 ; Row  4 Column 5
CoolAutoManLED        IS JPO21 ; Row  5 Column 1
CoolFloodLED          IS JPO22 ; Row  5 Column 2
CoolMistLED           IS JPO23 ; Row  5 Column 3
Aux13LED              IS JPO24 ; Row  5 Column 4
UnusedR5C5LED         IS JPO25 ; Row  5 Column 5
IncrContLED           IS JPO26  ; Row  6 Column 1
x1JogLED              IS JPO27  ; Row  6 Column 2
x10JogLED             IS JPO28  ; Row  6 Column 3
x100JogLED            IS JPO29  ; Row  6 Column 4
MPGLED                IS JPO30  ; Row  6 Column 5
Ax4PlusJogLED         IS JPO31  ; Row  7 Column 1
UnusedR7C2LED         IS JPO32  ; Row  7 Column 2
Ax2PlusJogLED         IS JPO33  ; Row  7 Column 3
UnusedR7C4LED         IS JPO34  ; Row  7 Column 4
Ax3PlusJogLED         IS JPO35  ; Row  7 Column 5
UnusedR8C1LED         IS JPO36  ; Row  8 Column 1
Ax1MinusJogLED        IS JPO37  ; Row  8 Column 2
FastSlowLED           IS JPO38  ; Row  8 Column 3
Ax1PlusJogLED         IS JPO39  ; Row  8 Column 4
UnusedR8C5LED         IS JPO40  ; Row  8 Column 5
Ax4MinusJogLED        IS JPO41  ; Row  9 Column 1
UnusedR9C2LED         IS JPO42  ; Row  9 Column 2
Ax2MinusJogLED        IS JPO43  ; Row  9 Column 3
UnusedR9C4LED         IS JPO44  ; Row  9 Column 4
Ax3MinusJogLED        IS JPO45  ; Row  9 Column 5
CycleCancelLED        IS JPO46  ; Row 10 Column 1
SingleBlockLED        IS JPO47  ; Row 10 Column 2

; FOR JOGBRD REV??????, the LED outputs do not match Key inputs
; The PLC program should activate all three of these when
; it wants to turn on FeedHoldLED so that future hardware changes
; to put them in the same order as their corresponding inputs will work.
ToolCheckLED          IS JPO50  ; Row 10 Column 3
FeedHoldLED           IS JPO48  ; Row 10 Column 4
CycleStartLED         IS JPO49  ; Row 10 Column 5


;-----------------------------------------------------------------------------
;--MEMORY BIT DEFINITIONS
;-----------------------------------------------------------------------------
PLCExecutorFault_M      IS MEM1
SoftwareReady_M         IS MEM2
MPGManOffFlag_M         IS MEM3
EnableAxes_M            IS MEM4 ;used to enable axes when E-Stop is released
MasterEnable_M          IS MEM5
DriveFault_M            IS MEM6
ExpansionPLC_1_M        IS MEM7
PLCBus_Oe_M             IS MEM8
ErrClr_M                IS MEM9
PLCBus_Online_M         IS MEM10
Ax1PlusJogDisabled_M    IS MEM11
Ax1MinusJogDisabled_M   IS MEM12
Ax2PlusJogDisabled_M    IS MEM13
Ax2MinusJogDisabled_M   IS MEM14
ChuckOpenSafety_M       IS MEM15
ChuckOpening_M          IS MEM16
ChuckCloseSafety_M      IS MEM17
ChuckClosing_M          IS MEM18
StallError_M            IS MEM48
LubeFault_M             IS MEM49
PLCFault_M              IS MEM50
AxisFault_M             IS MEM51
PLCBusExtDevEn_M        IS MEM52
ProbeFault_M            IS MEM53
JogProbeFault_M         IS MEM54
SpindleFault_M          IS MEM55
AirFault_M              IS MEM56
KbJpActive_M            IS MEM60 ; aka SV_PC_VIRTUAL_JOGPANEL_ACTIVE
InvalidTool_M           IS MEM64
WaitToClearTool_M       IS MEM65
WaitToArriveAtTool_M    IS MEM66
ToolChangeFault_M       IS MEM67
DoingToolChange_M       IS MEM68
ToolChangeDone_M        IS MEM69
ProbeMsgSent_M          IS MEM78
InvertXJogKeys_M        IS MEM79 ; SV_MACHINE_PARAMETER_1 bit 1
SwapAxes_M              IS MEM80 ; SV_MACHINE_PARAMETER_1 bit 2
true                    IS MEM81
SpinLowRange_M          IS MEM82
SpinMedLowRange_M       IS MEM83
SpinMedHighRange_M      IS MEM84
SpinHighRange_M         IS MEM85
SpindlePause_M          IS MEM86
DisableKbInput_M        IS MEM102 ;If 1, disable kb jogging
AllowKbInput_M          IS MEM103 ;If 1, allow kb jogging
JogOverOnly_M           IS MEM105
KbOverOnly_M            IS MEM106
UsingFeedrateKnob_M     IS MEM117
WaitingForSleepTimer_M  IS MEM118
X1_M                    IS MEM119
X10_M                   IS MEM120
X100_M                  IS MEM121
OnAtPowerUp_M           IS MEM200

InvLubeOk_M          IS MEM300  ; P178 Bit 0  (1) ; add 1 to parm 178 if
                                ; lubeOk is NO
InvSpinInverterOk_M  IS MEM301  ; P178 Bit 1  (2) ; Add 2 to parm 178 if
                                ; InvSpinInverterOk_M is NO

KbCycleStart_M       IS MEM400 ; "alt" + "s"
KbCycleCancel_M      IS MEM401 ; escape
KbToolCheck_M        IS MEM402 ; "Ctrl" + "t"
KbTogSingleBlock_M   IS MEM403 ; "Ctrl" + "b"
KbIncreaseJogInc_M   IS MEM404 ; "Insert"
KbDecreaseJogInc_M   IS MEM405 ; "Delete"
KbIncFeedOver_M      IS MEM406 ; "ctrl" + "keyboard "+" ("=")
KbDecFeedOver_M      IS MEM407 ; "ctrl" + "keyboard "-"
KbFeedOver100_M      IS MEM450 ; "ctrl" + "\"
KbTogIncContJog_M    IS MEM408 ; "ctrl" + "i"
KbTogFastSlowJog_M   IS MEM409 ; "ctrl" + "f"
KbJogAx1Plus_M       IS MEM411 ; right arrow + KbJpActive_M
KbJogAx1Minus_M      IS MEM412 ; left arrow + KbJpActive_M
KbJogAx2Plus_M       IS MEM413 ; up arrow + KbJpActive_M
KbJogAx2Minus_M      IS MEM414 ; down arrow + KbJpActive_M
KbJogAx3Plus_M       IS MEM415 ; page up + KbJpActive_M
KbJogAx3Minus_M      IS MEM416 ; page down + KbJpActive_M
KbJogAx4Plus_M       IS MEM417 ; "home"+ KbJpActive_M
KbJogAx4Minus_M      IS MEM418 ; "end" + KbJpActive_M
KbAux1Key_M          IS MEM419 ; "ctrl" + "F1"
KbAux2Key_M          IS MEM420 ; "ctrl" + "F2"
KbAux3Key_M          IS MEM421 ; "ctrl" + "F3"
KbAux4Key_M          IS MEM422 ; "ctrl" + "F4"
KbAux5Key_M          IS MEM423 ; "ctrl" + "F5"
KbAux6Key_M          IS MEM424 ; "ctrl" + "F6"
KbAux7Key_M          IS MEM425 ; "ctrl" + "F7"
KbAux8Key_M          IS MEM426 ; "ctrl" + "F8"
KbAux9Key_M          IS MEM427 ; "ctrl" + "F9"
KbAux10Key_M         IS MEM428 ; "ctrl" + "F10"
KbAux11Key_M         IS MEM429 ; "ctrl" + "F11"
KbAux12Key_M         IS MEM430 ; "ctrl" + "F12"
KbTogRapidOver_M     IS MEM431 ; "ctrl" + "r"
KbTogSpinAutoMan_M   IS MEM432 ; "ctrl" + "a"
KbSpinCW_M           IS MEM433 ; "ctrl" + "c"
KbSpinCCW_M          IS MEM434 ; "ctrl" + "w"
KbSpinStart_M        IS MEM435 ; "ctrl" + "s"
KbSpinStop_M         IS MEM436 ; "ctrl" + "q"
KbFloodOnOff_M       IS MEM437 ; "ctrl" + "n"
KbMistOnOff_M        IS MEM451 ; "ctrl" + "k"
KbTogCoolAutoMan_M   IS MEM438 ; "ctrl" + "m"
KbFeedHold_M         IS MEM439 ; space bar
KbIncSpinOver_M      IS MEM440 ; "ctrl" + ">" (.)
KbDecSpinOver_M      IS MEM441 ; "ctrl" + "<" (,)
KbSpinOver100_M      IS MEM442 ; "ctrl" + "?" (/)

;-----------------------------------------------------------------------------
;--SYSTEM VARIABLES
; For a complete list of System Variables and their functions, please see the
; MPU11 PLC manual.
;-----------------------------------------------------------------------------

; MPU11 based systems provide the PLC with the ability to read/write to a
; limited number of "System Variables".  While the use of System Variables
; greatly expands PLC functionality, it comes with additional reponsibility on
; the part of the PLC programmer.  Functionality that was once implemented as
; default behavior such as jogging, spindle speed, feedrate override, spindle
; gear ranges etc... is now implemented through System Variables in the PLC
; program.  It is now the sole responsibilty of the PLC program to provide a
; method to jog an axis, override the spindle speed or feedrates or even map a
; jog panel keypress to a specific function.  Pressing a jog key or Aux key
; won't DO anything unless the PLC assigns an action to the keypress.  All jog
; panel functions MUST be explicitly implemented in the PLC program.
;                                 ----IMPORTANT----
; Menu navigation in the CNC software requires that the escape key or Cycle
; Cancel key is used to back out of menus and screens.  You must use the PLC
; program to map a jog panel key and/or a keyboard key to the Cycle Cancel
; System Variable (SV_PLC_FUNCTION_1 has been declared as "DoCycleCancel")
; in order to use the control.  For example:
; The following lines map the escape key and Jog Panel Cycle Cancel key to
; produce a Cycle Cancel event:

; 1. Map escape keypress event to identifier to describe what key was pressed.
;    Kb_Escape    IS SV_PC_Keyboard_Key_1

; 2. Map MEM bit to identifier that describes what the keypress is used for.
;    KbCycleCancel_M  IS MEM401

; 3. Logic to "SET" KbCycleCancel_M anytime the escape key is pressed.
;    if Kb_Escape THEN(KbCycleCancel_M)

; 4. Logic to cancel job if the escape key or cycle cancle key is pressed.
;    IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)

;   Some of the information made available to the PLC through System Variables:
; 1. Encoder positions: SV_MPU11_ABS_POS_1 - SV_MPU11_ABS_POS_7
; 2. Parameter values: SV_MACHINE_PARAMETER_1 - SV_MACHINE_PARAMETER_999
; 3. Spindle Speed command from PC: SV_PC_DAC_SPINDLE_SPEED
; 4. PC Keyboard Keypress: SV_PC_FUNCTION_1 - SV_PC_FUNCTION_127
; 5. ...

;   Some of the functionality controlled by the PLC through System Variables:
; 1. Axis jogging: SV_PLC_FUNCTION_12 - SV_PLC_FUNCTION_23
; 2. "Final" Spindle speed reported to PC: SV_PLC_SPINDLE_SPEED -provides nearly
;     unlimited gear ranges
; 3. Feedrate (through override knob): SV_PLC_FeedrateKnob_W
; 4. Custom debounce, invert/force inputs: SV_PLC_DEBOUNCE_1-SV_PLC_DEBOUNCE_64
; 5. ...

;-------------------------------------------------------------------------------
;        PLC Input manipulation - SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_64
; The System Variables in this section are used to modify the characteristics
; of PLC inputs 1-240.  Each input can be inverted, forced or assigned a custom
; debounce time.

;-----------------------------Debounce Times------------------------------------
; SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64 are used to define up to seven custom
; debounce times which can be selected for each input.

; The 32 bit integer System Variables SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64,
; are broken up into 8, 16 bit words, only 7 of which are used. The first word,
; the 16 MSB of SV_PLC_DEBOUNCE_61 is unused.  Each 16 bit word can be used to
; store a debounce time of between 0-32767 (the MSB of each word is unused).
; Debounce times are in increments of 62.5 usecs which provides debounce times
; of up to ~2 secs.

;                          SV_PLC_DEBOUNCE_61
;                     Unused:Bits 32-17 (Selection 0)
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                    Debounce Time Selection #1
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;                          SV_PLC_DEBOUNCE_62
;                      Debounce Time Selection #2
;         MSB 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16

;                      Debounce Time Selection #3
;              15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

;------------------------Configuring Input Behavior---------------------------
; Each System Variable from SV_PLC_DEBOUNCE_1 - SV_PLC_DEBOUNCE_60 is a 32 bit
; integer word broken up into 4 bit words to control the behavior of 4 inputs.
; Inputs 1-4 are configured using SV_PLC_DEBOUNCE_1, inputs 5-8 are handled
; using SV_PLC_DEBOUNCE_2 and so on to SV_PLC_DEBOUNCE_60 which controls inputs
; 237-240

; As mentioned above, each 32 bit word defines the charactersitics for 4 inputs.
; SV_PLC_DEBOUNCE_1 defines the characteristics of INP1, INP2, INP3 & INP4 and
; so on through SV_PLC_DEBOUNCE_60 which handles INP237, INP238, INP239&INP240.
; The behavior of an input is SET as follows:

; Five new operators have been introduced to simplify bit operations:
; BitSet, BitRst, BITTST, LShift & Rshift.  Below we will use bitset to
; invert an input.  This is convenient to use when a device is normally
; open and the logic is written for a normally closed device.  Inverting
; the input allows to reuse the existing logic rather than rewrite it.

; bitset and bitrst can not operate directly on SV_PLC_DEBOUNCE_# system
; variables, they can only operate on W32 variables.  In order to use bitset and
; bitrst to manipulate the debounce variables you'll have to perform all
; operations on a w32 first:

; Declare a W32:
; Inputs_9_12_W IS W1
; use bitst or bitrst
; if 1 == 1 THEN bitset Inputs_9_12_W 14  ;invert INP10 (bit14)

; Set Debounce system variable = to W32 variable
; if 1 == 1 THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

;---------------------System Variable = SV_PLC_DEBOUNCE_1---------------------
;                      Inp1 = bits 31-24        Inp2 = bits 23-16
;                MSB 31 30 29 28 27 26 25 24| 23 22 21 20 19 18 17 16

;                        Inp3 = bits 15-8       Inp4 = bits 7-0
;                      15 14 13 12 11 10 9 8| 7 6 5 4 3 2 1 0LSB

;                              Each 8 bit word from above
;      MSB       7      6      5      4      3      2      1      0     LSB
;              Force  Invert Spare  Spare  Spare  Debounce Select (7)
;                                                          selects 1 of 7
;                                                          debounce times
;                                                         (zero is invalid)
;     Force (bit 7): Set this bit to force the input to a 1* (closed)
;     Ivert (bit 6): Set this to invert an input
;     Spare(bit5-3): Not used
; Debounce(bit 0-2): Selects one of the 7 preset debounce times defined in
;                    SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64
;
;  *If you wish to force an input to 0, SET the both invert AND force bits
;   for the input.

;-------------------------------------------------------------------------------
; PLC Jog Panel input manipulation - The System Variables in this section are
; used to modify the characteristics of the Jog Panel keys.  The jog panel keys
; can be configured in the same manner as the PLC inputs and use debounce times
; as selected/SET in SV_PLC_DEBOUNCE_61 - SV_PLC_DEBOUNCE_64.
;-------------------------------------------------------------------------------


;----------------------------------------------------------------
;--SYSTEM VARIABLES:  JOG PANEL FUNCTIONS
;----------------------------------------------------------------
; Jog panel functions
;Invalid              IS SV_PLC_FUNCTION_0
DoCycleCancel         IS SV_PLC_FUNCTION_1
DoCycleStart          IS SV_PLC_FUNCTION_2
DoToolCheck           IS SV_PLC_FUNCTION_3
SelectSingleBlock     IS SV_PLC_FUNCTION_4
SelectX1JogInc        IS SV_PLC_FUNCTION_5
SelectX10JogInc       IS SV_PLC_FUNCTION_6
SelectX100JogInc      IS SV_PLC_FUNCTION_7
SelectUserJogInc      IS SV_PLC_FUNCTION_8
SelectIncContJog      IS SV_PLC_FUNCTION_9
SelectFastSlowJog     IS SV_PLC_FUNCTION_10
SelectMpgMode         IS SV_PLC_FUNCTION_11
DoAx1PlusJog          IS SV_PLC_FUNCTION_12
DoAx1MinusJog         IS SV_PLC_FUNCTION_13
DoAx2PlusJog          IS SV_PLC_FUNCTION_14
DoAx2MinusJog         IS SV_PLC_FUNCTION_15
DoAx3PlusJog          IS SV_PLC_FUNCTION_16
DoAx3MinusJog         IS SV_PLC_FUNCTION_17
DoAx4PlusJog          IS SV_PLC_FUNCTION_18
DoAx4MinusJog         IS SV_PLC_FUNCTION_19
DoAx5PlusJog          IS SV_PLC_FUNCTION_20
DoAx5MinusJog         IS SV_PLC_FUNCTION_21
DoAx6PlusJog          IS SV_PLC_FUNCTION_22
DoAx6MinusJog         IS SV_PLC_FUNCTION_23
DoAux1Key             IS SV_PLC_FUNCTION_24
DoAux2Key             IS SV_PLC_FUNCTION_25
DoAux3Key             IS SV_PLC_FUNCTION_26
DoAux4Key             IS SV_PLC_FUNCTION_27
DoAux5Key             IS SV_PLC_FUNCTION_28
DoAux6Key             IS SV_PLC_FUNCTION_29
DoAux7Key             IS SV_PLC_FUNCTION_30
DoAux8Key             IS SV_PLC_FUNCTION_31
DoAux9Key             IS SV_PLC_FUNCTION_32
DoAux10Key            IS SV_PLC_FUNCTION_33
SelectRapidOverride   IS SV_PLC_FUNCTION_34
SelectManAutoSpindle  IS SV_PLC_FUNCTION_35
DoSpindleStart        IS SV_PLC_FUNCTION_37
DoSpindleStop         IS SV_PLC_FUNCTION_38
DoAux13Key            IS SV_PLC_FUNCTION_39
DoAux14Key            IS SV_PLC_FUNCTION_40
SelectCoolantFlood    IS SV_PLC_FUNCTION_43
SelectCoolantMist     IS SV_PLC_FUNCTION_44
DoFeedHold            IS SV_PLC_FUNCTION_45
SelectSpindleCCW      IS SV_PLC_FUNCTION_98
SelectSpindleCW       IS SV_PLC_FUNCTION_99
SelectCoolAutoMan     is SV_PLC_FUNCTION_104
DoIncreaseSpindleOr   IS SV_PLC_FUNCTION_106
DoDecreaseSpindleOr   IS SV_PLC_FUNCTION_107
SelectSpinOr100       IS SV_PLC_FUNCTION_108

;-----------------------------------------------------------------------------
;--SYSTEM VARIABLES:  KEYBOARD JOGGING FUNCTIONS
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
; Keyboard Jogging Keys - The System Variables in this section inform the PLC
; that a PC keyboard keypress has occured.  Keep in mind that some key presses
; only come down while the keyboard jogging screen is enabled (alt-j) and that
; NONE of these keys not perform ANY default actions unless programmed to do so.
; The assignments provided below are for reference only.  For an example of
; mapping a keyboard key press to an MPU11 action, see the logic assigned to
; KbCycleStart_M or KbCycleCancel_M.
;
;Note:
; Keypresses are sent down as individual keys.  It is the resposibility of
; the PLC programmer to insure that a keypress is only acted on at the
; appropriate times.
; The "SV_PC_VIRTUAL_JOGPANEL_ACTIVE" system variable can be used to prevent
; a keypress form being acted on unless the keyboard jog screen is being
; displayed.  NOTE The above,29 character sys variable is mapped to
; KbJpActive_M (MEM80) to make it a "little" shorter......
;-----------------------------------------------------------------------------
Kb_a              IS SV_PC_KEYBOARD_KEY_60
Kb_b              IS SV_PC_KEYBOARD_KEY_79
Kb_c              IS SV_PC_KEYBOARD_KEY_77
Kb_d              IS SV_PC_KEYBOARD_KEY_62
Kb_e              IS SV_PC_KEYBOARD_KEY_41
Kb_f              IS SV_PC_KEYBOARD_KEY_63
Kb_g              IS SV_PC_KEYBOARD_KEY_64
Kb_h              IS SV_PC_KEYBOARD_KEY_65
Kb_i              IS SV_PC_KEYBOARD_KEY_46
Kb_j              IS SV_PC_KEYBOARD_KEY_66
Kb_k              IS SV_PC_KEYBOARD_KEY_67
Kb_l              IS SV_PC_KEYBOARD_KEY_68
Kb_m              IS SV_PC_KEYBOARD_KEY_81
Kb_n              IS SV_PC_KEYBOARD_KEY_80
Kb_o              IS SV_PC_KEYBOARD_KEY_47
Kb_p              IS SV_PC_KEYBOARD_KEY_48
Kb_q              IS SV_PC_KEYBOARD_KEY_39
Kb_r              IS SV_PC_KEYBOARD_KEY_42
Kb_s              IS SV_PC_KEYBOARD_KEY_61
Kb_t              IS SV_PC_KEYBOARD_KEY_43
Kb_u              IS SV_PC_KEYBOARD_KEY_45
Kb_v              IS SV_PC_KEYBOARD_KEY_78
Kb_w              IS SV_PC_KEYBOARD_KEY_40
Kb_x              IS SV_PC_KEYBOARD_KEY_76
Kb_y              IS SV_PC_KEYBOARD_KEY_44
Kb_z              IS SV_PC_KEYBOARD_KEY_75
Kb_spacebar       IS SV_PC_KEYBOARD_KEY_95
Kb_L_Shift        IS SV_PC_KEYBOARD_KEY_74
Kb_R_Shift        IS SV_PC_KEYBOARD_KEY_85
Kb_L_Alt          IS SV_PC_KEYBOARD_KEY_94
Kb_R_Alt          IS SV_PC_KEYBOARD_KEY_96
Kb_L_Ctrl         IS SV_PC_KEYBOARD_KEY_92
Kb_R_Ctrl         IS SV_PC_KEYBOARD_KEY_99
Kb_Ins            IS SV_PC_KEYBOARD_KEY_31
Kb_Home           IS SV_PC_KEYBOARD_KEY_32
Kb_End            IS SV_PC_KEYBOARD_KEY_53
Kb_PgDown         IS SV_PC_KEYBOARD_KEY_54
Kb_PgUp           IS SV_PC_KEYBOARD_KEY_33
Kb_Del            IS SV_PC_KEYBOARD_KEY_52
Kb_Back           IS SV_PC_KEYBOARD_KEY_30
Kb_Tab            IS SV_PC_KEYBOARD_KEY_38
Kb_Up             IS SV_PC_KEYBOARD_KEY_87
Kb_Down           IS SV_PC_KEYBOARD_KEY_101
Kb_Left           IS SV_PC_KEYBOARD_KEY_100
Kb_Right          IS SV_PC_KEYBOARD_KEY_102
Kb_Escape         IS SV_PC_KEYBOARD_KEY_1 ;Performs Cycle Cancel
Kb_F1             IS SV_PC_KEYBOARD_KEY_2
Kb_F2             IS SV_PC_KEYBOARD_KEY_3
Kb_F3             IS SV_PC_KEYBOARD_KEY_4
Kb_F4             IS SV_PC_KEYBOARD_KEY_5
Kb_F5             IS SV_PC_KEYBOARD_KEY_6
Kb_F6             IS SV_PC_KEYBOARD_KEY_7
Kb_F7             IS SV_PC_KEYBOARD_KEY_8
Kb_F8             IS SV_PC_KEYBOARD_KEY_9
Kb_F9             IS SV_PC_KEYBOARD_KEY_10
Kb_F10            IS SV_PC_KEYBOARD_KEY_11
Kb_F11            IS SV_PC_KEYBOARD_KEY_12
Kb_F12            IS SV_PC_KEYBOARD_KEY_13
Kb_Prt_Scrn       IS SV_PC_KEYBOARD_KEY_14
Kb_Scrl_Lck       IS SV_PC_KEYBOARD_KEY_15
Kb_Break          IS SV_PC_KEYBOARD_KEY_16
Kb_Num_Lock       IS SV_PC_KEYBOARD_KEY_34
Kb_1              IS SV_PC_KEYBOARD_KEY_18
Kb_2              IS SV_PC_KEYBOARD_KEY_19
Kb_3              IS SV_PC_KEYBOARD_KEY_20
Kb_4              IS SV_PC_KEYBOARD_KEY_21
Kb_5              IS SV_PC_KEYBOARD_KEY_22
Kb_6              IS SV_PC_KEYBOARD_KEY_23
Kb_7              IS SV_PC_KEYBOARD_KEY_24
Kb_8              IS SV_PC_KEYBOARD_KEY_25
Kb_9              IS SV_PC_KEYBOARD_KEY_26
Kb_0              IS SV_PC_KEYBOARD_KEY_27
Kb_10_Key_Div     IS SV_PC_KEYBOARD_KEY_35
Kb_10_Key_Mlt     IS SV_PC_KEYBOARD_KEY_36
Kb_10_Key_Sub     IS SV_PC_KEYBOARD_KEY_37
Kb_10_Key_0       IS SV_PC_KEYBOARD_KEY_103
Kb_10_Key_1       IS SV_PC_KEYBOARD_KEY_88
Kb_10_Key_2       IS SV_PC_KEYBOARD_KEY_89
Kb_10_Key_3       IS SV_PC_KEYBOARD_KEY_90
Kb_10_Key_4       IS SV_PC_KEYBOARD_KEY_71
Kb_10_Key_5       IS SV_PC_KEYBOARD_KEY_72
Kb_10_Key_6       IS SV_PC_KEYBOARD_KEY_73
Kb_10_Key_7       IS SV_PC_KEYBOARD_KEY_55
Kb_10_Key_8       IS SV_PC_KEYBOARD_KEY_56
Kb_10_Key_9       IS SV_PC_KEYBOARD_KEY_57
Kb_10_Key_Dec_Pt  IS SV_PC_KEYBOARD_KEY_104
Kb_10_Key_Plus    IS SV_PC_KEYBOARD_KEY_58
Kb_Num_Enter      IS SV_PC_KEYBOARD_KEY_91
Kb_L_Sq_Bracket   IS SV_PC_KEYBOARD_KEY_49
Kb_R_Sq_Bracket   IS SV_PC_KEYBOARD_KEY_50
Kb_Hypen          IS SV_PC_KEYBOARD_KEY_28
Kb_Equals         IS SV_PC_KEYBOARD_KEY_29
Kb_Comma          IS SV_PC_KEYBOARD_KEY_82
Kb_Period         IS SV_PC_KEYBOARD_KEY_83
Kb_Slash          IS SV_PC_KEYBOARD_KEY_84
Kb_Backslash      IS SV_PC_KEYBOARD_KEY_86

;----------------------------------------------------------------
;--M FUNCTIONS
;The System Variables in this section inform the
;PLC that an M function has been requested.
;----------------------------------------------------------------
M3   IS SV_M94_M95_1 ;(Spindle CW)
M4   IS SV_M94_M95_2 ;(Spindle CCW)
M8   IS SV_M94_M95_3 ;(Flood On)
M10  IS SV_M94_M95_4 ;(Chucks Close)
M11  IS SV_M94_M95_5 ;(Chucks Open)
M6   IS SV_M94_M95_6 ;(Tool Change)
;    IS SV_M94_M95_7 ;
;    IS SV_M94_M95_8 ;
;    IS SV_M94_M95_9 ;
;    IS SV_M94_M95_10;
;    IS SV_M94_M95_11;
;    IS SV_M94_M95_12;
;    IS SV_M94_M95_13;
;    IS SV_M94_M95_14;
;    IS SV_M94_M95_15;
;    IS SV_M94_M95_16;

;-----------------------------------------------------------------------------
;--WORD DEFINITIONS (INT32)
;-----------------------------------------------------------------------------
ErrorCode_W          IS W1
TwelveBitSpeed_W     IS W2
LubeAccumTime_W      IS W3
KbOverride_W         IS W4
FeedrateKnob_W       IS W5
CycloneStatus_W      IS W6
FinalFeedOverride_W  IS W7
PLC_Fault_W          IS W8
PLCFaultAddr_W       IS W9
Last_FeedrateKnob_W  IS W10
AsyncMsg_W           IS W11
P148Value_W          IS W12
P1Value_W            IS W13
MaxTools_W           IS W14
ToolNumber_W         IS W15
WantedToolNumber_W   IS W16
TempToolNumber_W     IS W17
Temp_W               IS W18
Lube_W               IS W21
LubeM_W              IS W22
LubeS_W              IS W23
Inputs_9_12_W        IS W28
P170Value_W          IS W30
P178Value_W          IS W31
SpinSpeedCommand_W   IS W32

;-----------------------------------------------------------------------------
;--WORD DEFINITIONS (F32)
;-----------------------------------------------------------------------------
SpinRangeAdjust_FW  IS FW1
RPMPerBit_FW        IS FW2
CfgMinSpeed_FW      IS FW3
CfgMaxSpeed_FW      IS FW4
TwelveBitSpeed_FW   IS FW5

;-----------------------------------------------------------------------------
;--ONE SHOT DEFINITIONS
;-----------------------------------------------------------------------------
IncrContPD            IS PD1
SlowFastPD            IS PD2
MpgPD                 IS PD3
SingleBlockPD         IS PD4
FeedHoldPD            IS PD5
SpinAutoManPD         IS PD6
SpindlePlusPD         IS PD7
SpinOverMinusPD       IS PD8
SpinOver100PD         IS PD9
SpinStartPD           IS PD10
SpinStopPD            IS PD11
SpinCWPD              IS PD12
SpinCCWPD             IS PD13
F9PD                  IS PD14
x1JogPD               IS PD15
x10JogPD              IS PD16
x100JogPD             IS PD17
Aux13KeyPD            IS PD18
RapidOverPD           IS PD19
CoolantAutoManualPD   IS PD21
CoolantFloodPD        IS PD22
CoolantMistPD         IS PD23
ToolCheckPD           IS PD24
JogProbeFaultPD       IS PD25
RigidTapPD            IS PD26
Aux1KeyPD             IS PD27
Aux2KeyPD             IS PD28
TurretIndexKeyPD      IS PD29
PCSpindleStartStopPD  IS PD30
PCSpindleManualPD     IS PD31
PCSpindleCWPD         IS PD32
PCSpindleCCWPD        IS PD33
Aux4KeyPD             IS PD34
StopRunning_PD        IS PD35
SoftwareReadyPD       IS PD36
WorklightKeyPD        IS PD37
ChuckOpenPD           IS PD38
ChuckClosePD       IS PD39
M6_PD                 IS PD40

;-----------------------------------------------------------------------------
;--TIMER DEFINITIONS
;-----------------------------------------------------------------------------
; 1000 = 1 second for all timers.
;
MsgClear_T           IS T1
Sleep_T              IS T2
CycloneStatus_T      IS T3
Initialize_T         IS T4
WaitForNextTool_T    IS T5
WaitForTurretDown_T  IS T6
PauseBetweenTools_T  IS T7
ChuckOpen_T          IS T8
ChuckClose_T         IS T9
PauseBeforeTurretLock_T IS T10
PauseAfterToolChange_T IS T11
LubeM_T              IS T13
LubeS_T              IS T14
ChuckCloseDelay_T    IS T15
ChuckOpenDelay_T     IS T16

;-----------------------------------------------------------------------------
;--STAGE DEFINITIONS
;-----------------------------------------------------------------------------
WatchDogStage                  IS STG1
InitialStage                   IS STG2
JogPanelStage                  IS STG3
MainStage                      IS STG4
AxesEnableStage                IS STG5
SpindleStage                   IS STG6
MPGStage                       IS STG7
CheckCycloneStatusStage        IS STG8
LoadCNC11ParametersStage       IS STG9
KeyboardEventsStage            IS STG10
AxesReconfiguredStage          IS STG11
LubeUsePumpTimersStage         IS STG13
LubeUsePLCTimersStage          IS STG14
ResetToolChangeStage           IS STG15
MonitorToolNumberStage         IS STG16
StartToolChangeStage           IS STG17
IndexTurretStage               IS STG18
MonitorToolChangeStage         IS STG19
WaitForToolNumberStage         IS STG20
MoveToNextTurretPositionStage  IS STG21
PauseBeforeTurretLockStage     IS STG22
WaitForTurretDownStage         IS STG23
PauseBetweenToolsStage         IS STG24
ToolChangeDoneStage            IS STG25
PauseAfterToolChangeStage      IS STG26
SetErrorStage                  IS STG50
BadErrorStage                  IS STG51



;-----------------------------------------------------------------------------
;********************************Program Start********************************
;-----------------------------------------------------------------------------



;-----------------------------------------------------------------------------
                      WatchDogStage
;-----------------------------------------------------------------------------

; Handle PLC executor faults. The only way to reset a PLC executor fault
; is to reboot the MPU11.
IF SV_PLC_FAULT_STATUS != 0 THEN
    PLC_Fault_W    = SV_PLC_FAULT_STATUS,
    PLCFaultAddr_W = SV_PLC_FAULT_ADDRESS,
    ErrorCode_W    = PLC_EXECUTOR_FLT_MSG, MSG ErrorCode_W,
    SET PLCExecutorFault_M, RST SetErrorStage, SET SV_STOP

; Handle software exit.
IF !SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN
    SET SoftwareReady_M,
    SET SV_STOP,
    ErrorCode_W = SOFTWARE_EXIT_MSG

IF SV_PC_SOFTWARE_READY && (SV_PLC_FAULT_STATUS == 0) THEN (SoftwareReadyPD)
IF SoftwareReadyPD && !SoftwareReady_M || !true THEN SET InitialStage

IF SoftwareReadyPD && SoftwareReady_M THEN RST SoftwareReady_M
;-----------------------------------------------------------------------------
;--end of WatchDogStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      InitialStage
;-----------------------------------------------------------------------------
IF 1==1 THEN SET true,
    SET OnAtPowerUp_M,
    SET AxesEnableStage,
    SET MainStage,
    SET JogPanelStage,
    SET LoadCNC11ParametersStage,
    SET MPGStage,
    SET PLCBus_Oe_M,
    SET ErrClr_M,
    RST PLCFault_M,
    CycloneStatus_T = 300,
    ErrorCode_W = MSG_CLEARED_MSG,
    RST BadErrorStage,
    SET SetErrorStage,
    Initialize_T = 1000,
    SET Initialize_T,
    RST SV_SPINDLE_LOW_RANGE,
    RST SV_SPINDLE_MID_RANGE,
    SpinRangeAdjust_FW = 1.2,
    SET ResetToolChangeStage,
    SET MonitorToolNumberStage,
    MaxTools_W = 4,
    WaitForNextTool_T = 7000,
    WaitForTurretDown_T = 3000,
    PauseBetweenTools_T = 1000,
    PauseBeforeTurretLock_T = 500,
    PauseAfterToolChange_T = 500,
    ChuckOpen_T = 3000,
    RST ChuckOpen_T,
    ChuckClose_T = 3000,
    RST ChuckClose_T,
    ChuckOpenDelay_T = 2000,
    RST ChuckOpenDelay_T,
    ChuckCloseDelay_T = 2000,
    RST ChuckCloseDelay_T,
    RST ChuckOpenSol,
    RST ChuckCloseSol,
    Temp_W = 0,
    RST InitialStage
;-----------------------------------------------------------------------------
;--end of InitialStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      LoadCNC11ParametersStage
;-----------------------------------------------------------------------------
; There are two methods of control for the lube pump and they are SET by CNC11
; Machine Parameter 179, where the value is between 0 - 65535 and is formatted
; as MMMSS where MMM is a time in minutes and SS is a time in seconds.
;
; METHOD 1 (SS == 0) For lube pumps with internal timers.
; METHOD 2 (SS != 0) For lube pumps with no timers (controlled soley by PLC).
;
; Load lube pump times from P179 and convert to milliseconds.
IF true THEN Lube_W = SV_MACHINE_PARAMETER_179,
             LubeM_W = (Lube_W / 100) * 60000,
             LubeS_W = (Lube_W % 100) * 1000

; Set the apprpriate stage according to method of control
IF LubeS_W == 0 THEN SET LubeUsePumpTimersStage,
                     RST LubeUsePLCTimersStage

IF LubeS_W != 0 THEN SET LubeUsePLCTimersStage,
                     RST LubeUsePumpTimersStage

IF true THEN P148Value_W = SV_MACHINE_PARAMETER_148,
             P170Value_W = SV_MACHINE_PARAMETER_170,
             P178Value_W = SV_MACHINE_PARAMETER_178

If true THEN BITTST P148Value_W 1 DisableKbInput_M
IF true && !DisableKbInput_M THEN BITTST P170Value_W 0 AllowKbInput_M
If true THEN BITTST P170Value_W 1 JogOverOnly_M
If true THEN BITTST P170Value_W 2 KbOverOnly_M
IF JogOverOnly_M && KbOverOnly_M THEN RST KbOverOnly_M

If true THEN BITTST P178Value_W 0 InvLubeOk_M
If true THEN BITTST P178Value_W 1 InvSpinInverterOk_M
;-----------------------------------------------------------------------------
;--end of LoadCNC11ParametersStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      LubeUsePumpTimersStage
;-----------------------------------------------------------------------------

; METHOD 1 (SS == 0) For lube pumps with internal timers.
;
; When using this method, P179 should be SET such that MMM is a
; value that is greater than the cycle time SET on the internal timers and
; SS should be SET to zero. How much greater MMM needs to be depends on the
; accuracy of the lube pump timers, but it is better to be on the long side
; to ensure proper operation.
;
; Example 1. The internal lube cycle interval is SET to 60 minutes.
;            Set P179 = 7500. In this example, as long as the accuracy
;            of the lube timer interval causes the lube to turn on
;            within 75 minutes, it will work. Note that the amount of time
;            that lube is output is usually SET with another timer control
;            on the lube pump and it does not factor into the setting of P179.
;
; It should be noted that lube pumps with internal timers may differ on how
; they operate.
;
; (a) For pumps that lube immediately when power is applied and then start timing
; until the next cycle, it is possible to run out of lube quickly on short job
; runs if, after the program has been run, lube power is removed.
;
; (b) For pumps that do not lube until it has been turned on for the interval time,
; it is possible that lube never gets applied if, after the short program has been run,
; lube power is removed.
;
; A short program or job run is defined as a job that finishes before
; the interval setting (60 minutes in the above example).
;
; For the above mentioned reasons, we want the power to be applied for at least
; the amount of time SET by the inteval timer, noting that if the user decides
; to engage the E-stop to remove power after short jobs, then they risk the
; above mentioned problems accoding to the type of pump.
;
; On the start of SV_PROGRAM_RUNNING, the lube pump turns on.
; The lube pump is turned off when a program has NOT been
; running continuously for MMM minutes or E-stop is engaged.
; The reason the lube pump is turned off after a program has NOT been
; running for MMM minutes is to prevent lubing when the user leaves for the
; weekend, leaving the machine on and E-stop disengaged.

IF SV_PROGRAM_RUNNING THEN SET Lube,
    RST LubeM_T
IF !SV_PROGRAM_RUNNING THEN LubeM_T = LubeM_W,
    SET LubeM_T
IF LubeM_T || !EStopOk THEN RST Lube
;-----------------------------------------------------------------------------
;--end of LubeUsePumpTimersStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      LubeUsePLCTimersStage
;-----------------------------------------------------------------------------
;
; METHOD 2 (SS != 0) For lube pumps that do not have internal timers.
;
;  When using this method P179 should be SET so the lube turns on
;  every MMM minutes for SS seconds.
;
;  Example 1.
;    To SET the lube pump power to come on for 5 seconds
;    every 10 minutes, SET P179 =  1005.
;                                 MMMSS
;  Example 2.
;    To SET the lube pump power to come on for 30 seconds
;    every 2 hours, SET P179 = 12030
;                              MMMSS
;
; This method will accumulate time while a program is running until
; it reaches MMM minutes, at which time it will apply power
; for SS seconds (unless E-stop is engaged) and then start over. It is
; possible with frequent use of E-stop that a lube cycle is cut short.
;

IF SV_PROGRAM_RUNNING  THEN LubeM_T = LubeM_W,
    SET LubeM_T
IF !SV_PROGRAM_RUNNING THEN (StopRunning_PD)
IF StopRunning_PD THEN LubeAccumTime_W = LubeAccumTime_W + LubeM_T,
    RST LubeM_T
IF LubeM_T || (LubeAccumTime_W + LubeM_T > LubeM_W) THEN SET Lube,
    LubeS_T = LubeS_W,
    SET LubeS_T,
    RST LubeM_T,
    LubeAccumTime_W = 0
IF LubeS_T || !EStopOk THEN RST Lube,
    RST LubeS_T
;-----------------------------------------------------------------------------
;--end of LubeUsePLCTimersStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      KeyboardEventsStage
;-----------------------------------------------------------------------------
; This stage handles functions that are required for menu navigation
; by CNC11, require multiple keypresses and/or need to be interlocked
; with SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  Regarding
; "AllowKbInput_M": This PLC program reads a bit from a system parameter,
; in this case bit 0 of SV_MACHINE_PARAMETER_170, and sets "AllowKbInput_M"
; if the bit is a "0".  If the operator wishes to allow keyboard input
; to trigger PLC events, they must SET parameter 170 to a "1"
; (or any odd number for that matter).  It should be mentioned that
; the programmer will not want to interlock all keyboard keys with
; SV_PC_VIRTUAL_JOGPANEL_ACTIVE and/or AllowKbInput_M.  For example:
; The "escape" key must be echoed by the PLC to CNC11 to aid in menu
; navigation.  NOTE: For backward comaptibility with CNC10, setting bit 1
; of SV_MACHINE_PARAMETER_148 OR clearing bit 0 of SV_MACHINE_PARAMETER_170
; will disable keyboard jogging.

;-------------------------Not interlocked
; The for cycle cancel has been moved to the main stage.
; It is commented out below but remains for referrence
;Cycle Cancel
;if Kb_Escape THEN (KbCycleCancel_M)

;Rapidoverride: Ctrl-r
IF Kb_r && (Kb_L_Ctrl || Kb_R_Ctrl) THEN (KbTogRapidOver_M)

;----------------Interlocked with AllowKbInput_M
;KbCycle Start: alt-s
IF  Kb_s && (Kb_R_Alt || Kb_L_Alt) && AllowKbInput_M THEN (KbCycleStart_M)

;KbToolCheck_M: Ctrl-t
IF Kb_t && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbToolCheck_M)

;KbTogSingleBlock_M: ctrl-b
IF Kb_b && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSingleBlock_M)

;KbTogSpinAutoMan_M: ctrl-a
IF Kb_a && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogSpinAutoMan_M)

;KbSpinCW_M: ctrl-c
IF Kb_c && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCW_M,
    RST KbSpinCCW_M

;KbSpinCCW_M: ctrl-w
IF Kb_w && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN SET KbSpinCCW_M,
    RST KbSpinCW_M

;KbSpinStart_M:  ctrl-s
IF Kb_s && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStart_M)

;KbSpindle stop: Ctrl-q
IF Kb_q && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinStop_M)

;KbIncSpinOver_M: ctrl (">")
IF Kb_Period && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN
    (KbIncSpinOver_M)

;KbDecSpinOver_M: ctrl ("<")
IF Kb_Comma && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN
    (KbDecSpinOver_M)

;KbSpinOver100_M: ctrl + /
IF Kb_Slash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbSpinOver100_M)

;KbTogCoolAutoMan_M: Ctrl-m
IF Kb_m && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogCoolAutoMan_M)

;KbFloodOnOff_M: Ctrl-n
IF Kb_n && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbFloodOnOff_M)

;KbMistOnOff_M: Ctrl-k
;IF Kb_k && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbMistOnOff_M)

;KbTogIncContJog_M: "ctrl" +  "i"
IF Kb_i &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogIncContJog_M)

;KbTogFastSlowJog_M: "ctrl" + "f"
IF Kb_f &&  (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbTogFastSlowJog_M)

;KbAux1Key_M: "ctrl" + "F1"
IF Kb_F1 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux1Key_M)

;KbAux2Key_M: "ctrl" + "F2"
IF Kb_F2 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux2Key_M)

;KbAux3Key_M: "ctrl" + "F3"
IF Kb_F3 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux3Key_M)

;KbAux4Key_M: "ctrl" + "F4"
IF Kb_F4 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux4Key_M)

;KbAux5Key_M: "ctrl" + "F5"
IF Kb_F5 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux5Key_M)

;KbAux6Key_M: "ctrl" + "F6"
IF Kb_F6 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux6Key_M)

;KbAux7Key_M: "ctrl" + "F7"
IF Kb_F7 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux7Key_M)

;KbAux8Key_M: "ctrl" + "F8"
IF Kb_F8 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux8Key_M)

;KbAux9Key_M: "ctrl" + "F9"
IF Kb_F9 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux9Key_M)

;KbAux10Key_M: "ctrl" + "F10"
IF Kb_F10 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux10Key_M)

;KbAux11Key_M: "ctrl" + "F11"
IF Kb_F11 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux11Key_M)

;KbAux12Key_M: "ctrl" + "F12"
IF Kb_F12 && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN (KbAux12Key_M)

;KbIncFeedOver_M: "ctrl" + "keyboard +" (actually "=")
IF Kb_Equals && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN
    (KbIncFeedOver_M)

;KbDecFeedOver_M: "ctrl" + "keyboard -"
IF Kb_Hypen && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN
    (KbDecFeedOver_M)

;KbFeedOver100_M: "ctrl" + "keyboard \"
IF Kb_Backslash && (Kb_L_Ctrl || Kb_R_Ctrl) && AllowKbInput_M THEN
    (KbFeedOver100_M)


;--------Interlocked with AllowKbInput_M && KbJpActive_M

;KbIncreaseJogInc_M: "insert"
IF Kb_Ins && AllowKbInput_M && KbJpActive_M THEN (KbIncreaseJogInc_M)
IF KbIncreaseJogInc_M && x1JogLED && !X1_M && !X10_M && !X100_M THEN SET X10_M
IF KbIncreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M THEN SET X100_M

;KbDecreaseJogInc_M: "delete"
IF Kb_Del && AllowKbInput_M && KbJpActive_M
  THEN (KbDecreaseJogInc_M)
IF KbDecreaseJogInc_M && x10JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X1_M
IF KbDecreaseJogInc_M && x100JogLED && !X1_M && !X10_M && !X100_M
  THEN SET X10_M


;KbJogAx1Plus_M: Right arrow
IF Kb_Left && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Plus_M)

;KbJogAx1Minus_M: Right arrow
IF Kb_Right && AllowKbInput_M && KbJpActive_M THEN (KbJogAx1Minus_M)

;KbJogAx2Plus_M: Up arrow
IF Kb_Up && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Plus_M)

;KbJogAx1Minus_M: Down arrow
IF Kb_Down && AllowKbInput_M && KbJpActive_M THEN (KbJogAx2Minus_M)

;KbJogAx3Plus_M: Page up
IF Kb_PgUp && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Plus_M)

;KbJogAx3Minus_M: Page Down
IF Kb_PgDown && AllowKbInput_M && KbJpActive_M THEN (KbJogAx3Minus_M)

;KbAx4PlusJog: "home"
IF Kb_Home && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Plus_M)

;KbAx4MinusJog: "end"
IF Kb_End && AllowKbInput_M && KbJpActive_M
  THEN (KbJogAx4Minus_M)

IF true THEN RST KeyboardEventsStage
;-----------------------------------------------------------------------------
;--end of KeyboardEventsStage
;-----------------------------------------------------------------------------


;-----------------------------------------------------------------------------
                      MPGStage
;-----------------------------------------------------------------------------
;--Turn on/off Jog Panel MPG LED & on the MPG
IF MPGKey THEN (MpgPD)
IF MpgPD && MPGLED THEN SET MPGManOffFlag_M
IF !SV_MPG_1_ENABLED || (MpgPD && !MPGLED) THEN RST MPGManOffFlag_M

IF (MpgPD && !MPGLED) || (SV_MPG_1_ENABLED && !MPGManOffFlag_M) &&
  !SV_PROGRAM_RUNNING THEN SET MPG_LED_OUT, SET MPGLED

IF (!SV_MPG_1_ENABLED || (MpgPD && MPGLED)) || SV_PROGRAM_RUNNING THEN
    RST MPG_LED_OUT,
    RST MPGLED

;x1, x10, x100 functions
;--X1
IF x1JogKey THEN (x1JogPD)
IF x1JogPD || OnAtPowerUp_M || X1_M || (MPG_Inc_X_1 && MPGLED) THEN
    SET x1JogLED,
    RST x10JogLED,
    RST x100JogLED

;--X10
IF x10JogKey THEN (x10JogPD)
IF x10JogPD || X10_M || (MPG_Inc_X_10 && MPGLED) THEN RST x1JogLED,
    SET x10JogLED,
    RST x100JogLED

;--X100
IF x100JogKey THEN (x100JogPD)
IF x100JogPD || X100_M || (MPG_Inc_X_100 && MPGLED) THEN RST x1JogLED,
    RST x10JogLED,
    SET x100JogLED

IF !KbIncreaseJogInc_M && !KbDecreaseJogInc_M THEN RST X1_M,
    RST X10_M,
    RST X100_M

;--MPG 1 Enable
IF MPG_AXIS_1 || MPG_AXIS_2 || MPG_AXIS_3 || MPG_AXIS_4 ||
  MPG_AXIS_5 || MPG_AXIS_6 || MPG_AXIS_7 || MPG_AXIS_8 THEN (SV_MPG_1_ENABLED)

;--Select axis to move
IF MPG_AXIS_1 THEN SV_MPG_1_AXIS_SELECT = 1
IF MPG_AXIS_2 THEN SV_MPG_1_AXIS_SELECT = 2
IF MPG_AXIS_3 THEN SV_MPG_1_AXIS_SELECT = 3
IF MPG_AXIS_4 THEN SV_MPG_1_AXIS_SELECT = 4

;--Select MPG 1 Multiplier
IF MPG_Inc_X_100 THEN SV_MPG_1_MULTIPLIER = 100
IF MPG_Inc_X_10 THEN  SV_MPG_1_MULTIPLIER = 10
IF MPG_Inc_X_1 THEN   SV_MPG_1_MULTIPLIER = 1

;--Disable "Windup" mode IF x100 selected
IF !MPG_Inc_X_100 THEN (SV_MPG_1_WINDUP_MODE)
;-----------------------------------------------------------------------------
;--end of MPGStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      JogPanelStage
;-----------------------------------------------------------------------------
;--Select Incremental or Continuous Jog Mode
IF IncrContKey || KbTogIncContJog_M THEN (IncrContPD)
IF (IncrContPD && !IncrContLED) || OnAtPowerUp_M THEN SET IncrContLED
IF (IncrContPD && IncrContLED) THEN RST IncrContLED

;--Select Fast or Slow Jog Mode
IF FastSlowKey || KbTogFastSlowJog_M THEN (SlowFastPD)
IF (SlowFastPD && !FastSlowLED) || OnAtPowerUp_M || MechnicalProbe THEN
    SET FastSlowLED
IF (SlowFastPD && FastSlowLED) THEN RST FastSlowLED

;--Single Block Mode functionality
IF SingleBlockKey || KbTogSingleBlock_M THEN (SingleBlockPD)
IF SingleBlockPD && !SingleBlockLED && !SV_PROGRAM_RUNNING THEN
    SET SingleBlockLED
IF SingleBlockPD && SingleBlockLED THEN RST SingleBlockLED
IF SingleBlockLED THEN (SelectSingleBlock)

;--Toolcheck functionality
IF (ToolCheckKey || KbToolCheck_M) && EstopOk THEN (ToolCheckPD)
IF ToolCheckPD THEN (DoToolCheck)

;--Feed Hold Mode
IF (FeedHoldKey || KbFeedHold_M) && SV_PROGRAM_RUNNING THEN (FeedHoldPD)
IF FeedHoldPD && !FeedHoldLED THEN SET FeedHoldLED
IF FeedHoldPD && FeedHoldLED && !SV_PROGRAM_RUNNING && !SV_MDI_MODE THEN
    RST FeedHoldLED
IF FeedHoldLED && (DoCycleStart || DoCycleCancel || ToolCheckPD) THEN
    RST FeedHoldLED
IF FeedHoldLED THEN SET DoFeedHold
IF !FeedHoldLED THEN RST DoFeedHold

;--Feedrate Override Section
;-------------------------------------------------------------------------
; Feedrate override works as follows:
;
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; 2. The PLC scales this value to a 0-200 value (0-200%) by dividing by
;    the knob value by 127.5 and THEN multiplying the result by 100
; 3. If keyboard joggin is not disabled (it is enabled by default), the PLC
;    determines whether the operator is using the keyboard override or
;    the FeedrateKnob_W to override the feedrate by watching which was changed
;    most recently.  The most recently changed value is saved as
;    "FinalFeedOverride_W"
; 4. Parameter 39 in (From the "params" scrren in CNC11 software) stores
;    a value which allows which the PLC program can use to limit the amount
;    of override applied to the programmed feedrate. This value is specified
;    as a percentage.
; 5. The PLC limits the override percentage by reading parameter 39 and, if
;    the feedrate override percentage as read from the knob is greater than
;    parameter 39, it sets the FinalFeedOverride_W value to the value of
;    parameter 39.
; 6. Once the override percentage has been determined and limited (if needed)
;    The PLC send this value up to the CNC11 software by setting
;    SV_PLC_FeedrateKnob_W = FinalFeedOverride_W
; 7. CNC11 reads SV_PLC_FEEDRATE_KNOB, factors in it's on own override based
;    on parameter 78 (see operators manual for more info on parm 78) and THEN
;    returns an override value to the PLC in the system variable
;    SV_PC_FEEDRATE_PERCENTAGE
; 8. The PLC reads SV_PC_FEEDRATE_PERCENTAGE and (typically) echoes the system
;    variable to SV_PLC_FEEDRATE_OVERRIDE which the MPU11 uses as the final
;    determination of the feedrate override percentage.
;-----------------------------------------------------------------------
; 1. The PLC reads the 8 bit value of the FeedrateKnob_W directly (0-255)
; NOTE: BTW = Bit To Word
; BTW reads the specified number of bits (if none is specified it defaults to 8)
; starting from a bit location and writes them to a word with the starting bit
; location being written to the LSB of the word used.  Below, BTW reads the bit
; values from JpFeedOrKnobBit0 to JpFeedOrKnobBit7 and writes them into to the
; word "FeedrateKnob_W" which sets FeedrateKnob_W to a value of 0-255
;-----------------------------------------------------------------------
IF true THEN BTW FeedrateKnob_W JpFeedOrKnobBit0 8

;-----------------------------------------------------------------------
; 2. Scale this value to a 0-200 value (0-200%)
;-----------------------------------------------------------------------
IF true THEN FeedrateKnob_W = (FeedrateKnob_W/127.5)*100
IF FeedrateKnob_W == 101 || FeedrateKnob_W == 99 THEN FeedrateKnob_W = 100

;-----------------------------------------------------------------------
; 3.  Determine whether to us FeedrateKnob_W or KbOverride_W
;-----------------------------------------------------------------------
; This section determines when to use the feedrate override value sent down
; by the jogpanel (FeedrateKnob_W) or the feedrate override as determined
; by the PLC monitoring the keyboard override keys (KbOverride_W).

;-------------------------------------------------------------------------------
;     At powerup, default feedrate override is jog panel (FeedrateKnob_W)
;       To use both keyboard or jogpanel overrides SET p170 to 0 (default)
;       To use jogpanel override only SET p170 to 2
;       To use keyboard only SET p170 to 4
;-------------------------------------------------------------------------------
IF OnAtPowerUp_M && KbOverOnly_M || KbFeedOver100_M THEN KbOverride_W = 100
IF OnAtPowerUp_M && !KbOverOnly_M THEN SET UsingFeedrateKnob_M,
  KbOverride_W = FeedrateKnob_W, Last_FeedrateKnob_W = FeedrateKnob_W

;--Calculate keyboard feedrate override
;Sleep_T is used to limit the KbOverride_W update rate to 20% per sec

IF AllowKbInput_M && KbIncFeedOver_M && !WaitingForSleepTimer_M THEN
    KbOverride_W = KbOverride_W + 1,
    RST UsingFeedrateKnob_M,
    SET WaitingForSleepTimer_M,
    Sleep_T = 50,
    SET Sleep_T

IF AllowKbInput_M && KbDecFeedOver_M && !WaitingForSleepTimer_M THEN
    KbOverride_W = KbOverride_W - 1,
    RST UsingFeedrateKnob_M,
    SET WaitingForSleepTimer_M,
    Sleep_T = 50,
    SET Sleep_T

IF Sleep_T THEN RST WaitingForSleepTimer_M,
    RST Sleep_T

;--Switch to FeedrateKnob_W if it changes more 3%
; Once it has changed by more than 3%, it will update as normal (1% increments)
; until it sees another KbOverride_W command at which point it will take
; another 3% change to re-activate the FeedrateKnob_W

IF (abs(Last_FeedrateKnob_W - FeedrateKnob_W) >= 3) || UsingFeedrateKnob_M
  THEN FinalFeedOverride_W = FeedrateKnob_W, KbOverride_W = FeedrateKnob_W,
  Last_FeedrateKnob_W = FeedrateKnob_W, SET UsingFeedrateKnob_M

;Limit keyboard override to parm 39.  Allowing the FeedrateKnob_W to go past
;parm 39, but keeping the KbOverride_W limited keeps the "dead space"
;down and allows the PLC to respond to changes in the FeedrateKnob_W even if
;above 120. Overall override is still limited later but this gives better
;response in changing between KbOverride_W & the FeedrateKnob_W

IF KbOverride_W > SV_MACHINE_PARAMETER_39 THEN
    KbOverride_W = SV_MACHINE_PARAMETER_39

IF !UsingFeedrateKnob_M && !JogOverOnly_M THEN
    FinalFeedOverride_W = KbOverride_W

;-----------------------------------------------------------------------
; 4 & 5. Limit override percentage to value SET in Parameter 39
;-----------------------------------------------------------------------
;------------Limit final override percentage to parm 39
IF FinalFeedOverride_W > SV_MACHINE_PARAMETER_39 THEN
    FinalFeedOverride_W = SV_MACHINE_PARAMETER_39

IF FinalFeedOverride_W < 0 THEN FinalFeedOverride_W = 0

; Override control bit for the feedrate override
; 1 == feedrate override knob will effect feedrate
; 0 == override knob has NO effect on feedrate
IF !SV_PC_OVERRIDE_CONTROL_FEEDRATE_OVERRIDE THEN FinalFeedOverride_W = 100

;-----------------------------------------------------------------------
; 6. Send override percentage to CNC11
;-----------------------------------------------------------------------
IF true THEN SV_PLC_FEEDRATE_OVERRIDE = FinalFeedOverride_W/100.0
IF true THEN SV_PLC_FEEDRATE_KNOB = FinalFeedOverride_W

;--End of Feedrate Override section

;--Rapid Override handling
IF KB_F9 THEN (F9PD)
IF KbTogRapidOver_M || (F9PD && SV_PROGRAM_RUNNING) THEN (RapidOverPD)
IF RapidOverPD ^ SelectRapidOverride THEN (SelectRapidOverride)
IF OnAtPowerUp_M THEN SET SelectRapidOverride

;Cycle Start/Cancel Keys
IF (CycleCancelKey || KbCycleCancel_M) && SV_PROGRAM_RUNNING THEN (DoCycleCancel)
IF (CycleStartKey  || KbCycleStart_M) THEN (DoCycleStart)

;Standard jogging setup for X & Z
;If parameters are SET to reverse the X+ & X- jog keys or to swap X & Z axes,
;the keys are switched in the AxesReconfigured stage
;Z
IF SwapAxes_M || InvertXJogKeys_M Then SET AxesReconfiguredStage
;Z
IF (Ax1PlusJogKey  || KbJogAx1Plus_M) && !SwapAxes_M && !InvertXJogKeys_M
  && !Ax1PlusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
    (DoAx1PlusJog)
IF (Ax1MinusJogKey || KbJogAx1Minus_M) && !SwapAxes_M && !InvertXJogKeys_M
  && !Ax1MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
    (DoAx1MinusJog)
;X
IF (Ax2PlusJogKey  || KbJogAx2Plus_M) && !SwapAxes_M && !InvertXJogKeys_M &&
  !Ax2PlusJogDisabled_M  && !(IncrContLED && FinalFeedOverride_W == 0) THEN
    (DoAx2PlusJog)
IF (Ax2MinusJogKey || KbJogAx2Minus_M) && !SwapAxes_M && !InvertXJogKeys_M &&
  !Ax2MinusJogDisabled_M && !(IncrContLED && FinalFeedOverride_W == 0) THEN
    (DoAx2MinusJog)

IF (Ax3PlusJogKey  || KbJogAx3Plus_M) &&
    !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3PlusJog)
IF (Ax3MinusJogKey || KbJogAx3Minus_M) &&
    !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx3MinusJog)
IF (Ax4PlusJogKey  || KbJogAx4Plus_M) &&
    !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4PlusJog)
IF (Ax4MinusJogKey || KbJogAx4Minus_M) &&
    !(IncrContLED && FinalFeedOverride_W == 0) THEN (DoAx4MinusJog)

IF (Aux1Key         || KbAux1Key_M) THEN (DoAux1Key)
IF (Aux2Key         || KbAux2Key_M) THEN (DoAux2Key)
IF (TurretIndexKey  || KbAux3Key_M) && !AirFault_M THEN (TurretIndexKeyPD), (DoAux3Key)
IF (Aux4Key         || KbAux4Key_M) THEN (DoAux4Key)
IF (Aux5Key         || KbAux5Key_M) THEN (DoAux5Key)
IF (Aux6Key         || KbAux6Key_M) THEN (DoAux6Key)
IF (WorklightKey    || KbAux7Key_M) THEN (WorklightKeyPD), (DoAux7Key)
IF (M11 || ChuckOpenKey || KbAux8Key_M) && !(AirFault_M || SV_STOP) THEN (ChuckOpenPD)
IF (M10 || ChuckCloseKey || KbAux9Key_M) && !(AirFault_M || SV_STOP) THEN (ChuckClosePD)
IF (Aux10Key        || KbAux10Key_M) THEN (DoAux10Key)
IF Aux13LED     THEN (DoAux13Key)
IF x1JogLED     THEN (SelectX1JogInc)
IF x10JogLED    THEN (SelectX10JogInc)
IF x100JogLED   THEN (SelectX100JogInc)
IF IncrContLED  THEN (SelectIncContJog)
IF FastSlowLED  THEN (SelectFastSlowJog)
IF MPGLED       THEN (SelectMpgMode)
IF FeedHoldLED  THEN (DoFeedHold)

;--Worklight
IF WorklightKeyPD ^ WorklightLED THEN (WorklightLED), (WorklightOut)

;--Turret Index Key
IF TurretIndexKeyPD && AirOk && !DoingToolChange_M && !SV_STOP THEN SET IndexTurretStage, SET TurretIndexLED

;--Coolant Functions

;--Toggle auto coolant mode
IF CoolAutoManKey || KbTogCoolAutoMan_M THEN (CoolantAutoManualPD)

IF (!CoolAutoManLED && CoolantAutoManualPD) || OnAtPowerUp_M
  THEN SET CoolAutoManLED

IF (CoolAutoManLED && CoolantAutoManualPD)
  THEN RST CoolAutoManLED

;--Report coolant mode to CNC11
IF CoolAutoManLED THEN (SelectCoolAutoMan)

;--Display coolant mode message
;changing to auto coolant mode ;9050 Auto Coolant Selected 2 + 50*256
IF (!CoolAutoManLED && CoolantAutoManualPD) THEN AsyncMsg_W = 12802,
    MSG AsyncMsg_W

;changing to manual coolant mode ;9051 Manual Coolant Selected 2 + 51*256
IF (CoolAutoManLED && CoolantAutoManualPD) THEN AsyncMsg_W = 13058,
    MSG AsyncMsg_W

;--Flood coolant on/off
IF ((CoolFloodKey || KbFloodOnOff_M) && !CoolAutoManLED) ||
  (M8 && CoolAutoManLED) || (DoCycleStart && M8 && CoolAutoManLED) THEN
    (CoolantFloodPD)

IF CoolantFloodPD && !CoolFloodLED THEN SET CoolFloodLED, SET Flood

IF SV_STOP || (CoolantFloodPD && CoolFloodLED) || (!M8 && CoolAutoManLED) ||
  (M8 && !CoolAutoManLED) || DoToolCheck THEN
    RST Flood,
    RST CoolFloodLED

IF CoolFloodLED THEN (SelectCoolantFlood)

;--Spindle Control
;-------------------------------------------------------------
; JOGBOARD SPINDLE CONTROL
; Spindle Auto Mode / Manual mode toggles via Auto/Man jog panel key
; CW/CCW jog keys determine spindle direction in manual mode
; M3/M4 system variables determine spindle direction in Auto mode
; Spindle can be stopped and restarted in auto mode using
; spin stop/start jog keys
;-------------------------------------------------------------
;--Select Auto or Manual Spindle Operation Mode
;Triggers to Toggle Auto/Manual Spindle Mode
IF SpinAutoManKey || KbTogSpinAutoMan_M THEN (SpinAutoManPD)

;--Set spindle to auto mode on startup
IF (SpinAutoManPD && !SpinAutoModeLED) || OnAtPowerUp_M THEN
    SET SpinAutoModeLED

;--Set spindle to manual mode
IF SpinAutoManPD && SpinAutoModeLED THEN RST SpinAutoModeLED

;--Report the Spindle mode to CNC11
IF SpinAutoModeLED THEN (SelectManAutoSpindle)

;--Set triggers to start and stop the spindle
;--------------------------------------------------------------
; NOTE: SpindlePause_M allows the operator to start and stop the
; spindle with the spin start and stop keys while in a job.  In
; this case, pressing the spindle start key will only restart
; the spindle if an M3 or M4 had previously been issued and is
; still active.

IF !SV_MDI_MODE && !SV_PROGRAM_RUNNING THEN RST M3,RST M4
IF ((SpinStartKey || KbSpinStart_M) && !SpinAutoModeLED) ||
    (SpinAutoModeLED && (M3 || M4) && !SpindlePause_M) ||
    ((SpinStartKey || KbSpinStart_M) && ((M3 || M4) && SpinAutoModeLED))
    THEN (SpinStartPD), RST SpindlePause_M

If (SpinAutoModeLED && (M3 || M4) && (SpinStopKey || KbSpinStop_M)) THEN
    SET SpindlePause_M

If (SpinStopKey || KbSpinStop_M) || (SpinAutoModeLED && !M3 && !M4) ||
  (SpinAutoManPD && SpindleEnableOut) || (SV_PC_RIGID_TAP_SPINDLE_OFF &&
  SpinAutoModeLED) THEN (SpinStopPD)

;Adjust spindle override when entering manual or auto spin mode
;Set the override value to 100% when spin auto mode is first selected
IF SpinAutoManPD && !SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 100,
    SET SpinAutoModeLED

;Set the override value to 10% whenever manual mode is entered
IF SpinAutoManPD && SpinAutoModeLED THEN SV_PLC_SPINDLE_KNOB = 10,
    RST SpinAutoModeLED

;--Set spindle direction
;Clockwise direction
IF ((KbSpinCW_M || SpinCWKey) && !SpinAutoModeLED) || (M3 && SpinAutoModeLED)
    || (M3 && DoCycleStart) THEN (SpinCWPD)
IF SpinCWPD THEN RST SpindleDirectionOut
IF !SpindleDirectionOut THEN (SpindleCWLED), (SelectSpindleCW)

;Counterclockwise direction
IF ((KbSpinCCW_M || SpinCCWKey) && !SpinAutoModeLED) || (M4 && SpinAutoModeLED)
    || (M4 && DoCycleStart) THEN (SpinCCWPD)
IF SpinCCWPD THEN SET SpindleDirectionOut
IF SpindleDirectionOut THEN (SpindleCCWLED), (SelectSpindleCCW)


;--Turn spindle on/off
IF ProbeDetect && SpinStartPD THEN SET ProbeFault_M

;only turn on the spindle if the chuck is not moving in or out
IF ((SpindleEnableOut || SpinStartPD ) && !SpinStopPD && !SV_STOP &&
    !ProbeDetect && SpindleInverterOk) && !(ChuckOpenLED || ChuckCloseLED)
    THEN (SpindleEnableOut), (InverterEStop)

IF SpindleEnableOut && (ChuckOpenLED || ChuckCloseLED) THEN 
    ErrorCode_W = SPINDLE_CHUCK_WARNING_MSG, MSG ErrorCode_W

IF !SpindleEnableOut  THEN (DoSpindleStop)

;-------------------------------------------------------
;          SPINDLE OVERRIDE CONTROL
;       Jogboard (-, +, and 100% keys),
; Keyboard "shift" + "<", "shift" + ">", "shift" + "<" & ">"
;-------------------------------------------------------
IF SpinOverPlusKey || KbIncSpinOver_M THEN
    SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB + 1
IF SpinOverMinusKey || KbDecSpinOver_M THEN
    SV_PLC_SPINDLE_KNOB = SV_PLC_SPINDLE_KNOB - 1
IF SpinOver100Key || KbSpinOver100_M || OnAtPowerUp_M THEN
    SV_PLC_SPINDLE_KNOB = 100

IF SV_PLC_SPINDLE_KNOB < 1  THEN SV_PLC_SPINDLE_KNOB = 1
IF SV_PLC_SPINDLE_KNOB > 200 THEN SV_PLC_SPINDLE_KNOB = 200

IF SV_PLC_SPINDLE_KNOB == 100 THEN (SpinOver100LED), (SelectSpinOr100)

IF SV_PLC_SPINDLE_KNOB < 100 THEN (SpinOverMinusLED), (DoDecreaseSpindleOr )

IF SV_PLC_SPINDLE_KNOB > 100 THEN (SpinOverPlusLED), (DoIncreaseSpindleOr)

;Calculate Correct analog value to send to spindle
;--Read commanded spindle speed, max & min
; ***NOTE***  SV_PC_COMMANDED_SPINDLE_SPEED already has override
;             factored in.
IF true THEN SpinSpeedCommand_W =  SV_PC_COMMANDED_SPINDLE_SPEED,
             CfgMinSpeed_FW = SV_PC_CONFIG_MIN_SPINDLE_SPEED,
             CfgMaxSpeed_FW = SV_PC_CONFIG_MAX_SPINDLE_SPEED

;----------------------------------------------------------------
; If commanded spindle speed is < Min Spin Speed * SpinRangeAdjust_FW
; & commanded spindle speed > 0, force to commanded spindle speed
; = min spin speed value * SpinRangeAdjust_FW.
;----------------------------------------------------------------
IF (SpinSpeedCommand_W > 0) &&
  (SpinSpeedCommand_W < (CfgMinSpeed_FW * SpinRangeAdjust_FW)) THEN
    SpinSpeedCommand_W = (CfgMinSpeed_FW * SpinRangeAdjust_FW),
    ErrorCode_W = MIN_SPEED_MSG

;---------------------------------------------------------------------------
; If SpinSpeedCommand_W > Max Spin Speed * SpinRangeAdjust_FW, force
; SpinSpeedCommand_W = max spin speed value * SpinRangeAdjust_FW.
;---------------------------------------------------------------------------
IF SpinSpeedCommand_W > (CfgMaxSpeed_FW * SpinRangeAdjust_FW) THEN
    SpinSpeedCommand_W = (CfgMaxSpeed_FW * SpinRangeAdjust_FW)

;----------------------------------------------------------------
; Convert Spindle "S" command to 12 bit value for output to DAC
;----------------------------------------------------------------
; Commanded Spindle speed (includes override factor) is sent down from CNC11
; in SV_PC_COMMANDED_SPINDLE_SPEED.  This value needs to be converted to a
; 12 bit value (0-4095) where full scale = SV_PC_CONFIG_MAX_SPINDLE_SPEED.

; Calculate #RPM's per bit of resolution
IF CfgMaxSpeed_FW > 0 THEN RPMPerBit_FW = CfgMaxSpeed_FW/4095
IF CfgMaxSpeed_FW <= 0 THEN RPMPerBit_FW = 1

;Convert RPM to 12 bit value
IF true THEN TwelveBitSpeed_FW = SpinSpeedCommand_W/RPMPerBit_FW

; Bound min to 0, max to 4095
IF TwelveBitSpeed_FW < 0 THEN TwelveBitSpeed_W = 0
IF TwelveBitSpeed_FW > 4095 THEN TwelveBitSpeed_W = 4095

; Factor in gear range
IF true THEN TwelveBitSpeed_FW = (TwelveBitSpeed_FW/SpinRangeAdjust_FW)

;Convert to integer word for DAC & I/O display
IF true THEN TwelveBitSpeed_W = TwelveBitSpeed_FW

;--Output 12-bit DAC value for spindle control
If true THEN WTB TwelveBitSpeed_W SpinAnalogOutBit0 12

;Display calculated RPM value on PC
IF true THEN SV_PLC_SPINDLE_SPEED = SpinSpeedCommand_W
;-----------------------------------------------------------------------------
;end of Jog Panel Stage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      AxesReconfiguredStage
;-----------------------------------------------------------------------------
;X axis jog keys inverted, X & Z not swapped
;--Z
IF InvertXJogKeys_M && !SwapAxes_M && (Ax1PlusJogKey  || KbJogAx1Plus_M)
    THEN (DoAx1PlusJog)
IF InvertXJogKeys_M && !SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
    THEN (DoAx1MinusJog)
;--X
IF InvertXJogKeys_M && !SwapAxes_M && (Ax2PlusJogKey  || KbJogAx2Plus_M)
    THEN (DoAx2MinusJog)
IF InvertXJogKeys_M && !SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
    THEN (DoAx2PlusJog)

;X & Z axes are swapped, X not inverted
;--Z
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2PlusJogKey || KbJogAx2Plus_M)
  THEN (DoAx1PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
    THEN (DoAx1MinusJog)
;--X
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1PlusJogKey || KbJogAx1Plus_M)
    THEN (DoAx2PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
    THEN (DoAx2MinusJog)

;X & Z axes are swapped, X also inverted
;--Z
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2PlusJogKey || KbJogAx2Plus_M)
    THEN (DoAx1PlusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax2MinusJogKey  || KbJogAx2Minus_M)
    THEN (DoAx1MinusJog)

;--X
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1PlusJogKey || KbJogAx1Plus_M)
    THEN (DoAx2MinusJog)
IF !InvertXJogKeys_M && SwapAxes_M && (Ax1MinusJogKey || KbJogAx1Minus_M)
    THEN (DoAx2PlusJog)
;-----------------------------------------------------------------------------
;--end of AxesReconfiguredStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      CheckCycloneStatusStage
;-----------------------------------------------------------------------------
; Due to amount of time it takes to retrieve data from the cyclone, this stage
; is only called few times per second to help reduce scan time of the main PLC
; program.

;check PLC status bit
IF TRUE THEN BITTST SV_PC_CYCLONE_STATUS_1 21 PLCBusExtDevEn_M

;check input fiber
IF !SV_PLC_BUS_ONLINE THEN ErrorCode_W = PLC_INFLT,
    SET SetErrorStage,
    RST PLCBus_Oe_M,
    SET PLCFault_M

;check output fiber
IF SV_PLC_BUS_ONLINE && PLCBus_Oe_M && !PLCBusExtDevEn_M THEN
    ErrorCode_W = PLC_OUTFLT,
    SET SetErrorStage,
    SET PLCFault_M

;check miniPLC online status bit
;check the first Expansion board
IF true THEN BITTST SV_PC_MINI_PLC_ONLINE 0 ExpansionPLC_1_M
IF !ExpansionPLC_1_M && PLCBus_Oe_M THEN
    RST PLCBus_Oe_M,
    ErrorCode_W = MINI_PLC_1_FAULT_MSG,
    SET SetErrorStage,
    SET PLCFault_M

;check for Axis fault
IF SV_PC_POWER_AXIS_1 && !Axis1DriveOk THEN
    ErrorCode_W = AXIS1_DRIVE_FAULT_MSG,
    SET SetErrorStage,
    SET DriveFault_M

IF SV_PC_POWER_AXIS_2 && !Axis2DriveOk THEN
    ErrorCode_W = AXIS2_DRIVE_FAULT_MSG,
    SET SetErrorStage,
    SET DriveFault_M

IF SV_PC_POWER_AXIS_3 && !Axis3DriveOk THEN
    ErrorCode_W = AXIS3_DRIVE_FAULT_MSG,
    SET SetErrorStage,
    SET DriveFault_M

IF SV_PC_POWER_AXIS_4 && !Axis4DriveOk THEN
    ErrorCode_W = AXIS4_DRIVE_FAULT_MSG,
    SET SetErrorStage,
    SET DriveFault_M

;clear drive fault errors
IF DriveFault_M && ! PLCFault_M && !EstopOk THEN
    RST DriveFault_M,
    ErrorCode_W = AXIS_DRIVE_FAULT_CLR,
    SET SetErrorStage

;clear PLC errors
IF (PLCFault_M || ExpansionPLC_1_M) && SV_PLC_BUS_ONLINE
    && PLCBusExtDevEn_M && !EstopOk THEN
    RST PLCFault_M,
    RST ExpansionPLC_1_M,
    ErrorCode_W = PLC_FLT_CLR,
    SET SetErrorStage,
    SET PLCBus_Oe_M

;read parameter 178 and check the Lube NO/NC state
; Invert input 9
IF  InvLubeOk_M THEN BITSET Inputs_9_12_W 6
IF !InvLubeOk_M THEN BITRST Inputs_9_12_W 6

 ; Invert input 10
IF  InvSpinInverterOk_M THEN BITSET Inputs_9_12_W 14
IF !InvSpinInverterOk_M THEN BITRST Inputs_9_12_W 14
IF true THEN SV_PLC_DEBOUNCE_3 = Inputs_9_12_W

IF true THEN RST CheckCycloneStatusStage
;-----------------------------------------------------------------------------
;--end of CheckCycloneStatusStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      AxesEnableStage
;-----------------------------------------------------------------------------
IF (SV_PC_POWER_AXIS_1 || EnableAxes_M) && Axis1DriveOk THEN (SV_ENABLE_AXIS_1);, (Axis_1_Enable)
IF (SV_PC_POWER_AXIS_2 || EnableAxes_M) && Axis2DriveOk THEN (SV_ENABLE_AXIS_2);, (Axis_2_Enable)

;read the status bits
IF OnAtPowerUp_M || CycloneStatus_T THEN SET CheckCycloneStatusStage,
    CycloneStatus_T = 300,
    SET CycloneStatus_T

;turn on drives if no errors
;also turn on axes once Estop is released to prevent axes from drifting
IF EnableAxes_M && !PLCFault_M && !DriveFault_M && !SV_STALL_ERROR THEN SET SV_MASTER_ENABLE

IF PLCFault_M || DriveFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE,
    SET SV_STOP
;-----------------------------------------------------------------------------
;--end of AxesEnableStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      MonitorToolNumberStage
;-----------------------------------------------------------------------------
IF Tool1 THEN TempToolNumber_W = 1
IF Tool2 THEN TempToolNumber_W = 2
IF Tool3 THEN TempToolNumber_W = 3
IF Tool4 THEN TempToolNumber_W = 4
;report tool number to CNC11, if at a definite turret position
IF (Tool1 || Tool2 || Tool3 || Tool4) && !InvalidTool_M THEN ToolNumber_W = TempToolNumber_W,
    SV_PLC_CAROUSEL_POSITION = ToolNumber_W
;-----------------------------------------------------------------------------
;--end of MonitorToolNumberStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      ResetToolChangeStage
;-----------------------------------------------------------------------------
IF true THEN RST M6,
             RST TurretIndexSol,
             RST ToolChangeDone_M,
             RST DoingToolChange_M,
             RST MoveToNextTurretPositionStage,
             RST StartToolChangeStage,
             RST IndexTurretStage,
             RST MonitorToolChangeStage,
             RST ToolChangeDoneStage,
             RST ToolChangeFault_M,
             RST TurretIndexLED,
             RST WaitForTurretDownStage,
	     RST PauseBeforeTurretLockStage,
	     RST PauseBeforeTurretLock_T,
             RST WaitForTurretDown_T,
             RST WaitForNextTool_T,
             WantedToolNumber_W = ToolNumber_W,
             RST WaitToClearTool_M,
             RST WaitToArriveAtTool_M,
	     RST PauseAfterToolChangeStage,
	     RST InvalidTool_M,
             RST PauseAfterToolChange_T,
             RST ResetToolChangeStage

;-----------------------------------------------------------------------------
;--end of ResetToolChangeStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      IndexTurretStage
;-----------------------------------------------------------------------------
;move one turret position when the Aux3Key is pushed
;prevent invalid tool by limiting request to valid range
;IF InvalidTool_M THEN RST InvalidTool_M
IF true THEN WantedToolNumber_W = (ToolNumber_W + 1)
If WantedToolNumber_W > MaxTools_W THEN WantedToolNumber_W = 1

;IF true THEN WantedToolNumber_W = (ToolNumber_W + 1) % MaxTools_W

;start the turret moving
IF TurretAtTool THEN SET TurretIndexSol,
    SET DoingToolChange_M,
    SET WaitToClearTool_M,
    JMP MoveToNextTurretPositionStage
;-----------------------------------------------------------------------------
;--end of IndexTurretStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      StartToolChangeStage
;-----------------------------------------------------------------------------
;read the desired tool number

IF true THEN WantedToolNumber_W = SV_TOOL_NUMBER, SET DoingToolChange_M, RST InvalidTool_M

;if the tool number is out of range, warn the user and exit
IF WantedToolNumber_W > MaxTools_W THEN WantedToolNumber_W = ToolNumber_W,
    ErrorCode_W = INVALID_TOOL_MSG, MSG ErrorCode_W,
    SET InvalidTool_M,
    JMP ToolChangeDoneStage

;If not at desired tool, start moving
IF WantedToolNumber_W != ToolNumber_W THEN SET TurretIndexSol,
    SET MonitorToolChangeStage,
    SET WaitToClearTool_M,
    JMP MoveToNextTurretPositionStage

;If at tool then exit tool change
IF WantedToolNumber_W == ToolNumber_W THEN JMP ToolChangeDoneStage
;-----------------------------------------------------------------------------
;--end of StartToolChangeStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      MonitorToolChangeStage
;-----------------------------------------------------------------------------
;If E-stop is pushed or something else cancels the tool change part way through,
; turn off the tool change process
IF !M6 && DoingToolChange_M THEN RST MoveToNextTurretPositionStage,
    RST PauseBeforeTurretLockStage,
    RST WaitForTurretDownStage,
    RST PauseBetweenToolsStage,
    JMP ResetToolChangeStage
;-----------------------------------------------------------------------------
;--end of MonitorToolChangeStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      MoveToNextTurretPositionStage
;-----------------------------------------------------------------------------
;Regardless of whether the turret is locked down, when the turret is at 90 deg.
; increments the input TurretAtTool is SET. This is used to know when the
; turret has left the current tool and arrived at the next tool.

;start timer for this stage to make sure it doesn't take too long
IF true THEN SET WaitForNextTool_T

;wait for the turret to move away from the current tool
IF !TurretAtTool && WaitToClearTool_M THEN RST WaitToClearTool_M,
    SET WaitToArriveAtTool_M

;wait for the turret to get to the next tool
IF TurretAtTool && WaitToArriveAtTool_M THEN RST WaitToArriveAtTool_M,
    RST WaitForNextTool_T,
    RST TurretIndexSol,
    JMP PauseBeforeTurretLockStage

;if timer expires, it has taken too long to get to the next position
IF WaitForNextTool_T THEN SET ToolChangeFault_M, RST WaitForNextTool_T,
    SET SV_STOP,
    JMP ResetToolChangeStage,
    ErrorCode_W = TURRET_NOT_AT_TOOL_FAULT_MSG
;-----------------------------------------------------------------------------
;--end of MoveToNextTurretPositionStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      PauseBeforeTurretLockStage
;-----------------------------------------------------------------------------
;Wait for half a second between each tool
IF true THEN SET PauseBeforeTurretLock_T
IF PauseBeforeTurretLock_T THEN RST PauseBeforeTurretLock_T,
    JMP WaitForTurretDownStage
;-----------------------------------------------------------------------------
;--end of PauseBetweenToolsStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      WaitForTurretDownStage
;-----------------------------------------------------------------------------
;Wait for the Turret to lock down and if the tool desired is achieved, end tool
; change, otherwise index again.
IF true THEN SET WaitForTurretDown_T

;If turret has arrived at the final destination, exit
IF TurretLocked && (WantedToolNumber_W == ToolNumber_W) THEN
    RST WaitForTurretDown_T,
    JMP ToolChangeDoneStage

;If not at the correct tool, move on
IF TurretLocked && (WantedToolNumber_W != ToolNumber_W) THEN
    RST WaitForTurretDown_T,
    JMP PauseBetweenToolsStage

;if timer expires, it has taken too long to lock down and likely will not
IF WaitForTurretDown_T THEN SET ToolChangeFault_M, RST WaitForTurretDown_T,
    SET SV_STOP,
    JMP ResetToolChangeStage,
    ErrorCode_W = TURRET_DOWN_FAULT_MSG
;-----------------------------------------------------------------------------
;--end of WaitForTurretDownStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      PauseBetweenToolsStage
;-----------------------------------------------------------------------------
;Wait for a second between each tool
IF true THEN SET PauseBetweenTools_T
IF PauseBetweenTools_T THEN RST PauseBetweenTools_T,
    SET TurretIndexSol,
    SET WaitToClearTool_M,
    RST WaitForTurretDown_T,
    JMP MoveToNextTurretPositionStage
;-----------------------------------------------------------------------------
;--end of PauseBetweenToolsStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      ToolChangeDoneStage
;-----------------------------------------------------------------------------
;Now that we are at the desired tool, clean up
IF ToolNumber_W == WantedToolNumber_W THEN SET ToolChangeDone_M
IF ToolNumber_W != WantedToolNumber_W THEN SET ToolChangeFault_M,
    ErrorCode_W = TOOL_CHANGE_FAULT_MSG,
    JMP ResetToolChangeStage
IF !M6 THEN RST MonitorToolChangeStage,
    RST ToolChangeFault_M,
    JMP PauseAfterToolChangeStage
;-----------------------------------------------------------------------------
;--end of ToolChangeDoneStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      PauseAfterToolChangeStage
;-----------------------------------------------------------------------------
;Wait for a second between each tool
IF true THEN SET PauseAfterToolChange_T
IF PauseAfterToolChange_T THEN RST PauseAfterToolChange_T,
    RST DoingToolChange_M,
    RST ToolChangeDone_M,
    RST TurretIndexLED,
    ErrorCode_W = TOOL_CHANGE_DONE_MSG, MSG ErrorCode_W,
    RST PauseAfterToolChangeStage
;-----------------------------------------------------------------------------
;--end of PauseAfterToolChangeStage
;-----------------------------------------------------------------------------


;-----------------------------------------------------------------------------
                      SetErrorStage
;-----------------------------------------------------------------------------
IF !((ErrorCode_W % 256 == 1) || (ErrorCode_W % 256 == 2)) THEN JMP BadErrorStage
IF true THEN MSG ErrorCode_W
If ErrorCode_W != MSG_CLEARED_MSG Then MsgClear_T = 1000, SET MsgClear_T

IF (!EstopOk && !SoftwareReady_M) || ((ErrorCode_W != MSG_CLEARED_MSG) && (ErrorCode_W % 2 == 0) &&
  MsgClear_T) Then ErrorCode_W = MSG_CLEARED_MSG, RST MsgClear_T
;-----------------------------------------------------------------------------
;--end of SetErrorStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      BadErrorStage
;-----------------------------------------------------------------------------
IF true THEN AsyncMsg_W = 2+256*100, MSG AsyncMsg_W, AsyncMsg_W = 0
IF true THEN RST BadErrorStage
;-----------------------------------------------------------------------------
;--end of BadErrorStage
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
                      MainStage
;-----------------------------------------------------------------------------
;Do gather if commanded (umcomment and recompile for debugging purposes)
;IF Aux13Key THEN (Aux13KeyPD)
;If Aux13KeyPD THEN (SV_TRIGGER_PLOT_DUMP)

;IF Aux4Key THEN (Aux4KEYPD)
;IF Aux4KEYPD ^ Aux4LED THEN (TurretIndexSol), (Aux4LED)

;--Probe protection while jogging
If MechnicalProbe && !JogProbeFault_M && (DoAx1PlusJog || DoAx1MinusJog ||
  DoAx2PlusJog || DoAx2MinusJog || DoAx3PlusJog || DoAx3MinusJog ||
  DoAx4PlusJog || DoAx4MinusJog || DoAx5PlusJog || DoAx5MinusJog)
  THEN SET JogProbeFault_M, (JogProbeFaultPD)

IF JogProbeFaultPD THEN set SV_Stop, ErrorCode_W = PROBE_JOG_FAULT_MSG
IF JogProbeFaultPD && DoAx1PlusJog  THEN SET Ax1PlusJogDisabled_M,
                                         SET Ax2MinusJogDisabled_M,
										 SET Ax2PlusJogDisabled_M
IF JogProbeFaultPD && DoAx1MinusJog THEN SET Ax1MinusJogDisabled_M,
                                         SET Ax2MinusJogDisabled_M,
										 SET Ax2PlusJogDisabled_M
IF JogProbeFaultPD && DoAx2PlusJog  THEN SET Ax2PlusJogDisabled_M,
                                         SET Ax1MinusJogDisabled_M,
										 SET Ax1PlusJogDisabled_M
IF JogProbeFaultPD && DoAx2MInusJog THEN SET Ax2MinusJogDisabled_M,
                                         SET Ax1MinusJogDisabled_M,
										 SET Ax1PlusJogDisabled_M

IF !MechnicalProbe THEN RST JogProbeFault_M,
    RST Ax1PlusJogDisabled_M,
    RST Ax1MinusJogDisabled_M,
    RST Ax2PlusJogDisabled_M,
    RST Ax2MinusJogDisabled_M

;--Keyboard
;handle always active Keyboard commands
;Cycle Cancel
IF Kb_Escape THEN (KbCycleCancel_M)
;KbFeedHold_M: spacebar
IF Kb_spacebar && AllowKbInput_M && SV_PROGRAM_RUNNING THEN (KbFeedHold_M)

;Just a shorter name for SV_PC_VIRTUAL_JOGPANEL_ACTIVE
IF SV_PC_VIRTUAL_JOGPANEL_ACTIVE THEN (KbJpActive_M)

;Call KeyboardEvents stage if needed
IF Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt
    || Kb_L_Alt || KbJpActive_M THEN SET KeyboardEventsStage

IF (Kb_L_Ctrl || Kb_R_Ctrl || Kb_L_Shift || Kb_R_Shift || Kb_R_Alt || Kb_L_Alt)
    && (Kb_j || Kb_f || kb_a || kb_s) && !AllowKbInput_M THEN
    ErrorCode_W = KB_JOG_MSG

;--M-Codes

IF M6 && !AirFault_M THEN (M6_PD)
IF M6_PD THEN SET StartToolChangeStage

;check for air pressure when doing something that requires air.
IF !AirOk && (M6 || TurretIndexKeyPD ||
    M10 || M11 || ChuckOpenPD || ChuckClosePD)
    THEN ErrorCode_W = AIR_FAULT_MSG, SET AirFault_M

IF AirOK && AirFault_M && !EstopOK THEN RST AirFault_M

;--Chuck Open/Close M-Code/Aux keys
;do not turn on the chuck solenoids if spindle is running
;IF (ChuckOpenPD && !ChuckOpenLED && !ChuckCloseLED) && !(SpindleEnableOut) && !AirFault_M THEN
;    SET ChuckOpen_T, SET ChuckOpenLED, SET ChuckOpenSol
;IF (ChuckClosePD && !ChuckCloseLED && !ChuckOpenLED) && !(SpindleEnableOut) && !AirFault_M THEN
;    SET ChuckClose_T, SET ChuckCloseLED, SET ChuckCloseSol

IF ChuckOpenPD && !SpindleEnableOut && !AirFault_M THEN
    SET ChuckOpen_T, SET ChuckOpenLED, SET ChuckOpenSol, SET ChuckOpening_M
IF ChuckClosePD && !SpindleEnableOut && !AirFault_M THEN
    SET ChuckClose_T, SET ChuckCloseLED, SET ChuckCloseSol, SET ChuckClosing_M

;turn off Open/Close Solenoid outputs
IF ChuckOpen_T THEN
    RST ChuckOpenSol, RST ChuckOpen_T, SET ChuckOpenDelay_T
IF ChuckOpenDelay_T THEN
    RST ChuckOpenDelay_T, RST ChuckOpenLED, RST ChuckOpening_M, RST ChuckOpenSafety_M
    
IF ChuckClose_T THEN
    RST ChuckCloseSol, RST ChuckClose_T, SET ChuckCloseDelay_T
IF ChuckCloseDelay_T THEN
    RST ChuckCloseDelay_T, RST ChuckCloseLED, RST ChuckClosing_M


;If Opening the chuck and Close is commanded, immediately reverse and vice versa
IF ChuckOpenPD && ChuckClosing_M && !SpindleEnableOut && !AirFault_M
    THEN RST ChuckCloseLED, 
    RST ChuckClosing_M,
    RST ChuckClose_T,
    RST ChuckCloseDelay_T, 
    RST ChuckCloseSol, 
    SET ChuckOpen_T,
    SET ChuckOpening_M, 
    SET ChuckOpenSol,
    SET ChuckOpenSafety_M
IF ChuckClosePD && ChuckOpening_M && !SpindleEnableOut && !AirFault_M
    THEN RST ChuckOpenLED, 
    RST ChuckOpening_M,
    RST ChuckOpen_T,
    RST ChuckOpenDelay_T, 
    RST ChuckOpenSol, 
    SET ChuckClose_T,
    SET ChuckClosing_M, 
    SET ChuckCloseSol,
    SET ChuckCloseSafety_M

IF SpindleEnableOut && (ChuckClosePD || ChuckOpenPD) THEN 
    ErrorCode_W = SPINDLE_CHUCK_WARNING_MSG, MSG ErrorCode_W


;Reset these M-codes if not running a program or in MDI
IF !SV_PROGRAM_RUNNING THEN RST M3, RST M4, RST M6, RST M8, RST M10, RST M11

;--Faults
;deal with all motion preventing faults here

;set the Stop bit if any error has occured. This will cancel jobs
IF !EStopOk || PLCFault_M || SV_STALL_ERROR || SpindleFault_M ||
  LubeFault_M || AxisFault_M ||  ProbeFault_M || AirFault_M THEN SET SV_STOP

;reset stall error if E-Stop pushed in
IF !EstopOk && SV_STALL_ERROR THEN RST SV_STALL_ERROR

IF SV_STOP || PLCFault_M || SV_STALL_ERROR THEN RST SV_MASTER_ENABLE

IF !EstopOK && ProbeFault_M THEN RST ProbeFault_M, RST ProbeMsgSent_M
IF Initialize_T && !SpindleInverterOk THEN ErrorCode_W = SPINDLE_FAULT_MSG,
  Set SV_STOP, SET SpindleFault_M

  ;reset spindle inverter if there is a fault
IF !EstopOK && SV_SPINDLE_FAULT THEN (InverterResetOut), RST SpindleFault_M

;set user viewable memory bit to see if Master Enable is on
IF SV_MASTER_ENABLE THEN (MasterEnable_M)

;set user viewable memory bit to see if Stall Error is detected is on
IF SV_STALL_ERROR THEN (StallError_M)

;turn on E-Stop release output
;IF !SV_STOP THEN (NoFaultOut), (InverterEStop), (EnableAxes_M)
IF !SV_STOP THEN (NoFaultOut), (EnableAxes_M)

;turn on contactor to drives when there is not a fault
IF SV_STOP THEN (ReleaseAx1Estop), (ReleaseAx2Estop)

;Reset Tool Change logic if E-Stop is in
IF SV_STOP THEN SET ResetToolChangeStage
;IF true THEN RST ResetToolChangeStage

;only clear a Stop fault if no errors are present
IF EStopOk && !PLCFault_M && !SV_STALL_ERROR && !SpindleFault_M &&
  !LubeFault_M && SV_PLC_BUS_ONLINE && !PLCFault_M && !SoftwareReady_M &&
  !PLCExecutorFault_M THEN RST SV_STOP

;if there is a probe fault and the user has not been notified, do so now
IF ProbeFault_M && !ProbeMsgSent_M THEN ErrorCode_W = PROBE_FAULT_MSG,
    SET SetErrorStage,
    SET ProbeMsgSent_M

;turn off default state setup variable
IF true THEN RST OnAtPowerUp_M
;-----------------------------------------------------------------------------
;--end of MainStage
;-----------------------------------------------------------------------------
